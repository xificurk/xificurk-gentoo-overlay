diff -ibruN projects/openttd_vs80.vcproj projects/openttd_vs80.vcproj
--- projects/openttd_vs80.vcproj	2010-06-19 20:44:18.000000000 +0400
+++ projects/openttd_vs80.vcproj	2010-06-20 15:22:46.000000000 +0400
@@ -488,10 +488,26 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_copying.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_pasting.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\command.cpp"
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\command_queue.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\console.cpp"
 				>
 			</File>
@@ -708,6 +724,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\template.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\texteff.cpp"
 				>
 			</File>
@@ -728,6 +748,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\transform_tables.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\vehicle.cpp"
 				>
 			</File>
@@ -832,6 +856,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cmd_helper.h"
 				>
 			</File>
@@ -840,6 +868,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\command_queue.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\command_type.h"
 				>
 			</File>
@@ -1460,6 +1492,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\template.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\template_base.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\template_face.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\template_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\terraform_gui.h"
 				>
 			</File>
@@ -1764,6 +1812,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\company_gui.cpp"
 				>
 			</File>
@@ -2172,6 +2224,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\template_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\town_sl.cpp"
 				>
 			</File>
@@ -3328,6 +3384,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\misc\compactarray.hpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\misc\countedobj.cpp"
 				>
 			</File>
diff -ibruN projects/openttd_vs90.vcproj projects/openttd_vs90.vcproj
--- projects/openttd_vs90.vcproj	2010-06-19 20:44:18.000000000 +0400
+++ projects/openttd_vs90.vcproj	2010-06-20 15:31:14.000000000 +0400
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9.00"
+	Version="9,00"
 	Name="openttd"
 	ProjectGUID="{668328A0-B40E-4CDB-BD72-D0064424414A}"
 	RootNamespace="openttd"
@@ -134,14 +134,15 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="..\objs\$(PlatformName)\$(ConfigurationName)\"
-			IntermediateDirectory="..\objs\$(PlatformName)\$(ConfigurationName)\"
+			Name="Release|x64"
+			OutputDirectory="..\objs\$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="..\objs\$(PlatformName)\$(ConfigurationName)"
 			ConfigurationType="1"
 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
 			UseOfMFC="0"
 			ATLMinimizesCRunTimeLibraryUsage="false"
 			CharacterSet="1"
+			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -188,7 +189,7 @@
 			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
+				PreprocessorDefinitions="NDEBUG"
 				Culture="2057"
 			/>
 			<Tool
@@ -197,16 +198,15 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalDependencies="winmm.lib ws2_32.lib libpng.lib zlibstat.lib lzo2.lib dxguid.lib libfreetype2.lib libicu.lib"
-				LinkIncremental="0"
+				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				IgnoreDefaultLibraryNames="LIBCMT.lib"
+				IgnoreDefaultLibraryNames=""
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				StackReserveSize="1048576"
 				StackCommitSize="1048576"
-				RandomizedBaseAddress="1"
-				DataExecutionPrevention="0"
-				TargetMachine="1"
+				OptimizeReferences="2"
+				TargetMachine="17"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -231,15 +231,14 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Release|x64"
-			OutputDirectory="..\objs\$(PlatformName)\$(ConfigurationName)"
-			IntermediateDirectory="..\objs\$(PlatformName)\$(ConfigurationName)"
+			Name="Debug|Win32"
+			OutputDirectory="..\objs\$(PlatformName)\$(ConfigurationName)\"
+			IntermediateDirectory="..\objs\$(PlatformName)\$(ConfigurationName)\"
 			ConfigurationType="1"
 			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops"
 			UseOfMFC="0"
 			ATLMinimizesCRunTimeLibraryUsage="false"
 			CharacterSet="1"
-			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -300,7 +299,7 @@
 			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
+				PreprocessorDefinitions="_DEBUG"
 				Culture="2057"
 			/>
 			<Tool
@@ -309,15 +308,16 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalDependencies="winmm.lib ws2_32.lib libpng.lib zlibstat.lib lzo2.lib dxguid.lib libfreetype2.lib libicu.lib"
-				LinkIncremental="1"
+				LinkIncremental="0"
 				SuppressStartupBanner="true"
-				IgnoreDefaultLibraryNames=""
+				IgnoreDefaultLibraryNames="LIBCMT.lib"
 				GenerateDebugInformation="true"
 				SubSystem="2"
 				StackReserveSize="1048576"
 				StackCommitSize="1048576"
-				OptimizeReferences="2"
-				TargetMachine="17"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="1"
 			/>
 			<Tool
 				Name="VCALinkTool"
@@ -338,9 +338,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -439,9 +436,6 @@
 				Name="VCAppVerifierTool"
 			/>
 			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
@@ -485,10 +479,26 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_copying.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\clipboard_pasting.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\command.cpp"
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\command_queue.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\console.cpp"
 				>
 			</File>
@@ -705,6 +715,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\template.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\texteff.cpp"
 				>
 			</File>
@@ -725,6 +739,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\transform_tables.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\vehicle.cpp"
 				>
 			</File>
@@ -829,6 +847,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\cmd_helper.h"
 				>
 			</File>
@@ -837,6 +859,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\command_queue.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\command_type.h"
 				>
 			</File>
@@ -1457,6 +1483,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\template.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\template_base.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\template_face.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\template_type.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\terraform_gui.h"
 				>
 			</File>
@@ -1473,15 +1515,15 @@
 				>
 			</File>
 			<File
-				RelativePath=".\..\src\tilearea_type.h"
+				RelativePath=".\..\src\tile_cmd.h"
 				>
 			</File>
 			<File
-				RelativePath=".\..\src\tile_cmd.h"
+				RelativePath=".\..\src\tile_type.h"
 				>
 			</File>
 			<File
-				RelativePath=".\..\src\tile_type.h"
+				RelativePath=".\..\src\tilearea_type.h"
 				>
 			</File>
 			<File
@@ -1761,6 +1803,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\clipboard_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\company_gui.cpp"
 				>
 			</File>
@@ -2169,6 +2215,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\template_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\town_sl.cpp"
 				>
 			</File>
@@ -3325,6 +3375,10 @@
 				>
 			</File>
 			<File
+				RelativePath="..\src\misc\compact_array.hpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\misc\countedobj.cpp"
 				>
 			</File>
@@ -3669,20 +3723,20 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|Win32"
-					ExcludedFromBuild="true"
+					Name="Release|x64"
 					>
 					<Tool
-						Name="VCCustomBuildTool"
+						Name="MASM AMD64"
+						PreserveIdentifierCase="true"
+						PreservePublicAndExternSymbolCase="true"
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|x64"
+					Name="Debug|Win32"
+					ExcludedFromBuild="true"
 					>
 					<Tool
-						Name="MASM AMD64"
-						PreserveIdentifierCase="true"
-						PreservePublicAndExternSymbolCase="true"
+						Name="VCCustomBuildTool"
 					/>
 				</FileConfiguration>
 				<FileConfiguration
diff -ibruN source.list source.list
--- source.list	2010-02-10 19:24:05.000000000 +0300
+++ source.list	2010-06-20 15:22:46.000000000 +0400
@@ -7,7 +7,11 @@
 cargopacket.cpp
 cargotype.cpp
 cheat.cpp
+clipboard.cpp
+clipboard_copying.cpp
+clipboard_pasting.cpp
 command.cpp
+command_queue.cpp
 console.cpp
 console_cmds.cpp
 crashlog.cpp
@@ -64,11 +68,13 @@
 string.cpp
 strings.cpp
 subsidy.cpp
+template.cpp
 texteff.cpp
 tgp.cpp
 tile_map.cpp
 tilearea.cpp
 townname.cpp
+transform_tables.cpp
 #if WIN32
 #else
 	#if WINCE
@@ -117,8 +123,10 @@
 cargotype.h
 cheat_func.h
 cheat_type.h
+clipboard.h
 cmd_helper.h
 command_func.h
+command_queue.h
 command_type.h
 company_base.h
 company_func.h
@@ -274,6 +282,10 @@
 subsidy_func.h
 subsidy_type.h
 tar_type.h
+template.h
+template_base.h
+template_face.h
+template_type.h
 terraform_gui.h
 textbuf_gui.h
 texteff.hpp
@@ -367,6 +379,7 @@
 bridge_gui.cpp
 build_vehicle_gui.cpp
 cheat_gui.cpp
+clipboard_gui.cpp
 company_gui.cpp
 console_gui.cpp
 date_gui.cpp
@@ -472,6 +485,7 @@
 saveload/station_sl.cpp
 saveload/strings_sl.cpp
 saveload/subsidy_sl.cpp
+saveload/template_sl.cpp
 saveload/town_sl.cpp
 saveload/vehicle_sl.cpp
 saveload/waypoint_sl.cpp
@@ -782,6 +796,7 @@
 misc/array.hpp
 misc/binaryheap.hpp
 misc/blob.hpp
+misc/compactarray.hpp
 misc/countedobj.cpp
 misc/countedptr.hpp
 misc/crc32.hpp
Binary files src/.DS_Store and src/.DS_Store differ
diff -ibruN src/clipboard.cpp src/clipboard.cpp
--- src/clipboard.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/clipboard.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,217 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard.cpp Implementaion of clipboard related to both copying and pasting. */
+
+#include "stdafx.h"
+#include "template_base.h"
+#include "clipboard.h"
+
+Clipboard _clipboard;
+Template _clipboard_content;
+
+/** Get the clipboard content. */
+TemplateFace *Clipboard::Content()
+{
+	return &_clipboard_content;
+}
+
+/** Clears contents of the clipboard. */
+void Clipboard::Clear()
+{
+	Template empty_template;
+	empty_template.Swap(&_clipboard_content);
+}
+
+//class BoundsFinder {
+//private:
+//	struct BoundNode {
+//		static const int INVALID_OFFSET = INT_MIN;
+//
+//		Compact2DOffset grid_pos;
+//
+//		BoundNode *next; ///< Pointer to the successor int the nodes chain.
+//
+//		union {
+//			int grid_pos_prev; ///< grid_pos of the predecessor. Used only before all node loops are created.
+//			bool not_visited;
+//		};
+//
+//		/** If this node is a part of a nodes chain (closed into loop or not). */
+//		FORCEINLINE bool IsLinked() { return (this->next != NULL) || (this->grid_pos_prev == INVALID_OFFSET); }
+//
+//		/** Join another node if it's the successor of this node. */
+//		FORCEINLINE bool JoinIfNext(BoundNode *node)
+//		{
+//			bool ret = node->grid_pos_prev == this->grid_pos;
+//			if (ret) {
+//				this->next = node;
+//				node->grid_pos_prev = INVALID_OFFSET;
+//			}
+//			return ret;
+//		}
+//	};
+//
+//	struct BoundNodesChain {
+//		BoundNode *head;
+//		BoundNode *tail;
+//
+//		bool TryJoinTail(BoundNode *node)
+//		{
+//			bool ret = this->tail->JoinIfNext(node);
+//			if (ret) this->tail = node;
+//			return ret;
+//		}
+//
+//		bool TryJoinHead(BoundNode *node)
+//		{
+//			bool ret = node->JoinIfNext(this->head);
+//			if (ret) this->head = node;
+//			return ret;
+//		}
+//	};
+//
+//	SmallVector<BoundNode, 75, SVG_EXPONENTIAL> bound_nodes;
+//	SmallVector<BoundNode*, 16> bound_loops;
+//	const TemplateTilesArray *tiles;
+//
+//	void AddBoundNode(Compact2DOffset grid_pos, Compact2DOffset grid_pos_prev)
+//	{
+//		BoundNode *node = bound_nodes.Append();
+//		node->grid_pos = grid_pos;
+//		node->next = NULL;
+//		node->grid_pos_prev = grid_pos_prev;
+//	}
+//
+//	void LinkBoundNodes()
+//	{
+//		this->bound_nodes.Compact();
+//
+//		SmallVector<BoundNodesChain, 16> node_chains((this->bound_nodes.Length() + 2) / 3); // estimate capacity as 1/3 of all bound nodes
+//
+//		/* We will join nodes into singly linked chains and finally into loops. node_chains
+//		 * vector will store endings (heads and tails) of not yet closed chains. Chains will
+//		 * grow until they will be all closed into loops. */
+//
+//		for (BoundNode *node = this->bound_nodes.Begin(); node != this->bound_nodes.End(); node++) {
+//			if (!node->IsLinked()) {
+//				/* try to link current node to one of chains */
+//				for (BoundNodesChain *chain = node_chains.End() - 1; ; chain--) {
+//					if (chain < node_chains.Begin()) {
+//						/* if node wasn't linked then create a new chain */
+//						chain = node_chains.Append();
+//						chain->head = chain->tail = node;
+//						break;
+//					}
+//
+//					/* try to join current node to a chain head */
+//					if (chain->TryJoinHead(node)) {
+//						/* try to close this chain into a loop */
+//						if (chain->TryJoinTail(node)) {
+//							*this->bound_loops.Append() = node; // save one of loop nodes
+//							node_chains.Erase(chain); // remove chain from the list
+//						/* try to join new head of this chain to a tail of another chain */
+//						} else {
+//							for (BoundNodesChain *other_chain = chain - 1; other_chain >= node_chains.Begin(); other_chain--) {
+//								if (other_chain->TryJoinTail(node)) {
+//									/* two chains linked, remove one of them from the list */
+//									chain->head = other_chain->head;
+//									node_chains.Erase(other_chain);
+//									break;
+//								}
+//							}
+//						}
+//						break; // current node is linked, take next one braking chains loop
+//					}
+//
+//					/* try to join current node to a chain tail */
+//					if (chain->TryJoinTail(node)) {
+//						/* try to close this chain into a loop */
+//						if (chain->TryJoinHead(node)) {
+//							*this->bound_loops.Append() = node; // save one of loop nodes
+//							node_chains.Erase(chain); // remove chain from the list
+//						/* try to join new tail of this chain to a head of another chain */
+//						} else {
+//							for (BoundNodesChain *other_chain = chain - 1; other_chain >= node_chains.Begin(); other_chain--) {
+//								if (other_chain->TryJoinHead(node)) {
+//									/* two chains linked, remove one of them from the list */
+//									chain->tail = other_chain->tail;
+//									node_chains.Erase(other_chain);
+//									break;
+//								}
+//							}
+//						}
+//						break; // current node is linked, take next one braking chains loop
+//					}
+//				}
+//			}
+//		}
+//	}
+//
+//	void FindBoundNodes()
+//	{
+//		bound_nodes.Reserve(2 * (this->tiles->Width() + this->tiles->Height()));
+//
+//		const TemplateTile *tiles = this->tiles->Data();
+//		Compact2DOffset row_diff = this->tiles->IndexToOffset(0, 1);
+//		Compact2DOffset first_row_first_col = this->tiles->IndexToOffset(0, 0);
+//		Compact2DOffset first_row_last_col = this->tiles->IndexToOffset(this->tiles->Width() - 2, 0);
+//		Compact2DOffset last_row_first_col = this->tiles->IndexToOffset(0, this->tiles->Height() - 2);
+//		Compact2DOffset last_row_last_col = this->tiles->IndexToOffset(this->tiles->Width() - 2, this->tiles->Height() - 2);
+//
+//		/* Top edge */
+//		for (Compact2DOffset i = first_row_first_col; i <= first_row_last_col; i++) {
+//			if (tiles[i].type != TTT_CLEAR) this->AddBoundNode(i, Compact2DOffset(i + 1));
+//		}
+//		/* Bottom edge */
+//		for (Compact2DOffset i = last_row_first_col; i <= last_row_last_col; i++) {
+//			if (tiles[i].type != TTT_CLEAR) this->AddBoundNode(Compact2DOffset(i + 1 + row_diff), Compact2DOffset(i + row_diff));
+//		}
+//		/* Left edge */
+//		for (Compact2DOffset i = first_row_first_col; i <= last_row_first_col; i += row_diff) {
+//			if (tiles[i].type != TTT_CLEAR) this->AddBoundNode(Compact2DOffset(i + row_diff), i);
+//		}
+//		/* Right edge */
+//		for (Compact2DOffset i = first_row_last_col; i <= last_row_last_col; i += row_diff) {
+//			if (tiles[i].type != TTT_CLEAR) this->AddBoundNode(Compact2DOffset(i + 1), Compact2DOffset(i + row_diff + 1));
+//		}
+//
+//		/* Inner by rows */
+//		for (Compact2DOffset first_in_row = first_row_first_col; first_in_row <= last_row_first_col; first_in_row += row_diff) {
+//			for (Compact2DOffset i(first_in_row + row_diff - 2); i > first_in_row; i--) {
+//				if ((tiles[i].type == TTT_CLEAR) != (tiles[i - 1].type == TTT_CLEAR)) {
+//					if (tiles[i].type == TTT_CLEAR) {
+//						this->AddBoundNode(Compact2DOffset(i + row_diff), i);
+//					} else {
+//						this->AddBoundNode(i, Compact2DOffset(i + row_diff));
+//					}
+//				}
+//			}
+//		}
+//
+//		/* Inner by columns */
+//		for (Compact2DOffset first_in_col = first_row_first_col, last_in_col = last_row_first_col; first_in_col <= first_row_last_col; first_in_col++, last_in_col++) {
+//			for (Compact2DOffset i = last_in_col; i > first_in_col; i -= row_diff) {
+//				if ((tiles[i].type == TTT_CLEAR) != (tiles[i - row_diff].type == TTT_CLEAR)) {
+//					if (tiles[i].type == TTT_CLEAR) {
+//						this->AddBoundNode(Compact2DOffset(i + 1), i);
+//					} else {
+//						this->AddBoundNode(i, Compact2DOffset(i + 1));
+//					}
+//				}
+//			}
+//		}
+//	}
+//
+//public:
+//	void Run(const TemplateTilesArray &tiles)
+//	{
+//		this->tiles = &tiles;
+//		this->FindBoundNodes();
+//		this->LinkBoundNodes();
+//	}
+//};
diff -ibruN src/clipboard.h src/clipboard.h
--- src/clipboard.h	1970-01-01 03:00:00.000000000 +0300
+++ src/clipboard.h	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,58 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file template.h Header file for the clipboad (template copier/paster). */
+
+#ifndef CLIPBOARD_H
+#define CLIPBOARD_H
+
+#include "template_face.h"
+#include "tile_type.h"
+
+/**
+ * Run a loop iterating through template tiles and corresponding board tiles.
+ *
+ * @param template_tile_index_var Name of a variable that will be used as a template tile index. It
+ *                                must be of type TemplateTileIndex or other type (like PointT) with
+ *                                x and y integer fields. Also it must be initialized before running
+ *                                the loop, iteration will start from its initial value.
+ * @param board_tile_index_var Name of a variable that will be used as a board tile index. It must be
+ *                            of TileIndex type. Also it must be initialized before running the loop,
+ *                            iteration will start from its initial value.
+ * @param width The width of a rectangular area we want to iterate through. Can be any expression.
+ * @param height The height of a rectangular area we want to iterate through. Can be any expression.
+ *
+ * @note The iteration runs firstly through the first row, then through the next row and so on (where
+ *       the row is a set of tiles haveing the same y coordinate).
+ */
+#define MAP_TEMPLATE_TILES_TO_BOARD_TILES(template_tile_index_var, board_tile_index_var, width, height)               \
+	for (                                                                                                           \
+		int size_x = width, end_x = template_tile_index_var.x + size_x, end_y = template_tile_index_var.y + height; \
+		template_tile_index_var.y < end_y;                                                                          \
+		template_tile_index_var.y++, board_tile_index_var += TileDiffXY(-size_x, 1)                                  \
+	) for (                                                                                                         \
+		template_tile_index_var.x = end_x - size_x;                                                                 \
+		template_tile_index_var.x < end_x;                                                                          \
+		template_tile_index_var.x++, board_tile_index_var++                                                          \
+	)                                                                                                               \
+
+/** The clipboard - copy and paste templates. */
+class Clipboard {
+public:
+	TemplateFace *Content();
+
+	/** If the clipboard is empty. */
+	FORCEINLINE bool IsEmpty() { return this->Content()->Width() == 0; }
+
+	void Clear();
+	void Copy(TileIndex start, TileIndex end);
+	void Paste(TileIndex tile);
+};
+
+extern Clipboard _clipboard;
+
+#endif /* CLIPBOARD_H */
diff -ibruN src/clipboard_copying.cpp src/clipboard_copying.cpp
--- src/clipboard_copying.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/clipboard_copying.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,522 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_copying.cpp Implementaion of clipboard related to copying. */
+
+#include "stdafx.h"
+#include "company_func.h"
+#include "rail_map.h"
+#include "road_map.h"
+#include "station_map.h"
+#include "water_map.h"
+#include "tunnelbridge_map.h"
+#include "bridge_map.h"
+#include "waypoint_base.h"
+#include "station_base.h"
+#include "template_base.h"
+#include "clipboard.h"
+
+extern Template _clipboard_content;
+
+static ClipboardSettings::Copying &_copy_settings = _settings_client.clipboard.copying;  ///< Alias for _settings_client.clipboard.copying variable.
+
+class ClipboardCopyTool : public TemplateBuilder {
+private:
+	/**
+	 * Search binary for a station with given id in a sorted array of station pointers.
+	 * @param id Id of a station to search for.
+	 * @param begin Pointer to the first cell of an array. Array must be sorted by station ID.
+	 * @param end Pointer to the past-the-end cell of an array.
+	 * @return Pointer to the cell containing station with the lowest ID not lower then ID given or end pointer if given ID is the highest.
+	 */
+	Template::Station * const *BinarySearchStationByID(TemplateStationID id)
+	{
+		Template::Station * const *begin = this->Stations().Begin();
+		Template::Station * const *end = this->Stations().End();
+		Template::Station * const *mid;
+		TemplateStationID mid_id;
+
+		while (begin < end) {
+			mid = begin + ((end - begin) >> 1);
+			mid_id = (*mid)->id;
+			if (mid_id < id) {
+				begin = mid + 1;
+			} else if (mid_id > id) {
+				end = mid;
+			} else {
+				return mid;
+			}
+		}
+
+		return begin;
+	}
+
+protected:
+	typedef void (ClipboardCopyTool::*CopyTileMethod)(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds);
+
+	static const CopyTileMethod copy_tile_methods[MP_END];
+
+
+	bool TileBelongsToCopyArea(TileIndex tile)
+	{
+		TileIndexDiffC diff = TileIndexToTileIndexDiffC(tile, this->start_tile);
+		return (((uint)diff.x < this->tiles.Width() - 1) && ((uint)diff.y < this->tiles.Height() - 1));
+	}
+
+	/**
+	 * Find a station with given ID or add new station if given ID is not in use.
+	 *
+	 * @param id ID of station to find or add.
+	 * @param added Pointer to bool variable to store if new station was added. Can be NULL.
+	 * @return Found or added station.
+	 *
+	 * @see TemplateBuilder::AddStation
+	 * @see TemplateBuilder::FindStation
+	 */
+	Template::Station *GetStation(TemplateStationID id, bool *added = NULL)
+	{
+		Template::Station * const *station = BinarySearchStationByID(id);
+		bool add_station = (station == this->Stations().End());
+		if (added != NULL) *added = add_station;
+		if (!add_station) return *station;
+		Template::Station *ret = TemplateBuilder::AddStation(station);
+		ret->id = id;
+		return ret;
+	}
+
+	/**
+	 * Find a station with given ID.
+	 *
+	 * @param id ID of station to find.
+	 * @return Found station or NULL if station wasn't found.
+	 *
+	 * @see TemplateBuilder::GetStation
+	 */
+	Template::Station *FindStation(TemplateStationID id)
+	{
+		Template::Station * const *station = BinarySearchStationByID(id);
+		return (station == this->Stations().End()) ? NULL : *station;
+	}
+
+	template <TileType Ttile_type>
+	void CopyTile(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds);
+
+	virtual TemplateBuilder::BuildReadinessFlags Build()
+	{
+		assert((this->start_tile < MapSize()) && (this->end_tile < MapSize()));
+
+		/* Calculate copied area template_bounds */
+		Bounds template_bounds = Bounds::EMPTY;
+		template_bounds.Include(TileX(start_tile), TileY(start_tile));
+		template_bounds.Include(TileX(end_tile), TileY(end_tile));
+		assert((template_bounds.min.x > 0) && (template_bounds.min.y > 0) && (template_bounds.max.x < (int)MapSizeX() - 1) && (template_bounds.max.y < (int)MapSizeY() - 1));
+
+		Dimension size = { template_bounds.max.x - template_bounds.min.x + 1, template_bounds.max.y - template_bounds.min.y + 1 };
+
+		/* Create and zero-fill template tiles array */
+		this->tiles.Resize(size.width + 1, size.height + 1);
+		MemSetT(this->tiles.Data(), 0, this->tiles.Length());
+
+		BoundsT<uint16> objects_bounds = BoundsT<uint16>::EMPTY;
+
+		/* Copy tiles content */
+		TemplateTileIndex template_tile = { 0, 0 };
+		TileIndex board_tile = TileXY(template_bounds.min.x, template_bounds.min.y);
+		MAP_TEMPLATE_TILES_TO_BOARD_TILES(template_tile, board_tile, size.width, size.height) {
+			this->tiles[template_tile].height = TileHeight(board_tile);
+			ClipboardCopyTool::CopyTileMethod copy_method = ClipboardCopyTool::copy_tile_methods[GetTileType(board_tile)];
+			if (copy_method != NULL) (this->*copy_method)(template_tile, board_tile, &objects_bounds);
+		}
+
+		/* TODO: cut out unused borders (use template_bounds) */
+
+		/* Copy heights on SE and SW borders (into extra row and column in the template tiles map) */
+		template_tile = TemplateTileIndex::Create(size.width, 0);
+		board_tile = TileXY(template_bounds.max.x + 1, template_bounds.min.y);
+		MAP_TEMPLATE_TILES_TO_BOARD_TILES(template_tile, board_tile, 1, size.height) {
+			this->tiles[template_tile].height = TileHeight(board_tile);
+		}
+		template_tile = TemplateTileIndex::Create(0, size.height);
+		board_tile = TileXY(template_bounds.min.x, template_bounds.max.y + 1);
+		MAP_TEMPLATE_TILES_TO_BOARD_TILES(template_tile, board_tile, size.width + 1, 1) {
+			this->tiles[template_tile].height = TileHeight(board_tile);
+		}
+
+		return BRF_BASIC;
+	}
+
+public:
+	TileIndex start_tile;
+	TileIndex end_tile;
+};
+
+template <>
+void ClipboardCopyTool::CopyTile<MP_RAILWAY>(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds)
+{
+	if (!_copy_settings.with_other && !IsTileOwner(source_idx, _current_company)) return;
+
+	TemplateTile &dest_tile = this->tiles[dest_idx];
+
+	/* Check if we want to copy this type of building */
+	if (!_copy_settings.with_rail) return;
+
+	dest_tile.type = TTT_RAIL_TRANSPORT;
+	dest_tile.rail.type = GetRailType(source_idx);
+	switch (GetRailTileType(source_idx)) {
+		case RAIL_TILE_DEPOT: { // Rail depot
+			Template::Depot *depot = this->Add<Template::Depot>(dest_idx);
+			depot->direction = GetRailDepotDirection(source_idx);
+			break;
+		}
+
+		case RAIL_TILE_SIGNALS: { // Rail tracks with signals
+			dest_tile.rail.bits = GetTrackBits(source_idx);
+
+			bool two_way;
+			Trackdir location;
+			Track track;
+			FOR_EACH_SET_TRACK(track, dest_tile.rail.bits) {
+				location = TrackToTrackdir(track);
+				if (HasSignalOnTrackdir(source_idx, location)) {
+					two_way = HasSignalOnTrackdir(source_idx, ReverseTrackdir(location));
+				} else if (HasSignalOnTrackdir(source_idx, location = ReverseTrackdir(location))) {
+					two_way = false;
+				} else {
+					continue;
+				}
+
+				Template::Signal *signal = this->Add<Template::Signal>(dest_idx);
+				signal->signal_type = GetSignalType(source_idx, track);
+				signal->variant = GetSignalVariant(source_idx, track);
+				signal->location = location;
+				signal->two_way = two_way;
+			}
+			break;
+		}
+
+		case RAIL_TILE_NORMAL: // Normal rail tracks
+			dest_tile.rail.bits = GetTrackBits(source_idx);
+			break;
+	}
+
+	objects_bounds->Include(dest_idx);
+}
+
+template <>
+void ClipboardCopyTool::CopyTile<MP_ROAD>(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds)
+{
+	TemplateTile &dest_tile = this->tiles[dest_idx];
+
+	RoadTypes copy_road_types = ROADTYPES_NONE;
+
+	if (HasTileRoadType(source_idx, ROADTYPE_ROAD) && _copy_settings.with_road && (_copy_settings.with_other || IsRoadOwner(source_idx, ROADTYPE_ROAD, _current_company))) {
+		copy_road_types |= ROADTYPES_ROAD;
+	}
+	if (HasTileRoadType(source_idx, ROADTYPE_TRAM) && _copy_settings.with_tram && (_copy_settings.with_other || IsRoadOwner(source_idx, ROADTYPE_TRAM, _current_company))) {
+		copy_road_types |= ROADTYPES_TRAM;
+	}
+
+	if (GetRoadTileType(source_idx) == ROAD_TILE_CROSSING) {
+		/* Tile is rail/road crossing */
+		bool copy_rail = _copy_settings.with_rail && (_copy_settings.with_other || IsTileOwner(source_idx, _current_company));
+		if (copy_rail) {
+			//TODO: dest_tile.m0 = GetRailType(source_idx); //rail.type and crossing.rail_type
+			if (copy_road_types != ROADTYPES_NONE) {
+				/* Copy rail/road crossing */
+				dest_tile.type = (GetCrossingRoadAxis(source_idx) == AXIS_X) ? TTT_RAIL_Y_ROAD_X : TTT_RAIL_X_ROAD_Y;
+				dest_tile.crossing.road_types = copy_road_types;
+			} else {
+				/* Copy rail from crossing */
+				dest_tile.type = TTT_RAIL_TRANSPORT;
+				dest_tile.rail.bits = GetCrossingRailBits(source_idx);
+			}
+		} else if (copy_road_types != ROADTYPES_NONE) {
+			/* Copy road from crossing */
+			dest_tile.type = TTT_ROAD_TRANSPORT;
+			dest_tile.road.bits = RoadBitsToRoadBitsPack(GetCrossingRoadBits(source_idx), copy_road_types);
+			dest_tile.road.types = copy_road_types;
+		}
+	} else {
+		/* Tile is road */
+		if (copy_road_types == ROADTYPES_NONE) return;
+
+		dest_tile.type = TTT_ROAD_TRANSPORT;
+		dest_tile.road.types = copy_road_types;
+
+		switch (GetRoadTileType(source_idx)) {
+			case ROAD_TILE_DEPOT: { // Road/tram depot
+				Template::Depot *depot = this->Add<Template::Depot>(dest_idx);
+				depot->direction = GetRoadDepotDirection(source_idx);
+				dest_tile.road.bits = ROAD_NONE;
+				break;
+			}
+
+			case ROAD_TILE_NORMAL: // Normal road and/or tram tracks
+				dest_tile.road.bits = GetRoadBitsPack(source_idx);
+				break;
+
+			default: NOT_REACHED();
+		}
+	}
+
+	objects_bounds->Include(dest_idx);
+}
+
+template <>
+void ClipboardCopyTool::CopyTile<MP_STATION>(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds)
+{
+	if (!_copy_settings.with_other && !IsTileOwner(source_idx, _current_company)) return;
+
+	TemplateTile &dest_tile = this->tiles[dest_idx];
+	StationID station_id = GetStationIndex(source_idx);
+
+	switch (GetStationType(source_idx)) {
+		/* Rail stations */
+		case STATION_RAIL: {
+			if (!_copy_settings.with_rail) return;
+			dest_tile.type = TTT_RAIL_TRANSPORT;
+
+			Template::RailStation *rail_part = this->Add<Template::RailStation>(dest_idx);
+			rail_part->direction = AxisToDiagDir(GetRailStationAxis(source_idx));
+			rail_part->station_id = station_id;
+			break;
+		}
+
+		case STATION_AIRPORT: {
+			if (!_copy_settings.with_airports) return;
+
+			/* copy an airport only when iterating through its main tile */
+			if (::Station::Get(station_id)->airport_tile != source_idx) return;
+
+			/* TODO: check airport bounds (if they fits into copied area) and
+			 * write all airport tiles to the tiles array */
+			/* objects_bounds->Include(other_end_dest_idx); */
+
+			Template::Airport *airport_part = this->Add<Template::Airport>(dest_idx);
+			airport_part->direction = DIAGDIR_BEGIN; // not used but must be valid
+			airport_part->airport_type = ::Station::Get(station_id)->airport_type;
+			airport_part->station_id = station_id;
+			break;
+		}
+
+		case STATION_TRUCK:
+		case STATION_BUS: {
+			if (!_copy_settings.with_road) return;
+			dest_tile.type = TTT_ROAD_TRANSPORT;
+			if (IsDriveThroughStopTile(source_idx)) {
+				dest_tile.road.types = GetRoadTypes(source_idx);
+				dest_tile.road.bits = RoadBitsToRoadBitsPack(AxisToRoadBits(DiagDirToAxis(GetRoadStopDir(source_idx))), dest_tile.road.types);
+			}
+
+			Template::RoadStop *road_part = this->Add<Template::RoadStop>(dest_idx);
+			road_part->direction = GetRoadStopDir(source_idx);
+			road_part->road_stop_type = GetRoadStopType(source_idx);
+			road_part->station_id = station_id;
+			break;
+		}
+
+		case STATION_DOCK: {
+			if (!_copy_settings.with_water_transport) return;
+
+			/* copy a dock only when iterating through its main tile */
+			if (::Station::Get(station_id)->dock_tile != source_idx) return;
+
+			//TODO: which direction is it?
+			DiagDirection direction = GetDockDirection(source_idx);
+
+			/* check if the dock fits into copied area */
+			if (!TileBelongsToCopyArea(TileAddByDiagDir(source_idx, direction))) return;
+
+			TemplateTileIndex other_end_dest_idx = dest_idx;
+			other_end_dest_idx.x += TileIndexDiffCByDiagDir(direction).x;
+			other_end_dest_idx.y += TileIndexDiffCByDiagDir(direction).y;
+		
+			dest_tile.type = this->tiles[other_end_dest_idx].type = TTT_WATER_TRANSPORT;
+
+			Template::Dock *dock_part = this->Add<Template::Dock>(dest_idx);
+			dock_part->direction = direction;
+			dock_part->station_id = station_id;
+
+			objects_bounds->Include(other_end_dest_idx);
+			break;
+		}
+
+		case STATION_BUOY: {
+			if (!_copy_settings.with_water_transport) return;
+			dest_tile.type = TTT_WATER_TRANSPORT;
+
+			Template::Waypoint *waypoint = this->Add<Template::Waypoint>(dest_idx);
+			waypoint->direction = DIAGDIR_BEGIN; // not used but must be valid to be transformable
+			waypoint->station_id = station_id;
+			break;
+		}
+
+		case STATION_WAYPOINT: {
+			if (!_copy_settings.with_rail) return;
+			dest_tile.type = TTT_RAIL_TRANSPORT;
+			dest_tile.rail.type = GetRailType(source_idx);
+			dest_tile.rail.bits = AxisToTrackBits(GetRailStationAxis(source_idx));
+
+			Template::Waypoint *waypoint = this->Add<Template::Waypoint>(dest_idx);
+			waypoint->direction = AxisToDiagDir(GetRailStationAxis(source_idx));
+			waypoint->station_id = station_id;
+			break;
+		}
+
+		default: return;
+	}
+
+	if (_copy_settings.with_station_names) {
+		Template::Station *station = this->GetStation(station_id);
+		if (station->name == NULL) station->SetName(::BaseStation::Get(station_id)->name);
+	}
+
+	objects_bounds->Include(dest_idx);
+}
+
+template <>
+void ClipboardCopyTool::CopyTile<MP_WATER>(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds)
+{
+	if (!_copy_settings.with_water_transport) return;
+	if (!_copy_settings.with_other && !IsTileOwner(source_idx, _current_company)) return;
+
+	TemplateTile &dest_tile = this->tiles[dest_idx];
+	switch (GetWaterTileType(source_idx)) {
+		/* Canal or lock */
+		case WATER_TILE_CLEAR:
+			if (GetWaterClass(source_idx) != WATER_CLASS_CANAL) return;
+			/* No break */
+		case WATER_TILE_LOCK:
+			/* Lock tiles are copied as canals, they will be created automatically on slopes when pasting canals */
+			dest_tile.type = TTT_WATER_TRANSPORT;
+			break;
+
+		/* Water depot */
+		case WATER_TILE_DEPOT: {
+			DiagDirection dir = GetShipDepotDirection(source_idx); // get exit direction
+			TemplateTileIndex other_end_dest_idx = dest_idx; // second depot tile
+			/* Check if we are on the souther depot tile (to copy depot only once) and check if depot fits into copied area */
+			switch (dir) {
+				case DIAGDIR_SW: if (other_end_dest_idx.x-- == 0) return; break;
+				case DIAGDIR_SE: if (other_end_dest_idx.y-- == 0) return; break;
+				default: return;
+			}
+			/* Write tiles, create and fill depot object */
+			dest_tile.type = this->tiles[other_end_dest_idx].type = TTT_WATER_TRANSPORT;
+			Template::Depot *depot = this->Add<Template::Depot>(dest_idx);
+			depot->direction = dir;
+
+			objects_bounds->Include(other_end_dest_idx);
+			break;
+		}
+
+		default: return;
+	}
+
+	objects_bounds->Include(dest_idx);
+}
+
+/* we should not try to copy MP_VOID tile */
+#ifdef _DEBUG
+template <>
+void ClipboardCopyTool::CopyTile<MP_VOID>(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds)
+{
+	assert(false);
+}
+#endif
+
+template <>
+void ClipboardCopyTool::CopyTile<MP_TUNNELBRIDGE>(TemplateTileIndex dest_idx, TileIndex source_idx, BoundsT<uint16> *objects_bounds)
+{
+	/* Check if settings allow to copy this tunnel/bridge */
+	if (!_copy_settings.with_other && !IsTileOwner(source_idx, _current_company)) return;
+	TemplateTileType tile_type;
+	switch (GetTunnelBridgeTransportType(source_idx)) {
+		case TRANSPORT_RAIL:
+			if (!_copy_settings.with_rail) return;
+			tile_type = TTT_RAIL_TRANSPORT;
+			break;
+
+		case TRANSPORT_ROAD:
+			if (!_copy_settings.with_road) return;
+			tile_type = TTT_ROAD_TRANSPORT;
+			break;
+
+		default:
+			NOT_REACHED();
+	}
+
+	if (GetTunnelBridgeDirection(source_idx) < 2) return; // copy tunnel/bridge only from western end
+
+	/* check if the bridge/tunnel fits into copied area */
+	TileIndex other_end_source_idx = GetOtherTunnelBridgeEnd(source_idx);
+	if (!this->TileBelongsToCopyArea(other_end_source_idx)) return;
+
+	/* Create and fill tunnel/bridge object */
+	Template::DoubleEndedObject *tunnel_bridge;
+	if (IsBridge(source_idx)) {
+		tunnel_bridge = this->Add<Template::Bridge>(dest_idx);
+		((Template::Bridge*)tunnel_bridge)->bridge_type = GetBridgeType(source_idx);
+	} else {
+		tunnel_bridge = this->Add<Template::Tunnel>(dest_idx);
+	}
+	
+	assert_compile(sizeof(TileIndexDiffC) == sizeof(PointT<int16>));
+	reinterpret_cast<TileIndexDiffC&>(tunnel_bridge->other_end_offset) = TileIndexToTileIndexDiffC(other_end_source_idx, source_idx);
+	TemplateTileIndex other_end_dest_idx = dest_idx;
+	other_end_dest_idx.x += tunnel_bridge->other_end_offset.x;
+	other_end_dest_idx.y += tunnel_bridge->other_end_offset.y;
+
+	/* Write tiles */
+	TemplateTile &dest_tile = this->tiles[dest_idx];
+	TemplateTile &other_end_dest_tile = this->tiles[other_end_dest_idx];
+	dest_tile.type = other_end_dest_tile.type = tile_type;
+	if (tile_type == TTT_RAIL_TRANSPORT) {
+		dest_tile.rail.type = other_end_dest_tile.rail.type = GetRailType(source_idx);
+	} else { // TTT_ROAD_TRANSPORT
+		dest_tile.road.types = other_end_dest_tile.road.types = GetRoadTypes(source_idx);
+	}
+
+	objects_bounds->Include(dest_idx);
+	objects_bounds->Include(other_end_dest_idx);
+}
+
+const ClipboardCopyTool::CopyTileMethod ClipboardCopyTool::copy_tile_methods[MP_END] = {
+	NULL, // MP_CLEAR
+	&ClipboardCopyTool::CopyTile<MP_RAILWAY>,
+	&ClipboardCopyTool::CopyTile<MP_ROAD>,
+	NULL, // MP_HOUSE
+	NULL, // MP_TREES
+	&ClipboardCopyTool::CopyTile<MP_STATION>,
+	&ClipboardCopyTool::CopyTile<MP_WATER>,
+
+#ifdef _DEBUG
+	&ClipboardCopyTool::CopyTile<MP_VOID>,
+#else /* _DEBUG */
+	NULL, // MP_VOID
+#endif /* _DEBUG */
+
+	NULL, // MP_INDUSTRY
+	&ClipboardCopyTool::CopyTile<MP_TUNNELBRIDGE>,
+	NULL, // MP_UNMOVABLE
+};
+
+/**
+ * Copies given area into the clipboard.
+ *
+ */
+void Clipboard::Copy(TileIndex start, TileIndex end)
+{
+	static ClipboardCopyTool copy_tool;
+	copy_tool.start_tile = start;
+	copy_tool.end_tile = end;
+	try {
+		copy_tool.BuildTemplate(&_clipboard_content);
+	} catch (TMPL_BuildException&) {
+		/* TODO: */
+	}
+};
diff -ibruN src/clipboard_gui.cpp src/clipboard_gui.cpp
--- src/clipboard_gui.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/clipboard_gui.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,291 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_gui.cpp GUIs related to the clipboard. */
+
+//#include "stdafx.h"
+//#include "openttd.h"
+//#include "gui.h"
+//#include "window_gui.h"
+//#include "viewport_type.h"
+//#include "viewport_func.h"
+//#include "gfx_func.h"
+//#include "strings_type.h"
+//#include "functions.h"
+//#include "window_type.h"
+//#include "window_func.h"
+//#include "sound_type.h"
+//#include "sound_func.h"
+//#include "tilehighlight_type.h"
+//#include "tilehighlight_func.h"
+//#include "company_func.h"
+//#include "tile_type.h"
+//#include "rail_type.h"
+//#include "rail_gui.h"
+//#include "sprite.h"
+//#include "fios.h"
+//#include "copy_paste.h"
+//#include "table/sprites.h"
+//#include "table/strings.h"
+//
+///** Current railtype. Used for autoconversion */
+//static RailType _last_railtype = RAILTYPE_RAIL;
+//
+///* **** GUI Code for Copy&Paste **** */
+//
+//
+//void PlaceProc_Copy(TileIndex tile)
+//{
+//	VpStartPlaceSizing(tile, VPM_X_AND_Y_LIMITED, DDSP_COPY_AREA);
+//	VpSetPlaceSizingLimit(255);
+//}
+//
+//void PlaceProc_Paste(TileIndex tile)
+//{
+//	_copy_paste.PasteArea(tile);
+//}
+//
+//
+///** Widget definiton of the copy paste window */
+//static const Widget _copy_paste_widgets[] = {
+//	{   WWT_CLOSEBOX,   RESIZE_NONE,   COLOUR_DARK_GREEN,     0,    10,     0,    13, STR_00C5,                  STR_018B_CLOSE_WINDOW},              // CPW_CLOSEBOX
+//	{    WWT_CAPTION,   RESIZE_NONE,   COLOUR_DARK_GREEN,    11,   329,     0,    13, STR_COPY_PASTE_TOOLBAR,    STR_018C_WINDOW_TITLE_DRAG_THIS},    // CPW_CAPTION
+//	{  WWT_STICKYBOX,   RESIZE_NONE,   COLOUR_DARK_GREEN,   330,   341,     0,    13, STR_NULL,                  STR_STICKY_BUTTON},                  // CPW_STICKYBOX
+//	{      WWT_PANEL,   RESIZE_NONE,   COLOUR_DARK_GREEN,    44,    47,    14,    35, 0x0,                       STR_NULL},                           // CPW_SPACER_1
+//	{      WWT_PANEL,   RESIZE_NONE,   COLOUR_DARK_GREEN,    92,    95,    14,    35, 0x0,                       STR_NULL},                           // CPW_SPACER_2
+//	{      WWT_PANEL,   RESIZE_NONE,   COLOUR_DARK_GREEN,   184,   187,    14,    35, 0x0,                       STR_NULL},                           // CPW_SPACER_3
+//
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,     0,    21,    14,    35, SPR_IMG_COPY,              STR_COPY_PASTE_COPY_TOOLTIP},        // CPW_COPY
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,    22,    43,    14,    35, SPR_IMG_PASTE,             STR_COPY_PASTE_PASTE_TOOLTIP},       // CPW_PASTE
+//
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,    48,    69,    14,    35, SPR_IMG_LOAD,              STR_COPY_PASTE_LOAD_TOOLTIP},        // CPW_LOAD
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,    70,    91,    14,    35, SPR_IMG_SAVE,              STR_COPY_PASTE_SAVE_TOOLTIP},        // CPW_SAVE
+//
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,    96,   117,    14,    35, SPR_IMG_ROTATE_LEFT,       STR_COPY_PASTE_ROTATE_LEFT_TOOLTIP},      // CPW_ROTATE_LEFT
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,   118,   139,    14,    35, SPR_IMG_ROTATE_RIGHT,      STR_COPY_PASTE_ROTATE_RIGHT_TOOLTIP},     // CPW_ROTATE_RIGHT
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,   140,   161,    14,    35, SPR_IMG_MIRROR_HORIZONTAL, STR_COPY_PASTE_MIRROR_HORIZONTAL_TOOLTIP},// CPW_MIRROR_HORIZONTAL
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,   162,   183,    14,    35, SPR_IMG_MIRROR_VERTICAL,   STR_COPY_PASTE_MIRROR_VERTICAL_TOOLTIP},  // CPW_MIRROR_VERTICAL
+//
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,   188,   209,    14,    35, SPR_IMG_MINUS_TERRAIN,     STR_COPY_PASTE_VACANT_TERRAIN_TOOLTIP},          // CPW_TERRAIN
+//	{   WWT_IMGBTN_2,   RESIZE_NONE,   COLOUR_DARK_GREEN,   210,   231,    14,    35, SPR_IMG_MINUS_DYNAMITE,    STR_COPY_PASTE_BULLDOZE_BEFORE_BUILD_TOOLTIP},   // CPW_DYNAMITE
+//	{   WWT_IMGBTN_2,   RESIZE_NONE,   COLOUR_DARK_GREEN,   232,   253,    14,    35, SPR_IMG_NO_RAIL,           STR_COPY_PASTE_WITHOUT_RAIL_TOOLTIP},            // CPW_RAIL
+//	{   WWT_IMGBTN_2,   RESIZE_NONE,   COLOUR_DARK_GREEN,   254,   275,    14,    35, SPR_IMG_NO_ROAD,           STR_COPY_PASTE_WITHOUT_ROAD_TOOLTIP},            // CPW_ROAD
+//	{   WWT_IMGBTN_2,   RESIZE_NONE,   COLOUR_DARK_GREEN,   276,   297,    14,    35, SPR_IMG_MINUS_SIGNAL,      STR_COPY_PASTE_TOGGLE_SIGNAL_DIRECTION_TOOLTIP}, // CPW_REVERSE_SIGNALS
+//	{     WWT_IMGBTN,   RESIZE_NONE,   COLOUR_DARK_GREEN,   298,   319,    14,    35, SPR_IMG_CONVERT_RAIL,      STR_COPY_PASTE_CONVERT_RAIL_TOOLTIP},            // CPW_CONVERT_RAILTYPE
+//	{   WWT_IMGBTN_2,   RESIZE_NONE,   COLOUR_DARK_GREEN,   320,   341,    14,    35, SPR_IMG_ONLY_OWN,          STR_COPY_PASTE_ONLY_OWN_TOOLTIP},                // CPW_ONLY_OWN
+//
+//	{   WIDGETS_END},
+//};
+//
+//static const WindowDesc _copy_paste_desc(
+//	WDP_AUTO, WDP_AUTO, 342, 36, 342, 36,
+//	WC_COPY_PASTE, WC_SCEN_LAND_GEN,
+//	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_STICKY_BUTTON,
+//	_copy_paste_widgets
+//);
+//
+//struct CopyPasteWindow : Window {
+//public:
+//
+//	/** Enum referring to the widgets of the copy paste window */
+//	enum CopyPasteWidgets {
+//		CPW_CLOSEBOX = 0,
+//		CPW_CAPTION,
+//		CPW_STICKYBOX,
+//		CPW_SPACER_1,
+//		CPW_SPACER_2,
+//		CPW_SPACER_3,
+//		CPW_COPY,
+//		CPW_PASTE,
+//		CPW_LOAD,
+//		CPW_SAVE,
+//		CPW_ROTATE_LEFT,
+//		CPW_ROTATE_RIGHT,
+//		CPW_MIRROR_HORIZONTAL,
+//		CPW_MIRROR_VERTICAL,
+//		CPW_TERRAIN,
+//		CPW_DYNAMITE,
+//		CPW_RAIL,
+//		CPW_ROAD,
+//		CPW_REVERSE_SIGNALS,
+//		CPW_CONVERT_RAILTYPE,
+//		CPW_ONLY_OWN,
+//
+//		CPW_FIRST_CLICKABLE = CPW_COPY,
+//		CPW_LAST_CLICKABLE = CPW_ONLY_OWN,
+//	};
+//
+//	CopyPasteWindow(const WindowDesc *desc) : Window(desc)
+//	{
+//		this->FindWindowPlacementAndResize(desc);
+//
+//		/* Set the button states according to variable content */
+//		if (_copy_paste.m_clear_before_build) this->LowerWidget(CPW_DYNAMITE);
+//		if (_copy_paste.m_toggle_signal_direction) this->LowerWidget(CPW_REVERSE_SIGNALS);
+//		if (_copy_paste.m_convert_rail)	  this->LowerWidget(CPW_CONVERT_RAILTYPE);
+//		if (_copy_paste.m_copy_with_rail) this->LowerWidget(CPW_RAIL);
+//		if (_copy_paste.m_copy_with_road) this->LowerWidget(CPW_ROAD);
+//		if (_copy_paste.m_copy_with_other)this->LowerWidget(CPW_ONLY_OWN);
+//	}
+//
+//	virtual void OnPaint()
+//	{
+//		SetWidgetsDisabledState(!_copy_paste.IsSomethingCopied(), CPW_PASTE, CPW_SAVE,
+//				CPW_ROTATE_LEFT, CPW_ROTATE_RIGHT, CPW_MIRROR_HORIZONTAL, CPW_MIRROR_VERTICAL,
+//				WIDGET_LIST_END);
+//		/* Set image for tri-state button */
+//		this->widget[CPW_TERRAIN].data = SPR_IMG_MINUS_TERRAIN + _copy_paste.m_paste_vacant_terrain;
+//
+//		this->DrawWidgets();
+//
+//		/* Draw CylinderGuy in CompanyColor, if unclicked */
+//		if (!this->IsWidgetLowered(CPW_ONLY_OWN))
+//			DrawSprite(SPR_IMG_ONLY_OWN, COMPANY_SPRITE_COLOUR(_current_company), this->widget[CPW_ONLY_OWN].left + 1, this->widget[CPW_ONLY_OWN].top + 1);
+//	}
+//
+//	virtual void OnClick(Point pt, int widget)
+//	{
+//		SetWidgetsDisabledState(!_copy_paste.IsSomethingCopied(), CPW_PASTE, CPW_SAVE,
+//				CPW_ROTATE_LEFT, CPW_ROTATE_RIGHT, CPW_MIRROR_HORIZONTAL, CPW_MIRROR_VERTICAL,
+//				WIDGET_LIST_END);
+//		if (this->IsWidgetDisabled(widget)) return;
+//		if ((widget >= CPW_FIRST_CLICKABLE) && (widget <= CPW_LAST_CLICKABLE)) {
+//			if (widget != CPW_COPY && widget != CPW_PASTE && 
+//				widget != CPW_DYNAMITE && widget != CPW_REVERSE_SIGNALS && 
+//				widget != CPW_RAIL && widget !=  CPW_CONVERT_RAILTYPE && 
+//				widget != CPW_ROAD && widget != CPW_ONLY_OWN) {
+//				this->HandleButtonClick(widget);
+//			}
+//			SndPlayFx(SND_15_BEEP);
+//			switch (widget) {
+//				case CPW_COPY:
+//					HandlePlacePushButton(this, CPW_COPY, SPR_CURSOR_COPY, VHM_RECT, PlaceProc_Copy);
+//					break;
+//				case CPW_PASTE:
+//					HandlePlacePushButton(this, CPW_PASTE, SPR_CURSOR_PASTE, VHM_PREVIEW, PlaceProc_Paste);
+//					break;
+//				case CPW_LOAD:
+//					_copy_paste.m_toggle_signal_direction = false;
+//					/* fallthrough */
+//				case CPW_SAVE:
+//					ShowSaveLoadDialog(widget == CPW_SAVE ? SLD_SAVE_TEMPLATE : SLD_LOAD_TEMPLATE);
+//					break;
+//				case CPW_ROTATE_LEFT:
+//				case CPW_ROTATE_RIGHT:
+//					if (widget == CPW_ROTATE_LEFT)  _copy_paste.RotateSelectionCCW();
+//					if (widget == CPW_ROTATE_RIGHT) _copy_paste.RotateSelectionCW();
+//					break;
+//				case CPW_MIRROR_HORIZONTAL:
+//				case CPW_MIRROR_VERTICAL:
+//					if (widget == CPW_MIRROR_HORIZONTAL) _copy_paste.MirrorSelectionHorizontal();
+//					if (widget == CPW_MIRROR_VERTICAL)   _copy_paste.MirrorSelectionVertical();
+//					
+//					/* Toggle SignalDir */
+//					this->OnClick(Point(), CPW_REVERSE_SIGNALS);
+//					break;
+//				case CPW_TERRAIN:
+//					_copy_paste.m_paste_vacant_terrain++;
+//					if (_copy_paste.m_paste_vacant_terrain > 2) _copy_paste.m_paste_vacant_terrain = 0;
+//					break;
+//				case CPW_DYNAMITE: case CPW_REVERSE_SIGNALS:
+//				case CPW_RAIL: case CPW_CONVERT_RAILTYPE:
+//				case CPW_ROAD: case CPW_ONLY_OWN: {
+//					this->SetDirty();
+//					this->ToggleWidgetLoweredState(widget);
+//					bool state = IsWidgetLowered(widget);
+//					switch (widget) {
+//						case CPW_DYNAMITE:	       _copy_paste.m_clear_before_build = state; break;
+//						case CPW_RAIL:             _copy_paste.m_copy_with_rail = state; break;
+//						case CPW_ROAD:             _copy_paste.m_copy_with_road = state; break;
+//						case CPW_REVERSE_SIGNALS:  _copy_paste.m_toggle_signal_direction = state; break;
+//						case CPW_CONVERT_RAILTYPE: _copy_paste.m_convert_rail = state; break;
+//						case CPW_ONLY_OWN:         _copy_paste.m_copy_with_other = state; break;
+//						default: NOT_REACHED();
+//					}
+//				} break;
+//				default: break;
+//			}
+//
+//			/* Set Selection size to Copy size */
+//			if (this->IsWidgetLowered(CPW_PASTE)) {
+//				if (_copy_paste.GetWidth() > 0)
+//					SetTileSelectSize(_copy_paste.GetWidth() - 1, _copy_paste.GetHeight() - 1);
+//			}
+//			else
+//				SetTileSelectSize(1, 1);
+//		}
+//	}
+//
+//	virtual void OnPlaceObject(Point pt, TileIndex tile)
+//	{
+//		_place_proc(tile);
+//	}
+//
+//	virtual void OnPlaceDrag(ViewportPlaceMethod select_method, ViewportDragDropSelectionProcess select_proc, Point pt)
+//	{
+//		VpSelectTilesWithMethod(pt.x, pt.y, select_method);
+//	}
+//
+//	virtual void OnPlaceMouseUp(ViewportPlaceMethod select_method, ViewportDragDropSelectionProcess select_proc, Point pt, TileIndex start_tile, TileIndex end_tile)
+//	{
+//		if (pt.x != -1) {
+//			switch (select_proc) {
+//				case DDSP_COPY_AREA:
+//					_copy_paste.CopyArea(end_tile, start_tile);
+//					/* Reset SignalDir */
+//					if (_copy_paste.m_toggle_signal_direction) this->OnClick(Point(), CPW_REVERSE_SIGNALS);
+//					this->SetDirty();
+//					break;
+//				default:
+//					break;
+//			}
+//		}
+//	}
+//
+//	virtual void OnPlaceObjectAbort()
+//	{
+//		/* UnclickWindowButtons "copy" and "paste" */
+//		this->RaiseWidget(CPW_COPY);
+//		this->RaiseWidget(CPW_PASTE);
+//
+//		this->SetDirty();
+//	}
+//
+//	virtual void OnTimeout()
+//	{
+//		this->RaiseWidget(CPW_LOAD);
+//		this->RaiseWidget(CPW_SAVE);
+//		this->RaiseWidget(CPW_ROTATE_LEFT);
+//		this->RaiseWidget(CPW_ROTATE_RIGHT);
+//		this->RaiseWidget(CPW_MIRROR_HORIZONTAL);
+//		this->RaiseWidget(CPW_MIRROR_VERTICAL);
+//		this->RaiseWidget(CPW_TERRAIN);
+//		this->SetDirty();
+//	}
+//
+//	virtual void OnTick()
+//	{
+//		/* If railtype has changed, we need to update our GUI */
+//		if (_last_railtype != _cur_railtype) {
+//			const RailtypeInfo *rti = GetRailTypeInfo(_cur_railtype);
+//			_last_railtype = _cur_railtype;
+//			this->widget[CPW_CONVERT_RAILTYPE].data = rti->gui_sprites.convert_rail;
+//			this->SetDirty();
+//		}
+//	}
+//};
+//
+//void ShowCopyPasteToolbar(int button)
+//{
+//	Window *w;
+//	/* don't recreate the window if we're clicking on a button and the window exists. */
+//	if (button < CopyPasteWindow::CPW_FIRST_CLICKABLE || !(w = FindWindowById(WC_COPY_PASTE, 0))) {
+//		DeleteWindowByClass(WC_COPY_PASTE);
+//		w = new CopyPasteWindow(&_copy_paste_desc);
+//	}
+//	if (w != NULL) w->OnClick(Point(), button);
+//}
diff -ibruN src/clipboard_pasting.cpp src/clipboard_pasting.cpp
--- src/clipboard_pasting.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/clipboard_pasting.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,668 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file clipboard_pasting.cpp Implementaion of clipboard related to pasting. */
+
+#include "stdafx.h"
+#include "debug.h"
+#include "command_queue.h"
+#include "command_func.h"
+#include "track_func.h"
+#include "road_func.h"
+#include "network/network.h"
+#include "template_base.h"
+#include "clipboard.h"
+
+/* TODO: Show only overall paste cost. */
+
+/* TODO: Feature idea: Show more info when pasting - which tiles need to be cleared,
+ * which tile corners need to be terraformed. Feature should be optional (needs some
+ * computing) and visualized only when holding cursor on a tile for some period of
+ * time and/or by pressing a shortcut key. */
+
+extern Template _clipboard_content;
+
+static ClipboardSettings::Pasting &_paste_settings = _settings_client.clipboard.pasting; ///< Alias for _settings_client.clipboard.pasting variable.
+
+/** Flags related to each paste-tile. @see ClipboardPasteTool::PasteTile */
+enum PasteTileFlags {
+	TPS_NONE               = 0,      ///< This tile is passive in a pastemap, no calculation were done on this tile, will not be not affected by a paste.
+	TPS_HAS_MIN_HEIGHT     = 1 << 0, ///< Desired height of this tile is bigger then present height, tile needs to be raisen.
+	TPS_HAS_MAX_HEIGHT     = 1 << 1, ///< Desired height of this tile is smaller then present height, tile needs to be lowered.
+	TPS_HAS_EXACT_HEIGHT = TPS_HAS_MIN_HEIGHT | TPS_HAS_MAX_HEIGHT, ///< Present and desired heights of this tile are the same.
+	TPS_NEED_BULDOZE       = 1 << 2, ///< Tile needs to be buldozed.
+};
+typedef SimpleTinyEnumT<PasteTileFlags, byte> PasteTileFlagsByte;
+
+static void SendCommand(TileIndex tile, uint32 p1, uint32 p2, CommandCallback *callback, uint32 cmd);
+static void SendPlaceRailTrack(TileIndex tile, Track track, RailType rail_type);
+static void SendPlaceRoad(TileIndex tile, RoadBits road_bits,  RoadType road_type);
+static void SendPlaceCanal(TileIndex tile);
+static void SendPlaceSignals(TileIndex tile, SignalType type, SignalVariant variant, Trackdir location, bool two_way);
+//static void SendPlaceRoadStop(TileIndex tile, uint8 direction, uint8 roadtype, bool truck_stop, bool drive_through);
+static void SendPlaceRailTunnel(TileIndex tile, RailType rail_type);
+static void SendPlaceRoadTunnel(TileIndex tile, RoadTypes road_types);
+static void SendPlaceRailBridge(TileIndex start, TileIndex end, BridgeType bridge_type, RailType rail_type);
+static void SendPlaceRoadBridge(TileIndex start, TileIndex end, BridgeType bridge_type, RoadTypes road_types);
+static void SendPlaceCannalBridge(TileIndex start, TileIndex end, BridgeType bridge_type);
+static void SendPlaceRailDepot(TileIndex tile, RailType rail_type, DiagDirection direction);
+static void SendPlaceRoadDepot(TileIndex tile, RoadType road_type, DiagDirection direction);
+static void SendPlaceShipDepot(TileIndex tile, DiagDirection direction);
+//static void SendPlaceWaypoint(TileIndex tile, TransportType transport_type);
+//static void SendClearTiles(TileIndex start, TileIndex end);
+
+struct PastemapTile {
+	PasteTileFlagsByte state;
+	uint8 target_height;
+};
+
+class PastemapTilesArray : public Compact2DArray<PastemapTile> {
+private:
+	struct TripleTileIter {
+		TemplateTilesArray::IterC template_tile;
+		PastemapTilesArray::Iter pastemap_tile;
+		TileIndex board_tile;
+
+		TripleTileIter(PastemapTilesArray *pastemap)
+			: template_tile(pastemap->template_tiles->FirstIterC())
+			, pastemap_tile(pastemap->IterAt(MAX_TILE_HEIGHT, MAX_TILE_HEIGHT))
+			, board_tile(pastemap->PastemapToBoardTileIndex(MAX_TILE_HEIGHT, MAX_TILE_HEIGHT))
+		{
+		}
+
+		FORCEINLINE TripleTileIter &IncX() { this->template_tile.x++, this->pastemap_tile.x++, this->board_tile++; return *this; }
+		FORCEINLINE TripleTileIter &DecX() { this->template_tile.x--, this->pastemap_tile.x--, this->board_tile--; return *this; }
+		FORCEINLINE TripleTileIter &IncY() { this->template_tile.y++, this->pastemap_tile.y++, this->board_tile += MapSizeX(); return *this; }
+		FORCEINLINE TripleTileIter &DecY() { this->template_tile.y--, this->pastemap_tile.y--, this->board_tile -= MapSizeX(); return *this; }
+
+		FORCEINLINE TripleTileIter &Move(int y, int x)
+		{
+			this->template_tile.Move(x, y);
+			this->pastemap_tile.Move(x, y);
+			this->board_tile += TileDiffXY(x, y);
+			return *this;
+		}
+	};
+
+	struct PasteTilesWaitList {
+	public:
+		struct Node {
+			Compact2DOffset paste_tile;
+			uint pos_of_paste_tile;
+		};
+
+	private:
+		Node *nodes;
+		uint num_waiting;
+
+		Compact2DOffset &AtPos(uint pos) { return this->nodes[pos].paste_tile; }
+		uint &PosOf(Compact2DOffset tile) { return this->nodes[tile].pos_of_paste_tile; }
+
+	public:
+		PasteTilesWaitList(Node *buffer, uint num_items) : nodes(buffer), num_waiting(0)
+		{
+			while (num_items-- > 0) {
+				this->AtPos(num_items) = Compact2DOffset(num_items);
+				this->PosOf(Compact2DOffset(num_items)) = num_items;
+			}
+		}
+
+		bool HasWaitingTile() { return this->num_waiting > 0; }
+		Compact2DOffset PopWaitingTile() { return this->AtPos(--this->num_waiting); }
+
+		void MarkTileAsWaiting(Compact2DOffset tile)
+		{
+			uint tile_pos = this->PosOf(tile);
+			if (tile_pos >= this->num_waiting) {
+				if (tile_pos > this->num_waiting) {
+					::Swap(this->PosOf(tile), this->PosOf(this->AtPos(this->num_waiting)));
+					::Swap(this->AtPos(this->num_waiting), this->AtPos(tile_pos));
+				}
+				this->num_waiting++;
+			}
+		}
+	};
+
+	const TemplateTilesArray *template_tiles; ///< Being pasted template tiles.
+	TileIndex pastemap_target_tile;           ///< Northern tile of pastemap area.
+
+	FORCEINLINE static void ReadTileTargetHeight(const TripleTileIter &iter)
+	{
+		if (iter.pastemap_tile->state == TPS_NONE) PastemapTilesArray::ForceReadTileTargetHeight(iter);
+	}
+
+	FORCEINLINE static void ForceReadTileTargetHeight(const TripleTileIter &iter)
+	{
+		uint target_height = iter.template_tile->height;
+		uint current_height = TileHeight(iter.board_tile);
+
+		iter.pastemap_tile->target_height = target_height;
+		if (target_height <= current_height) iter.pastemap_tile->state |= TPS_HAS_MAX_HEIGHT;
+		if (target_height >= current_height) iter.pastemap_tile->state |= TPS_HAS_MIN_HEIGHT;
+	}
+
+public:
+	void Init(const Template *template_, TileIndex template_target_tile)
+	{
+		this->template_tiles = &template_->Tiles();
+		this->pastemap_target_tile = template_target_tile + TileDiffXY(-(int)MAX_TILE_HEIGHT, -(int)MAX_TILE_HEIGHT);
+		this->Resize(this->template_tiles->Width() + 2 * MAX_TILE_HEIGHT, this->template_tiles->Height() + 2 * MAX_TILE_HEIGHT);
+		MemSetT(this->Data(), 0, this->Length());
+	}
+
+	TileIndex PastemapToBoardTileIndex(uint x, uint y)
+	{
+		TileIndex ret = this->pastemap_target_tile + TileDiffXY(x, y);
+		assert(ret < MapSize());
+		return ret;
+	}
+
+	TileIndex PastemapOffsetToBoardTileIndex(Compact2DOffset offset)
+	{
+		Point index = this->OffsetToIndex<int>(offset);
+		return this->PastemapToBoardTileIndex(index.x, index.y);
+	}
+
+	void PreBuildPastemapHeights()
+	{
+		if (_paste_settings.restore_heights == CHRM_NONE) return;
+		
+		TripleTileIter iter(this);
+
+		if (_paste_settings.restore_heights == CHRM_MINIMAL) {
+			/* We must read heights around each non-clear tile and move them to a pastemap.
+			 *
+			 * We will iterate tiles row by row. Inner loop will be splitted into two loops - the one
+			 * that iterates clear tiles and the one that iterates non-clear tiles. We will jump
+			 * from one loop to another when the type of a tile chnages from clear to non-clear or
+			 * vice versa.
+			 * This is one of rare times where the goto will be used to increas performance and
+			 * readability. This is one of template algorithms with the worse complexity - O(A)
+			 * where A is the area in tiles. It's also a part of the most exhaustive operation on
+			 * a template - pasting. */
+
+			for (
+				/* We must stop at the last tile of the last but one row. Last row and collumn don't
+				 * store tiles, it's only for heights around previous row/column. */
+				const TemplateTile *end_template_tile = this->template_tiles->LastRow() - 1;
+				iter.template_tile < end_template_tile;
+				iter.Move(1, this->template_tiles->Width() - 1) // move back to the beggining of row and advance to next row
+			) {
+				const TemplateTile *last_in_row_template_tile = iter.template_tile.Relative(this->template_tiles->Width() - 1, 0);
+
+				/* The first loop, don't read heights until we are on a clear tile. */
+				CLEAR_TILES_LOOP:
+				while (iter.template_tile < last_in_row_template_tile) {
+					/* If this is a non-clear tile, clear tiles ends here. */
+					if (iter.template_tile->type != TTT_CLEAR) {
+						/* No heights were read behind this tile so we must read each of 4 corners
+						 * around. Then jump to the second loop.
+						 * S and E corners were never read in oppostion to N and W corners - they could
+						 * be read before when we was processing previous row. */
+						this->ReadTileTargetHeight(iter); // N corner
+						this->ForceReadTileTargetHeight(iter.IncY()); // E corner
+						this->ForceReadTileTargetHeight(iter.IncX()); // S corner
+						this->ReadTileTargetHeight(iter.DecY()); // W corner
+
+						goto NON_CLEAR_TILES_LOOP;
+					}
+
+					/* In this loop we don't need to read any heights, just advance to the next tile. */
+					iter.IncX();
+				}
+				continue; // this row is done, do not fall into the second loop
+
+				/* The second loop, read heights around a tile while it's non-clear. */
+				NON_CLEAR_TILES_LOOP:
+				while (iter.template_tile < last_in_row_template_tile) {
+					/* If this is a clear tile, non-clear tiles ends here. */
+					if (iter.template_tile->type == TTT_CLEAR) {
+						/* Heights around previous tiles were copied already so just advance to the
+						 * next tile in this row and jump to the first loop. */
+						iter.IncX();
+						goto CLEAR_TILES_LOOP;
+					}
+
+					/* In this loop we read heights from S and W corners of a current tile. N and E
+					 * corners were read in previous step (they belong aloso to previous tile).
+					 * S corner was never read in oppostion to W corner - it could be read before
+					 * when previous row was processed. */
+					this->ForceReadTileTargetHeight(iter.Move(1, 1)); // S corner
+					this->ReadTileTargetHeight(iter.DecY()); // W corner
+				}
+			}
+		} else { // CHRM_FULL
+			/* Read all heights from each tile corner. */
+			const TemplateTile *end_template_tile = this->template_tiles->End();
+			while (iter.template_tile < end_template_tile) {
+				const TemplateTile *row_end_template_tile = iter.template_tile.Relative(this->template_tiles->Width(), 0);
+				while (iter.template_tile < row_end_template_tile) {
+					this->ForceReadTileTargetHeight(iter);
+					iter.IncX();
+				}
+				iter.Move(1, -(int)this->template_tiles->Width());
+			}
+		}
+	}
+
+	void BuildPastemapHeights()
+	{
+		// TODO: map borders!
+
+		PasteTilesWaitList wait_list(AllocaM(PasteTilesWaitList::Node, this->Length()), this->Length());
+
+		/* Firstly we will mark as "waiting to be visited" tiles with
+		 * pre-built target heights that differ from current map heights. */
+		for (Compact2DOffset i(0); (uint)i < this->Length(); i++) {
+			PasteTileFlags state = this->At(i)->state;
+			if ((state != TPS_NONE) && (state != TPS_HAS_EXACT_HEIGHT)) {
+				wait_list.MarkTileAsWaiting(i);
+			}
+		}
+
+		Compact2DOffset pastemap_tile_offset;
+		PastemapTile *pastemap_tile;
+
+		while (wait_list.HasWaitingTile()) {
+			pastemap_tile_offset = wait_list.PopWaitingTile();
+			pastemap_tile = this->At(pastemap_tile_offset);
+			if (pastemap_tile->state == TPS_HAS_MAX_HEIGHT) {
+				this->ReheightHasMaxNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset( 1,  0)), &wait_list);
+				this->ReheightHasMaxNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset(-1,  0)), &wait_list);
+				this->ReheightHasMaxNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset( 0,  1)), &wait_list);
+				this->ReheightHasMaxNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset( 0, -1)), &wait_list);
+			} else {
+				assert(pastemap_tile->state == TPS_HAS_MIN_HEIGHT); //TODO: remove assert after tests
+				this->ReheightHasMinNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset( 1,  0)), &wait_list);
+				this->ReheightHasMinNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset(-1,  0)), &wait_list);
+				this->ReheightHasMinNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset( 0,  1)), &wait_list);
+				this->ReheightHasMinNeighbour(*pastemap_tile, Compact2DOffset(pastemap_tile_offset + this->IndexToOffset( 0, -1)), &wait_list);
+			}
+		}
+	}
+
+	/* Kepp the method FORCEINLINE'ed, it's a part of exhaustive algortihm. */
+	FORCEINLINE void ReheightHasMaxNeighbour(const PastemapTile &tile, Compact2DOffset neighbour, PasteTilesWaitList *wait_list)
+	{
+		PastemapTile &neighbour_tile = (*this)[neighbour];
+		uint8 neighbour_max_height = min<int>(MAX_TILE_HEIGHT, tile.target_height + 1);
+		if ((neighbour_tile.state & TPS_HAS_MAX_HEIGHT) != 0) {
+			if (neighbour_tile.target_height <= neighbour_max_height) return;
+		} else {
+			assert(neighbour_tile.state == TPS_NONE); //TODO: remove assert after tests
+			if (TileHeight(this->PastemapOffsetToBoardTileIndex(neighbour)) <= neighbour_max_height) return;
+		}
+		neighbour_tile.target_height = neighbour_max_height;
+		neighbour_tile.state = TPS_HAS_MAX_HEIGHT;
+		wait_list->MarkTileAsWaiting(neighbour);
+	}
+
+	/* Kepp the method FORCEINLINE'ed, it's a part of exhaustive algortihm. */
+	void ReheightHasMinNeighbour(const PastemapTile &tile, Compact2DOffset neighbour, PasteTilesWaitList *wait_list)
+	{
+		PastemapTile &neighbour_tile = (*this)[neighbour];
+		uint8 neighbour_min_height = max<int>(0, tile.target_height - 1);
+		if ((neighbour_tile.state & TPS_HAS_MIN_HEIGHT) != 0) {
+			if (neighbour_tile.target_height >= neighbour_min_height) return;
+		} else {
+			assert(neighbour_tile.state == TPS_NONE); //TODO: remove assert after tests
+			if (TileHeight(this->PastemapOffsetToBoardTileIndex(neighbour)) >= neighbour_min_height) return;
+		}
+		neighbour_tile.target_height = neighbour_min_height;
+		neighbour_tile.state = TPS_HAS_MIN_HEIGHT;
+		wait_list->MarkTileAsWaiting(neighbour);
+	}
+};
+
+
+class ClipboardPasteTool {
+private:
+	typedef void (ClipboardPasteTool::*PasteObjectProc)(const Template::Object *object, TileIndex board_tile);
+
+	static const PasteObjectProc paste_object_procs[TOT_END];
+
+	const Template *template_;      ///< Being pasted template.
+	TileIndex template_target_tile; ///< Northern tile of pasted area.
+	PastemapTilesArray pastemap;
+
+	FORCEINLINE TileIndex TemplateToBoardTileIndex(uint x, uint y)
+	{
+		return TILE_ADDXY(this->template_target_tile, x, y);
+	}
+
+	FORCEINLINE TileIndex TemplateToBoardTileIndex(TemplateTileIndex index)
+	{
+		return this->TemplateToBoardTileIndex(index.x, index.y);
+	}
+
+	/** Check if template contents are allowed by current game options. */
+	bool GameOptionsAllowToPaste()
+	{
+		/* TODO: */
+		return true;
+	}
+
+	void BuildPastemap()
+	{
+		this->pastemap.Init(this->template_, this->template_target_tile);
+		this->pastemap.PreBuildPastemapHeights();
+		this->pastemap.BuildPastemapHeights();
+	}
+
+	void PasteHeights()
+	{
+	}
+
+	void PasteTracks()
+	{
+		/* TODO: put locks instead of canals if slope is on the map */
+
+		const TemplateTilesArray &tiles = this->template_->Tiles();
+
+		TemplateTileIndex template_tile_idx = { 0, 0 };
+		TileIndex board_tile_idx = this->template_target_tile;
+		MAP_TEMPLATE_TILES_TO_BOARD_TILES(template_tile_idx, board_tile_idx, this->template_->Width(), this->template_->Height()) {
+			const TemplateTile &template_tile = tiles[template_tile_idx];
+			switch (template_tile.type) {
+				case TTT_RAIL_TRANSPORT: {
+					Track track;
+					FOR_EACH_SET_TRACK(track, template_tile.rail.bits) {
+						SendPlaceRailTrack(board_tile_idx, track, template_tile.rail.type);
+					}
+					break;
+				}
+
+				case TTT_ROAD_TRANSPORT: {
+					RoadType road_type;
+					FOR_EACH_SET_ROADTYPE(road_type, template_tile.road.types) {
+						RoadBits road_bits = ExtractRoadBits(template_tile.road.bits, road_type);
+						if (road_bits != ROAD_NONE) SendPlaceRoad(board_tile_idx, road_bits, road_type);
+					}
+					break;
+				}
+
+				case TTT_WATER_TRANSPORT:
+					SendPlaceCanal(board_tile_idx);
+					break;
+
+				case TTT_AIR_TRANSPORT:
+					break;
+
+				case TTT_RAIL_X_ROAD_Y:
+				case TTT_RAIL_Y_ROAD_X: {
+					RoadBits road_bits = (template_tile.type == TTT_RAIL_X_ROAD_Y) ? ROAD_Y : ROAD_X;
+					RoadType road_type;
+					FOR_EACH_SET_ROADTYPE(road_type, template_tile.crossing.road_types) {
+						SendPlaceRoad(board_tile_idx, road_bits, road_type);
+					}
+					SendPlaceRailTrack(board_tile_idx, (template_tile.type == TTT_RAIL_X_ROAD_Y) ? TRACK_X : TRACK_Y, template_tile.crossing.rail_type);
+					break;
+				}
+
+				default: break;
+			}
+		}
+	}
+
+	void PasteBridge(const Template::Bridge *bridge, TileIndex board_tile)
+	{
+		const TemplateTile &template_tile = this->template_->Tiles()[bridge->tile];
+		TileIndex board_tile_end = TILE_ADDXY(board_tile, bridge->other_end_offset.x, bridge->other_end_offset.y);
+
+		switch (template_tile.type) {
+			case TTT_RAIL_TRANSPORT: SendPlaceRailBridge(board_tile, board_tile_end, bridge->bridge_type, template_tile.rail.type); break;
+			case TTT_ROAD_TRANSPORT: SendPlaceRoadBridge(board_tile, board_tile_end, bridge->bridge_type, template_tile.road.types); break;
+			case TTT_WATER_TRANSPORT: SendPlaceCannalBridge(board_tile, board_tile_end, bridge->bridge_type); break;
+			default: NOT_REACHED();
+		};
+	}
+
+	void PasteTunnel(const Template::Tunnel *tunnel, TileIndex board_tile)
+	{
+		/* TODO: Check if tunnel ends on proper tile. */
+
+		const TemplateTile &template_tile = this->template_->Tiles()[tunnel->tile];
+
+		switch (template_tile.type) {
+			case TTT_RAIL_TRANSPORT: SendPlaceRailTunnel(board_tile, template_tile.rail.type); break;
+			case TTT_ROAD_TRANSPORT: SendPlaceRoadTunnel(board_tile, template_tile.road.types); break;
+			default: NOT_REACHED();
+		};
+	}
+
+	void PasteStation(const Template::Station *station, TileIndex board_tile)
+	{
+		//TODO:
+	}
+
+	void PasteSignal(const Template::Signal *signal, TileIndex board_tile)
+	{
+		SendPlaceSignals(board_tile, signal->signal_type, signal->variant, signal->location, signal->two_way);
+	}
+
+	void PasteDepot(const Template::Depot *depot, TileIndex board_tile)
+	{
+		const TemplateTile &depot_tile = this->template_->Tiles()[depot->tile];
+		switch (depot_tile.type) {
+			case TTT_RAIL_TRANSPORT: SendPlaceRailDepot(board_tile, depot_tile.rail.type, depot->direction); break;
+			case TTT_ROAD_TRANSPORT: SendPlaceRoadDepot(board_tile, (RoadType)FindLastBit(depot_tile.road.types), depot->direction); break;
+			case TTT_WATER_TRANSPORT: SendPlaceShipDepot(board_tile, depot->direction); break;
+			default: NOT_REACHED();
+		}
+	}
+
+	void PasteStationPart(const Template::StationPart *station_part, TileIndex board_tile)
+	{
+		/* Do nothing, station parts are pasted from station paste procedure. */
+	}
+
+
+public:
+	ClipboardPasteTool() { }
+
+	/**
+	 * Paste template onto map taking care of multi/single player environment.
+	 * @param start_tile northern corner to paste to
+	 */
+	void Paste(const Template &template_, TileIndex start_tile)
+	{
+		DEBUG(misc, 1, "Pasting %dx%d template from (%d, %d) tile to (%d, %d) tile.",
+			template_.Width(), template_.Height(), TileX(start_tile), TileY(start_tile),
+			TileX(start_tile) + template_.Width() - 1, TileY(start_tile) + template_.Height() - 1);
+
+		this->template_ = &template_;
+		this->template_target_tile = start_tile;
+
+		if (!this->GameOptionsAllowToPaste()) return; //TODO: show apropriate message (error returned as this method result maybe)
+		
+		//DEBUG(misc, 1, "Building pastemap...");
+		//this->BuildPastemap();
+		//DEBUG(misc, 1, "Done");
+
+		//this->PasteHeights();
+
+		this->PasteTracks();
+
+		/* Paste objects */
+		for (const Template::Object *object = this->template_->Objects(); object != NULL; object = object->NextObject()) {
+			(this->*(this->paste_object_procs[object->object_type]))(object, this->TemplateToBoardTileIndex(object->tile));
+		}
+	}
+};
+
+const ClipboardPasteTool::PasteObjectProc ClipboardPasteTool::paste_object_procs[TOT_END] = {
+	(ClipboardPasteTool::PasteObjectProc)&ClipboardPasteTool::PasteBridge,      // TOT_BRIDGE
+	(ClipboardPasteTool::PasteObjectProc)&ClipboardPasteTool::PasteTunnel,      // TOT_TUNNEL
+	(ClipboardPasteTool::PasteObjectProc)&ClipboardPasteTool::PasteStation,     // TOT_STATION
+	(ClipboardPasteTool::PasteObjectProc)&ClipboardPasteTool::PasteSignal,      // TOT_SIGNAL
+	(ClipboardPasteTool::PasteObjectProc)&ClipboardPasteTool::PasteDepot,       // TOT_DEPOT
+	(ClipboardPasteTool::PasteObjectProc)&ClipboardPasteTool::PasteStationPart, // TOT_STATION_PART
+};
+
+/**
+ * DoCommand for Copy&Paste.
+ * If shift is pressed, a cost-estimate is displayed instead of executing the paste.
+ *
+ * If we are in multiplayer the pasting is redirected to the command-queue,
+ * which delays execution, to prevent overflowing the network connection.
+ */
+static void SendCommand(TileIndex tile, uint32 p1, uint32 p2, CommandCallback *callback, uint32 cmd)
+{
+#ifdef ENABLE_NETWORK
+	if (_networking) {
+		CommandQueue::QueueCommand(tile, p1, p2, callback, cmd);
+		return;
+	}
+#endif /* ENABLE_NETWORK */
+	DoCommandP(tile, p1, p2, cmd, callback);
+}
+
+/**
+ * @param tile The Tile to operate on
+ * @param mode true means Raise, false means Lower
+ */
+//void SendRaiseLowerLand(TileIndex tile, bool mode)
+//{
+//	SendCommand(tile, 8, (uint32)mode, NULL, CMD_TERRAFORM_LAND | CMD_MSG(mode ? STR_0808_CAN_T_RAISE_LAND_HERE : STR_0809_CAN_T_LOWER_LAND_HERE));
+//}
+
+static void SendPlaceRailTrack(TileIndex tile, Track track, RailType rail_type)
+{
+	SendCommand(tile, rail_type, track, NULL, CMD_BUILD_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK));
+}
+
+static void SendPlaceRoad(TileIndex tile, RoadBits road_bits, RoadType road_type)
+{
+	/* See CmdBuildLongRoad. */
+
+	if ((road_bits & ROAD_X) != 0) {
+		SendCommand(tile, tile,
+			(((road_bits & ROAD_NE) != 0) ? 0 : 1 << 0) |
+			(((road_bits & ROAD_SW) == 0) ? 0 : 1 << 1) |
+			(AXIS_X << 2) |
+			(road_type << 3) /* TODO: |
+			(one_way << 5) */,
+			NULL, CMD_BUILD_LONG_ROAD | CMD_MSG(STR_ERROR_CAN_T_BUILD_ROAD_HERE)
+		);
+	}
+
+	if ((road_bits & ROAD_Y) != 0) {
+		SendCommand(tile, tile,
+			(((road_bits & ROAD_NW) != 0) ? 0 : 1 << 0) |
+			(((road_bits & ROAD_SE) == 0) ? 0 : 1 << 1) |
+			(AXIS_Y << 2) |
+			(road_type << 3) /* TODO: |
+			(one_way << 5) */,
+			NULL, CMD_BUILD_LONG_ROAD | CMD_MSG(STR_ERROR_CAN_T_BUILD_ROAD_HERE)
+		);
+	}
+}
+
+static void SendPlaceCanal(TileIndex tile)
+{
+	SendCommand(tile, tile, 0, NULL, CMD_BUILD_CANAL | CMD_MSG(STR_ERROR_CAN_T_BUILD_CANALS));
+}
+
+static void SendPlaceSignals(TileIndex tile, SignalType type, SignalVariant variant, Trackdir location, bool two_way)
+{
+	assert(IsValidTrackdir(location) && !IsReversingRoadTrackdir(location));
+
+	/* two-way signal - no cycling
+	 * one-way signal at [TRACKDIR_LEFT_S..TRACKDIR_LEFT_N) - cycle twice
+	 * other one-way signals - cycle once */
+	int cycle = two_way ? 0 : (IsInsideMM(location, TRACKDIR_LEFT_S, TRACKDIR_LEFT_N) ? 2 : 1);
+	if (type > SIGTYPE_LAST_NOPBS) cycle--; // cycle PBS one time less as there is no two-way PBS.
+
+	SendCommand(tile, TrackdirToTrack(location) | variant << 4 | type << 5 | cycle << 15, 0, NULL,
+			CMD_BUILD_SIGNALS | CMD_MSG(STR_ERROR_CAN_T_BUILD_SIGNALS_HERE));
+}
+
+//static void SendPlaceRoadStop(TileIndex tile, uint8 direction, uint8 roadtype, bool truck_stop, bool drive_through)
+//{
+//	SendCommand(tile, direction,
+//		((int)!!truck_stop) | ((int)!!drive_through) << 1 | ((int)!!roadtype) << 2 | INVALID_STATION << 16,
+//		NULL, CMD_BUILD_ROAD_STOP | CMD_MSG(truck_stop ? STR_1809_CAN_T_BUILD_TRUCK_STATION : STR_1808_CAN_T_BUILD_BUS_STATION));
+//}
+
+static void SendPlaceRailTunnel(TileIndex tile, RailType rail_type)
+{
+	SendCommand(tile, rail_type, 0, NULL, CMD_BUILD_TUNNEL | CMD_MSG(STR_ERROR_CAN_T_BUILD_TUNNEL_HERE));
+}
+
+static void SendPlaceRoadTunnel(TileIndex tile, RoadTypes road_types)
+{
+	SendCommand(tile, (1 << 9) | road_types, 0, NULL, CMD_BUILD_TUNNEL | CMD_MSG(STR_ERROR_CAN_T_BUILD_TUNNEL_HERE));
+}
+
+static void SendPlaceRailBridge(TileIndex start, TileIndex end, BridgeType bridge_type, RailType rail_type)
+{
+	SendCommand(start, end, bridge_type | (rail_type << 8) | (TRANSPORT_RAIL << 15),
+		NULL, CMD_BUILD_BRIDGE | CMD_MSG(STR_ERROR_CAN_T_BUILD_BRIDGE_HERE));
+}
+
+static void SendPlaceRoadBridge(TileIndex start, TileIndex end, BridgeType bridge_type, RoadTypes road_types)
+{
+	SendCommand(start, end, bridge_type | (road_types << 8) | (TRANSPORT_ROAD << 15),
+		NULL, CMD_BUILD_BRIDGE | CMD_MSG(STR_ERROR_CAN_T_BUILD_BRIDGE_HERE));
+}
+
+static void SendPlaceCannalBridge(TileIndex start, TileIndex end, BridgeType bridge_type)
+{
+	SendCommand(start, end, bridge_type | (TRANSPORT_WATER << 15),
+		NULL, CMD_BUILD_BRIDGE | CMD_MSG(STR_ERROR_CAN_T_BUILD_BRIDGE_HERE));
+}
+
+static void SendPlaceRailDepot(TileIndex tile, RailType rail_type, DiagDirection direction)
+{
+	SendCommand(tile, rail_type, direction, NULL,
+		CMD_BUILD_TRAIN_DEPOT | CMD_MSG(STR_ERROR_CAN_T_BUILD_TRAIN_DEPOT));
+}
+
+static void SendPlaceRoadDepot(TileIndex tile, RoadType road_type, DiagDirection direction)
+{
+	SendCommand(tile, direction | (road_type << 2), 0, NULL,
+		CMD_BUILD_ROAD_DEPOT | CMD_MSG(STR_ERROR_CAN_T_BUILD_ROAD_HERE));
+}
+
+static void SendPlaceShipDepot(TileIndex tile, DiagDirection direction)
+{
+	SendCommand(tile, DiagDirToAxis(direction), 0, NULL,
+		CMD_BUILD_SHIP_DEPOT | CMD_MSG(STR_ERROR_CAN_T_BUILD_ROAD_HERE));
+}
+
+//static void SendPlaceWaypoint(TileIndex tile, TransportType transport_type)
+//{
+//	switch (transport_type) {
+//		case TRANSPORT_RAIL:
+//			//SendCommand(tile, waypoint_type, 0, NULL, CMD_BUILD_TRAIN_WAYPOINT | CMD_MSG(STR_CANT_BUILD_TRAIN_WAYPOINT));
+//			break;
+
+//		case TRANSPORT_WATER:
+//			//SendCommand(tile, waypoint_type, 0, NULL, CMD_BUILD_TRAIN_WAYPOINT | CMD_MSG(STR_CANT_BUILD_TRAIN_WAYPOINT));
+//			break;
+
+//		default:
+//			NOT_REACHED();
+//	}
+//}
+
+//static void SendClearTiles(TileIndex start, TileIndex end)
+//{
+//	SendCommand(start, end, 0, NULL, CMD_CLEAR_AREA | CMD_MSG(STR_00B5_CAN_T_CLEAR_THIS_AREA));
+//}
+
+/**
+ * Copy given area into the clipboard.
+ * The way the tiles are copied is determined by clipboard options.
+ *
+ *
+ */
+void Clipboard::Paste(TileIndex start)
+{
+	static ClipboardPasteTool paste_tool;
+	paste_tool.Paste(_clipboard_content, start);
+};
diff -ibruN src/command_queue.cpp src/command_queue.cpp
--- src/command_queue.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/command_queue.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,70 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* $Id: command_queue.cpp 4998 2006-05-30 16:15:17Z Frostregen $ */
+
+#include "stdafx.h"
+#include "tile_type.h"
+#include "command_type.h"
+#include "command_func.h"
+#include "debug.h"
+#include "command_queue.h"
+#include "settings_type.h"
+#include "gfx_func.h"
+#include "variables.h"
+
+std::queue<CommandContainer> CommandQueue::queue;
+
+/**
+ * Enqueue the given command.
+ * Can be executed later by calling ExecuteNextCommand
+ */
+void CommandQueue::QueueCommand(TileIndex tile, uint32 p1, uint32 p2, CommandCallback *callback, uint32 cmd)
+{
+	static CommandContainer cc;
+
+	cc.tile = tile;
+	cc.p1   = p1;
+	cc.p2   = p2;
+	cc.callback = callback;
+	cc.cmd  = cmd;
+
+	/* add it to the queue */
+	CommandQueue::queue.push(cc);
+}
+
+/**
+ * Executes the next queued command, or does nothing if queue is emtpy
+ * Since DoCommandP checks for _shift_pressed,
+ * we have to store, unset und restore it.
+ */
+void CommandQueue::ExecuteNextCommand()
+{
+	/* Check if queue is not empty */
+	if (CommandQueue::queue.empty()) return;
+
+	/* Backup and unset _shift_pressed */
+	bool temp_shift_pressed = _shift_pressed;
+	_shift_pressed = false;
+	/* Get the command and execute it */
+	DoCommandP(&CommandQueue::queue.front());
+	/* Restore _shift_pressed */
+	_shift_pressed = temp_shift_pressed;
+	/* Remove command from the queue */
+	CommandQueue::queue.pop();
+}
+
+/** Process the CommandQueue */
+void CommandQueue::GameLoop()
+{
+	/* TODO: rename or redesign ("CommandQueue" <-> "network_paste_speed") */
+	if (_settings_client.clipboard.pasting.network_paste_speed < 255) {
+		if ((_tick_counter % _settings_client.clipboard.pasting.network_paste_speed) == 0) {
+			CommandQueue::ExecuteNextCommand();
+		}
+	}
+}
diff -ibruN src/command_queue.h src/command_queue.h
--- src/command_queue.h	1970-01-01 03:00:00.000000000 +0300
+++ src/command_queue.h	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,31 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file command_queue.h Commands queue. */
+
+#ifndef COMMAND_QUEUE_H
+#define COMMAND_QUEUE_H
+
+#include "map_type.h"
+#include "command_type.h"
+#include "settings_type.h"
+#include <queue>
+
+class CommandQueue {
+private:
+	static std::queue<CommandContainer> queue;
+
+public:
+	/** Clear the queue. */
+	void Clear() { CommandQueue::queue = std::queue<CommandContainer>(); }
+
+	static void QueueCommand(TileIndex tile, uint32 p1, uint32 p2, CommandCallback *callback, uint32 cmd);
+	static void ExecuteNextCommand();
+	static void GameLoop();
+};
+
+#endif /* COMMAND_QUEUE_H */
Binary files src/core/.DS_Store and src/core/.DS_Store differ
diff -ibruN src/core/bitmath_func.hpp src/core/bitmath_func.hpp
--- src/core/bitmath_func.hpp	2010-02-05 20:05:58.000000000 +0300
+++ src/core/bitmath_func.hpp	2010-06-20 15:22:46.000000000 +0400
@@ -321,6 +321,30 @@
 	for (i = 0; b != 0; i++, b >>= 1) \
 		if (b & 1)
 
+/**
+ * Do an operation for each set bit in a value.
+ *
+ * This macros is used to do an operation for each set bit in a given bitset value.
+ * Second arguments is the variable that can be reused in the operation due to it's
+ * the bit position counter. The 4th argument is the bitset value.
+ *
+ * In opposition to FOR_EACH_SET_BIT, bitset value can be any expression. This
+ * expression will be evaluated only once.
+ *
+ * @param Tbitpos_type Type of the position counter variable.
+ * @param bitpos_var   The position counter variable.
+ * @param Tbitset_type Type of the bitset value.
+ * @param bitset_value The bitset value which we check for bits, place here any expression.
+ *
+ * @see FOR_EACH_SET_BIT
+ */
+#define FOR_EACH_SET_BIT_EX(Tbitpos_type, bitpos_var, Tbitset_type, bitset_value) \
+	for (                                                                          \
+		Tbitset_type ___FESBE_bits = (bitpos_var = (Tbitpos_type)0, bitset_value);  \
+		___FESBE_bits != (Tbitset_type)0;                                           \
+		___FESBE_bits = (Tbitset_type)(___FESBE_bits >> 1), bitpos_var++            \
+	)                                                                              \
+		if ((___FESBE_bits & 1) != 0)
 
 #if defined(__APPLE__)
 	/* Make endian swapping use Apple's macros to increase speed
diff -ibruN src/core/geometry_func.hpp src/core/geometry_func.hpp
--- src/core/geometry_func.hpp	2009-08-22 00:21:05.000000000 +0400
+++ src/core/geometry_func.hpp	2010-06-20 15:22:46.000000000 +0400
@@ -13,7 +13,343 @@
 #define GEOMETRY_FUNC_HPP
 
 #include "geometry_type.hpp"
+#include "../direction_type.h"
+
+/**
+ * Add to dimension another dimension.
+ * @param left The dimension to add to.
+ * @param right The another dimension to add.
+ * @return reference to left.
+ */
+template <typename T>
+inline static DimensionT<T> &operator += (DimensionT<T> &left, const DimensionT<T> &right)
+{
+	left.width += right.width;
+	left.height += right.height;
+	return left;
+}
+
+/**
+ * Subtract from dimension another dimension.
+ * @param left The dimension to subtract from.
+ * @param right The another dimension to subtract
+ * @return reference to left.
+ */
+template <typename T>
+inline static DimensionT<T> &operator -= (DimensionT<T> &left, const DimensionT<T> &right)
+{
+	left.width -= right.width;
+	left.height -= right.height;
+	return left;
+}
+
+/**
+ * Add two dimensions.
+ * @param left The first dimension to add to.
+ * @param right The second dimension to add to.
+ * @return Sum of left and right dimensions.
+ */
+template <typename T>
+static DimensionT<T> operator + (const DimensionT<T> &left, const DimensionT<T> &right)
+{
+	return DimensionT<T>::Create(left.width + right.width, left.height + right.height);
+}
+
+/**
+ * Subtract two dimensions.
+ * @param left The dimension being subtracted from.
+ * @param right The dimension being subtracted
+ * @return Dimensions difference.
+ */
+template <typename T>
+inline static DimensionT<T> operator - (const DimensionT<T> &left, const DimensionT<T> &right)
+{
+	return DimensionT<T>::Create(left.width - right.width, left.height - right.height);
+}
+
+/**
+ * Translate a point by a given dimensions.
+ * @param left The point to translate.
+ * @param right The given dimension.
+ * @return reference to left.
+ */
+template <typename T>
+inline static PointT<T> &operator += (PointT<T> &left, const DimensionT<T> &right)
+{
+	left.x += right.width;
+	left.y += right.height;
+	return left;
+}
+
+/**
+ * Translate a point by a negation of given dimensions.
+ * @param left The point to translate.
+ * @param right The given dimension.
+ * @return reference to left.
+ */
+template <typename T>
+inline static PointT<T> &operator -= (PointT<T> &left, const DimensionT<T> &right)
+{
+	left.x -= right.width;
+	left.y -= right.height;
+	return left;
+}
+
+/**
+ * Calculate a point translation by a given dimensions.
+ * @param left The point to translate.
+ * @param right The given dimension.
+ * @return left translated by right.
+ */
+template <typename T>
+inline static PointT<T> operator + (const PointT<T> &left, const DimensionT<T> &right)
+{
+	return PointT<T>::Create(left.x + right.width, left.y + right.height);
+}
+
+/**
+ * Calculate a point translation by a negation of given dimensions.
+ * @param left The point to translate.
+ * @param right The given dimension.
+ * @return left translated by a negation of right.
+ */
+template <typename T>
+inline static PointT<T> operator - (const PointT<T> &left, const DimensionT<T> &right)
+{
+	return PointT<T>::Create(left.x - right.width, left.y - right.height);
+}
+
+/**
+ * Nagate coordinates of a given point.
+ * @param point The point to negate.
+ * @return Negated point.
+ */
+template <typename T>
+inline static PointT<T> operator - (const PointT<T> &point)
+{
+	return PointT<T>::Create(-point.x, -point.y);
+}
+
+/**
+ * Calculate absolute distance between two given points.
+ * @param left The first point.
+ * @param right The second point.
+ * @return The distance.
+ */
+template <typename T>
+static DimensionT<T> PointDistance(const PointT<T> &a, const PointT<T> &b)
+{
+	return DimensionT<T>::Create((a.x < b.x) ? (b.x - a.x) : (a.x - b.x), (a.y < b.y) ? (b.y - a.y) : (a.y - b.y));
+}
+
+/**
+ * Compute union of two rectangles. See RectT::Unify for more information.
+ * @param a The first rectangle.
+ * @param b The second rectangle.
+ * @return Union of given rectangles.
+ */
+template <typename T>
+static RectT<T> RectUnion(const RectT<T> &a, const RectT<T> &b)
+{
+	return RectT<T>::Create(min(a.left, b.left), min(a.top, b.top), max(a.right, b.right), max(a.bottom, b.bottom));
+}
+
+/**
+ * Compute intersection of two rectangles. See RectT::Intersect for more information.
+ * @param a The first rectangle.
+ * @param b The second rectangle.
+ * @return Intersection of given rectangles.
+ */
+template <typename T>
+static RectT<T> RectIntersection(const RectT<T> &a, const RectT<T> &b)
+{
+	return RectT<T>::Create(max(a.left, b.left), max(a.top, b.top), min(a.right, b.right), min(a.bottom, b.bottom));
+}
 
 Dimension maxdim(const Dimension &d1, const Dimension &d2);
 
+/**
+ * Convert DirTransform to LinearMap with a center of the transformation in point (0, 0).
+ * @param transformation DirTransform to convert.
+ * @return Conversion result.
+ * @see FillArrayIndicesMap
+ */
+template <typename T>
+inline static const LinearMap<T> &DirTransformToLinearMap(DirTransform transformation)
+{
+	static const LinearMap<T> REFLECTION_N_S_LIN_MAP = { {
+		{  0, 1  },
+		{  1, 0  }
+	} };
+
+	static const LinearMap<T> REFLECTION_W_E_LIN_MAP = { {
+		{  0, 1  },
+		{ -1, 0  }
+	} };
+
+	static const LinearMap<T> * const maps[DT_END] = {
+		&LinearMap<T>::IDENTITY,             // DT_IDENTITY
+		&LinearMap<T>::ROTATION_270,         // DT_ROTATE_90_RIGHT
+		&LinearMap<T>::ROTATION_180,         // DT_ROTATE_180
+		&LinearMap<T>::ROTATION_90,          // DT_ROTATE_90_LEFT
+		&LinearMap<T>::REFLECTION_AROUND_OX, // DT_REFLECT_NE_SW
+		&REFLECTION_W_E_LIN_MAP,             // DT_REFLECT_W_E
+		&LinearMap<T>::REFLECTION_AROUND_OY, // DT_REFLECT_NW_SE
+		&REFLECTION_N_S_LIN_MAP              // DT_REFLECT_N_S
+	};
+
+	return *maps[transformation];
+};
+
+/**
+ * Convert DirTransform to AffineMap allowing to transform 2D array indices.
+ * Center point of the transformation is selected so as to indices after transformation
+ * start from (0, 0).
+ *
+ * @param transformation DirTransform to convert.
+ * @param array_size Size of the array.
+ * @param output Pointer to AffineMap where to store result.
+ *
+ * @see DirTransformToLinearMap
+ */
+template <typename Tmap_elem, typename Tdim_coord>
+static void FillArrayIndicesMap(DirTransform transformation, DimensionT<Tdim_coord> array_size, AffineMap<Tmap_elem> *output)
+{
+	*output = DirTransformToLinearMap<Tmap_elem>(transformation);
+	
+	array_size.width--;
+	array_size.height--;
+
+	/* m-th coordinate of the array_size (0 - width, 1 - height) must be added to n-th coordinate
+	 * of the translation (0 - x, 1 - y) if transformation matrix element [m, n] is -1. */
+	output->AddTranslation(
+		array_size.width * (output->matrix[0][0] == -1) + array_size.height * (output->matrix[0][1] == -1),
+		array_size.width * (output->matrix[1][0] == -1) + array_size.height * (output->matrix[1][1] == -1)
+	);
+};
+
+/**
+ * Combine two linear transformations into one.
+ * Performing returned transformation will result in performing firstly left and secondly right transformation.
+ * @param left The first transformation.
+ * @param right The second transformation.
+ * @return Combination of left and right.
+ */
+template <typename T>
+static LinearMap<T> operator * (const LinearMap<T> &left, const LinearMap<T> &right)
+{
+	LinearMap<T> ret = { { {
+		left.matrix[0][0] * right.matrix[0][0] + left.matrix[0][1] * right.matrix[1][0],
+		left.matrix[0][0] * right.matrix[0][1] + left.matrix[0][1] * right.matrix[1][1],
+	}, {
+		left.matrix[1][0] * right.matrix[0][0] + left.matrix[1][1] * right.matrix[1][0],
+		left.matrix[1][0] * right.matrix[0][1] + left.matrix[1][1] * right.matrix[1][1],
+	} } };
+
+	return ret;
+}
+
+/**
+ * Perform linear transformation on a given point.
+ * @param left Linear transformation to perform.
+ * @param right The point to transform.
+ * @return The result of the transformation.
+ */
+template <typename T, typename Tcoord>
+static PointT<Tcoord> operator * (const LinearMap<T> &left, const PointT<Tcoord> &right)
+{
+	PointT<Tcoord> ret = {
+		(Tcoord)(left.matrix[0][0] * right.x + left.matrix[0][1] * right.y),
+		(Tcoord)(left.matrix[1][0] * right.x + left.matrix[1][1] * right.y)
+	};
+
+	return ret;
+}
+
+/**
+ * Combine two affine transformations into one.
+ * Performing returned transformation will result in performing firstly left and secondly right transformation.
+ * @param left The first transformation.
+ * @param right The second transformation.
+ * @return Combination of left and right.
+ */
+template <typename T>
+static AffineMap<T> operator * (const AffineMap<T> &left, const AffineMap<T> &right)
+{
+	AffineMap<T> ret = { { {
+		left.matrix[0][0] * right.matrix[0][0] + left.matrix[0][1] * right.matrix[1][0],
+		left.matrix[0][0] * right.matrix[0][1] + left.matrix[0][1] * right.matrix[1][1],
+		left.matrix[0][0] * right.matrix[0][2] + left.matrix[0][1] * right.matrix[1][2] + left.matrix[0][2]
+	}, {
+		left.matrix[1][0] * right.matrix[0][0] + left.matrix[1][1] * right.matrix[1][0],
+		left.matrix[1][0] * right.matrix[0][1] + left.matrix[1][1] * right.matrix[1][1],
+		left.matrix[1][0] * right.matrix[0][2] + left.matrix[1][1] * right.matrix[1][2] + left.matrix[1][2]
+	} } };
+
+	return ret;
+}
+
+/**
+ * Combine affine and linear transformations into one.
+ * Performing returned transformation will result in performing firstly left and secondly right transformation.
+ * @param left The affine transformation.
+ * @param right The linear transformation.
+ * @return Combination of left and right.
+ */
+template <typename T>
+static AffineMap<T> operator * (const AffineMap<T> &left, const LinearMap<T> &right)
+{
+	AffineMap<T> ret = { { {
+		left.matrix[0][0] * right.matrix[0][0] + left.matrix[0][1] * right.matrix[1][0],
+		left.matrix[0][0] * right.matrix[0][1] + left.matrix[0][1] * right.matrix[1][1],
+		left.matrix[0][2]
+	}, {
+		left.matrix[1][0] * right.matrix[0][0] + left.matrix[1][1] * right.matrix[1][0],
+		left.matrix[1][0] * right.matrix[0][1] + left.matrix[1][1] * right.matrix[1][1],
+		left.matrix[1][2]
+	} } };
+
+	return ret;
+}
+
+/**
+ * Combine linear and affine transformations into one.
+ * Performing returned transformation will result in performing firstly left and secondly right transformation.
+ * @param left The linear transformation.
+ * @param right The affine transformation.
+ * @return Combination of left and right.
+ */
+template <typename T>
+static AffineMap<T> operator * (const LinearMap<T> &left, const AffineMap<T> &right)
+{
+	AffineMap<T> ret = { { {
+		left.matrix[0][0] * right.matrix[0][0] + left.matrix[0][1] * right.matrix[1][0],
+		left.matrix[0][0] * right.matrix[0][1] + left.matrix[0][1] * right.matrix[1][1],
+		left.matrix[0][0] * right.matrix[0][2] + left.matrix[0][1] * right.matrix[1][2]
+	}, {
+		left.matrix[1][0] * right.matrix[0][0] + left.matrix[1][1] * right.matrix[1][0],
+		left.matrix[1][0] * right.matrix[0][1] + left.matrix[1][1] * right.matrix[1][1],
+		left.matrix[1][0] * right.matrix[0][2] + left.matrix[1][1] * right.matrix[1][2]
+	} } };
+
+	return ret;
+}
+
+/**
+ * Perform affine transformation on a given point.
+ * @param left Affine transformation to perform.
+ * @param right The point to transform.
+ * @return The result of the transformation.
+ */
+template <typename T, typename Tcoord>
+static PointT<Tcoord> operator * (const AffineMap<T> &left, const PointT<Tcoord> &right)
+{
+	PointT<Tcoord> ret = {
+		(Tcoord)(left.matrix[0][0] * right.x + left.matrix[0][1] * right.y + left.matrix[0][2]),
+		(Tcoord)(left.matrix[1][0] * right.x + left.matrix[1][1] * right.y + left.matrix[1][2])
+	};
+
+	return ret;
+}
+
 #endif /* GEOMETRY_FUNC_HPP */
diff -ibruN src/core/geometry_type.hpp src/core/geometry_type.hpp
--- src/core/geometry_type.hpp	2009-08-22 00:21:05.000000000 +0400
+++ src/core/geometry_type.hpp	2010-06-20 15:22:46.000000000 +0400
@@ -12,6 +12,8 @@
 #ifndef GEOMETRY_TYPE_HPP
 #define GEOMETRY_TYPE_HPP
 
+#include <limits>
+
 #if defined(__AMIGA__)
 	/* AmigaOS already has a Point declared */
 	#define Point OTTD_Point
@@ -23,42 +25,558 @@
 	#define Point OTTD_Point
 #endif /* __APPLE__ */
 
+template <typename T>
+struct PointT;
+
+/**
+ * Dimensions (a width and height) of a rectangle in 2D.
+ * @tparam T Type of fields storing dimensions.
+ */
+template <typename T>
+struct DimensionT {
+	T width;  ///< The width.
+	T height; ///< The height.
+
+	/**
+	 * Create initialized DimensionT object.
+	 * @note This is a "named constructor", no regular constructor to keep POD'ness.
+	 * @param width Initial width.
+	 * @param height Initial height.
+	 * @return DimensionT initialized with given values.
+	 */
+	FORCEINLINE static DimensionT<T> Create(T width, T height)
+	{
+		DimensionT<T> ret = { width, height };
+		return ret;
+	}
+
+	/**
+	 * Cast to PointT structure.
+	 * The width becomes the x coordinate and the height becomes the y coordinate.
+	 * @return Reference to this object as reference to PointT object.
+	 */
+	FORCEINLINE PointT<T> &AsPoint() { return reinterpret_cast<PointT<T>&>(*this); }
 
-/** Coordinates of a point in 2D */
-struct Point {
-	int x;
-	int y;
+	/**
+	 * Cast to PointT structure (const).
+	 * The width becomes the x coordinate and the height becomes the y coordinate.
+	 * @return Reference to this object as reference to PointT object.
+	 */
+	FORCEINLINE const PointT<T> &AsPoint() const { return reinterpret_cast<const PointT<T>&>(*this); }
 };
 
-/** Dimensions (a width and height) of a rectangle in 2D */
-struct Dimension {
-	uint width;
-	uint height;
+/**
+ * Coordinates of a point in 2D.
+ * @tparam T Type of fields storing coordinates.
+ */
+template <typename T>
+struct PointT {
+	T x; ///< The x coordinate.
+	T y; ///< The y coordinate.
+
+	/**
+	 * Create initialized PointT object.
+	 *
+	 * @note This is a "named constructor", no regular constructor to keep POD'ness.
+	 *
+	 * @param x Initial x coordinate.
+	 * @param y Initial y coordinate.
+	 * @return PointT initialized with given values.
+	 */
+	FORCEINLINE static PointT<T> Create(T x, T y)
+	{
+		PointT<T> ret = { x, y };
+		return ret;
+	}
+
+	/**
+	 * Cast to DimensionT structure.
+	 * The x coordinate becomes the width and the y coordinate becomes the height.
+	 * @return Reference to this object as reference to DimensionT object.
+	 */
+	FORCEINLINE DimensionT<T> &AsDimension() { return reinterpret_cast<DimensionT<T>&>(*this); }
+
+	/**
+	 * Cast to DimensionT structure (const).
+	 * The x coordinate becomes the width and the y coordinate becomes the height.
+	 * @return Reference to this object as reference to DimensionT object.
+	 */
+	FORCEINLINE const DimensionT<T> &AsDimension() const { return reinterpret_cast<const DimensionT<T>&>(*this); }
+};
+
+/**
+ * Specification of a rectangle with absolute coordinates of all edges.
+ * @tparam T Type of fields storing coordinates.
+ */
+template <typename T>
+struct RectT {
+	union {
+		/* Older GCC (and also ISO C++) forbids initialization of unnamed structures. There
+		 * must be a two the same structures containing coordinates (left/top/right/bottom),
+		 * one named and one unnamed so we could be able to:
+		 *  - make an union at all and declare other union member (left_top/right_bottom)
+		 *  - brace initialize this structure
+		 *  - use coordinates directly without the mentioned name prefix */
+		struct {
+			T left;   ///< The left coordinate.
+			T top;    ///< The top coordinate.
+			T right;  ///< The right coordinate.
+			T bottom; ///< The bottom coordinate.
+		}
+		coordinates;
+
+		struct {
+			T left;   ///< The left coordinate.
+			T top;    ///< The top coordinate.
+			T right;  ///< The right coordinate.
+			T bottom; ///< The bottom coordinate.
+		};
+
+		struct {
+			PointT<T> left_top; ///< Coordinates of upper left corner of this rectangle.
+			PointT<T> right_bottom; ///< Coordinates of lower right corner of this rectangle.
+		};
+	};
+
+	/**
+	 * Create initialized RectT object.
+	 *
+	 * @note This is a "named constructor", no regular constructor to keep POD'ness.
+	 *
+	 * @param left Initial left coordinate.
+	 * @param top Initial top coordinate.
+	 * @param right Initial right coordinate.
+	 * @param bottom Initial bottom coordinate.
+	 * @return RectT initialized with given values.
+	 */
+	FORCEINLINE static RectT<T> Create(T left, T top, T right, T bottom)
+	{
+		RectT<T> ret = { { { left, top, right, bottom } } };
+		return ret;
+	}
+
+	/**
+	 * Create initialized RectT object.
+	 *
+	 * @note This is a "named constructor", no regular constructor to keep POD'ness.
+	 *
+	 * @param left_top Initial coordinates of upper left corner.
+	 * @param right_bottom Initial coordinates of lower right corner.
+	 * @return RectT initialized with given values.
+	 */
+	FORCEINLINE static RectT<T> Create(const PointT<T> &left_top, const PointT<T> &right_bottom)
+	{
+		RectT<T> ret = { { { left_top.x, left_top.y, right_bottom.x, right_bottom.y } } };
+		return ret;
+	}
+
+	/**
+	 * Make an union of this and other rectangle and store the result in this rectangle.
+	 * In other words, this rectangle is extended exactly as much as needed to contain
+	 * the other rectangle.
+	 * @param rect The other rectangle.
+	 */
+	void Unify(const RectT<T> &rect)
+	{
+		if (this->left   > rect.left  ) this->left   = rect.left;
+		if (this->top    > rect.top   ) this->top    = rect.top;
+		if (this->bottom < rect.bottom) this->bottom = rect.bottom;
+		if (this->right  < rect.left  ) this->right  = rect.right;
+	}
+
+	/**
+	 * Make an intersection of this and other rectangle and store the result in this
+	 * rectangle. In other words, this rectangle is shrunk exactly as much as needed
+	 * to not exceed the other rectangle.
+	 * @param rect The other rectangle.
+	 */
+	void Intersect(const RectT<T> &rect)
+	{
+		if (this->left   < rect.left  ) this->left   = rect.left;
+		if (this->top    < rect.top   ) this->top    = rect.top;
+		if (this->bottom > rect.bottom) this->bottom = rect.bottom;
+		if (this->right  > rect.left  ) this->right  = rect.right;
+	}
+};
+
+/**
+ * Specification of a rectangle with an absolute top-left coordinate and
+ * a (relative) width/height.
+ * @tparam Tpoint_coord Type of fields storing top-left coordinates.
+ * @tparam Tdim_coord Type of fields storing width/height coordinates.
+ */
+template <typename Tpoint_coord, typename Tdim_coord = Tpoint_coord>
+struct PointDimensionT {
+	union {
+		/* Older GCC (and also ISO C++) forbids initialization of unnamed structures. There
+		 * must be a two the same structures containing coordinates (x/y/width/height),
+		 * one named and one unnamed so we could be able to:
+		 *  - make an union at all and declare other union member (point/dimension)
+		 *  - brace initialize this structure
+		 *  - use coordinates directly without the mentioned name prefix */
+		struct {
+			Tpoint_coord x;    ///< The x (left) coordinate.
+			Tpoint_coord y;    ///< The y (top) coordinate.
+			Tdim_coord width;  ///< The width.
+			Tdim_coord height; ///< The height.
+		}
+		coordinates;
+
+		struct {
+			Tpoint_coord x;    ///< The x (left) coordinate.
+			Tpoint_coord y;    ///< The y (top) coordinate.
+			Tdim_coord width;  ///< The width.
+			Tdim_coord height; ///< The height.
+		};
+
+		struct {
+			PointT<Tpoint_coord> point;       // The top-left coordinates.
+			DimensionT<Tdim_coord> dimension; // The width/height coordinates.
+		};
+	};
+
+	/**
+	 * Create initialized PointDimensionT object.
+	 *
+	 * @note This is a "named constructor", no regular constructor to keep POD'ness.
+	 *
+	 * @param x Initial x coordinate.
+	 * @param y Initial y coordinate.
+	 * @param width Initial width.
+	 * @param height Initial height.
+	 * @return PointDimensionT initialized with given values.
+	 */
+	FORCEINLINE static PointDimensionT<Tpoint_coord, Tdim_coord> Create(Tpoint_coord x, Tpoint_coord y, Tdim_coord width, Tdim_coord height)
+	{
+		PointDimensionT<Tpoint_coord, Tdim_coord> ret = { { { x, y, width, height } } };
+		return ret;
+	}
+
+	/**
+	 * Create initialized PointDimensionT object.
+	 *
+	 * @note This is a "named constructor", no regular constructor to keep POD'ness.
+	 *
+	 * @param point Initial x and y coordinates.
+	 * @param dimension Initial width and height.
+	 * @return PointDimensionT initialized with given values.
+	 */
+	FORCEINLINE static PointDimensionT<Tpoint_coord, Tdim_coord> Create(const PointT<Tpoint_coord> &point, const DimensionT<Tdim_coord> &dimension)
+	{
+		PointDimensionT<Tpoint_coord, Tdim_coord> ret = { { { point.x, point.y, dimension.width, dimension.height } } };
+		return ret;
+	}
+};
+
+/**
+ * A pair of two variables.
+ * @tparam Ta Type of the first variable.
+ * @tparam Ta Type of the second variable.
+ */
+template <typename Ta, typename Tb = Ta>
+struct PairT {
+	Ta a; ///< The first variable.
+	Tb b; ///< The second variable.
+
+	/**
+	 * Create initialized PairT object.
+	 *
+	 * @note This is a "named constructor", no regular constructor to keep POD'ness.
+	 *
+	 * @param a Initial value for the first variable of a pair.
+	 * @param b Initial value for the second variable of a pair.
+	 * @return PairT initialized with given values.
+	 */
+	FORCEINLINE static PairT<Ta, Tb> Create(Ta a, Tb b)
+	{
+		PairT<Ta, Tb> ret = { a, b };
+		return ret;
+	}
+};
+
+/**
+ * Type of rectangle to store and compute surrounding bounds of an object(s) in 2D.
+ * @tparam T Type of fields storing coordinates.
+ *
+ * @note There must exist an std::numeric_limits<T> instance thus T must be a numeric
+ *       type or otherwise you must instantiate the std::numeric_limits. See BoundsT::EMPTY
+ *       for more information.
+ *
+ * @note When including an object each bound is checked and updated separately i.e. when
+ *       minimal x is being updated then comparison to maximal x will not be skipped and
+ *       vice versa.
+ */
+template <typename T>
+struct BoundsT {
+	PointT<T> min; ///< Minimal x and minimal y coordinate.
+	PointT<T> max; ///< Maximal x and maximal y coordinate.
+
+	static const BoundsT<T> EMPTY;
+
+	/**
+	 * Cast to RectT structure.
+	 * Minimal x becomes left coordinate, minimal y becomes top coordinate and so on.
+	 * @return Reference to this object as reference to RectT object.
+	 */
+	FORCEINLINE RectT<T> &AsRect() { return reinterpret_cast<RectT<T>&>(*this); }
+
+	/**
+	 * Cast to RectT structure (const).
+	 * Minimal x becomes left coordinate, minimal y becomes top coordinate and so on.
+	 * @return Reference to this object as reference to RectT object.
+	 */
+	FORCEINLINE const RectT<T> &AsRect() const { return reinterpret_cast<RectT<T>&>(*this); }
+
+	/**
+	 * Cast a RectT reference to BoundsT reference.
+	 * The left coordinate becomes the minimal x, the top coordinate becomes the minimal y and so on.
+	 * @param rect RectT reference to cast from.
+	 * @return rect reference casted to BoundsT.
+	 */
+	FORCEINLINE static BoundsT<T> &FromRect(RectT<T> &rect) { return reinterpret_cast<BoundsT<T>&>(rect); }
+
+	/**
+	 * Cast a RectT reference to BoundsT reference (const).
+	 * The left coordinate becomes the minimal x, the top coordinate becomes the minimal y and so on.
+	 * @param rect RectT reference to cast from.
+	 * @return rect reference casted to BoundsT.
+	 */
+	FORCEINLINE static const BoundsT<T> &FromRect(const RectT<T> &rect) { return reinterpret_cast<BoundsT<T>&>(rect); }
+
+	/**
+	 * Include a point with a given x and y coordinates.
+	 * @param x The x coordinate of being included point.
+	 * @param y The y coordinate of being included point.
+	 * @return Reference to this object.
+	 */
+	BoundsT<T> &Include(T x, T y)
+	{
+		if (this->min.x > x) this->min.x = x;
+		if (this->max.x < x) this->max.x = x;
+		if (this->min.y > y) this->min.y = y;
+		if (this->max.y < y) this->max.y = y;
+
+		return *this;
+	}
+
+	/**
+	 * Include a point.
+	 * @param point The point to include.
+	 * @return Reference to this object.
+	 */
+	FORCEINLINE BoundsT<T> &Include(const PointT<T> &point) { return this->Include(point.x, point.y); }
+
+	/**
+	 * Include a rectangle.
+	 * @param rect The rectangle to include.
+	 * @return Reference to this object.
+	 */
+	FORCEINLINE BoundsT<T> &Include(const RectT<T> &rect) { return this->AsRect().Unify(rect), *this; }
+
+	/**
+	 * Include other bounds.
+	 * @param bounds The other bounds to include.
+	 * @return Reference to this object.
+	 */
+	FORCEINLINE BoundsT<T> &Include(const BoundsT<T> &bounds) { return this->Include(bounds.AsRect()); }
 };
 
-/** Specification of a rectangle with absolute coordinates of all edges */
-struct Rect {
-	int left;
-	int top;
-	int right;
-	int bottom;
+#ifdef min
+	#undef min
+#endif
+
+#ifdef max
+	#undef max
+#endif
+
+/**
+ * An empty bounds.
+ * Including any object to this bounds for the first time results in bounds of that
+ * object. std::numeric_limits<T>.max() is used to initialize minimal coordinates and
+ * std::numeric_limits<T>.min() is used to initialize maximal coordinates so they are
+ * overwritten when including any other object.
+ *
+ * @warning Minimal coordinates are grater then maximal coordinates here.
+ */
+template <typename T>
+const BoundsT<T> BoundsT<T>::EMPTY = {
+	{ std::numeric_limits<T>::max(), std::numeric_limits<T>::max() },
+	{ std::numeric_limits<T>::min(), std::numeric_limits<T>::min() }
 };
 
+/** Integer coordinates of a point in 2D. */
+typedef PointT<int> Point;
+
+/** Integer dimensions (a width and height) of a rectangle in 2D. */
+typedef DimensionT<uint> Dimension;
+
+/** Specification of a rectangle with absolute integer coordinates of all edges. */
+typedef RectT<int> Rect;
+
 /**
- * Specification of a rectangle with an absolute top-left coordinate and a
- * (relative) width/height
+ * Specification of a rectangle with an absolute top-left integer coordinate and
+ * a (relative) width/height.
  */
-struct PointDimension {
-	int x;
-	int y;
-	int width;
-	int height;
+typedef PointDimensionT<int> PointDimension;
+
+/** A pair of two integers. */
+typedef PairT<int> Pair;
+
+/** Integer, rectangular bounds. */
+typedef BoundsT<int> Bounds;
+
+
+template <typename T> struct AffineMap;
+
+/**
+ * Linear transformation matrix for 2D space.
+ * @tparam T Type of the matrix elements.
+ *
+ * @note Coordinates system known from math basics (x-axis directed right, y-axis directed up) is
+ *       left-rotated and angles are measured counterclockwise. Screen coordinates system (x-axis
+ *       directed right, y-axis directed down) is right-rotated and angle of rotation is measured
+ *       clockwise.
+ */
+template <typename T>
+struct LinearMap {
+public:
+	T matrix[2][2]; ///< Elements of the matrix.
+
+	/**
+	 * Create scaling transformation matrix with given factor.
+	 * @param x Scale factor in x dimension.
+	 * @param y Scale factor in y dimension.
+	 */
+	static LinearMap<T> Scaling(T x, T y)
+	{
+		LinearMap<T> ret = { {
+			{ x, 0 },
+			{ 0, y }
+		} };
+
+		return ret;
+	}
+
+	inline operator AffineMap<T> () const;
+
+	static const LinearMap<T> IDENTITY;
+	static const LinearMap<T> ROTATION_90;
+	static const LinearMap<T> ROTATION_180;
+	static const LinearMap<T> ROTATION_270;
+	static const LinearMap<T> REFLECTION_AROUND_OX;
+	static const LinearMap<T> REFLECTION_AROUND_OY;
 };
 
-/** A pair of two integers */
-struct Pair {
-	int a;
-	int b;
+/** Identity transformation matrix. */
+template <typename T>
+const LinearMap<T> LinearMap<T>::IDENTITY = { {
+	{  1,  0 },
+	{  0,  1 }
+} };
+
+/** Transformation matrix to rotate by 90 degree in a direction congruent to coordinates
+ * system rotation (see LinearMap for better explanation). */
+template <typename T>
+const LinearMap<T> LinearMap<T>::ROTATION_90 = { {
+	{  0, -1 },
+	{  1,  0 }
+} };
+
+/** Transformation matrix to rotate by 180 degree. */
+template <typename T>
+const LinearMap<T> LinearMap<T>::ROTATION_180 = { {
+	{ -1,  0 },
+	{  0, -1 }
+} };
+
+/** Transformation matrix to rotate by 270 in a direction congruent to coordinates system
+ * rotation (see LinearMap for better explanation). */
+template <typename T>
+const LinearMap<T> LinearMap<T>::ROTATION_270 = { {
+	{  0,  1 },
+	{ -1,  0 }
+} };
+
+/** Transformation matrix to reflect around X axis. */
+template <typename T>
+const LinearMap<T> LinearMap<T>::REFLECTION_AROUND_OX = { {
+	{  1,  0 },
+	{  0, -1 }
+} };
+
+/** Transformation matrix to reflect around Y axis. */
+template <typename T>
+const LinearMap<T> LinearMap<T>::REFLECTION_AROUND_OY = { {
+	{ -1,  0 },
+	{  0,  1 }
+} };
+
+/**
+ * Affine transformation (linear transformation + translation) matrix for 2D space.
+ * @tparam T Type of the matrix elements.
+ * @see LinearMap
+ */
+template <typename T>
+struct AffineMap {
+public:
+	T matrix[2][3]; ///< Elements of matrix. We don't need to store last row, it's always (0, 0, 1).
+
+	/**
+	 * Assign linear transformation matrix.
+	 * @param right The linear transformation matrix.
+	 * @return reference to this object.
+	 */
+	AffineMap<T> &operator = (const LinearMap<T> &right)
+	{
+		this->matrix[0][0] = right.matrix[0][0];
+		this->matrix[0][1] = right.matrix[0][1];
+		this->matrix[0][2] = 0;
+		this->matrix[1][0] = right.matrix[1][0];
+		this->matrix[1][1] = right.matrix[1][1];
+		this->matrix[1][2] = 0;
+
+		return *this;
+	}
+
+	/**
+	 * Combine this affine transformation (as first) with translation (as second) of given coordinates.
+	 * @param x X coordinate of translation.
+	 * @param y Y coordinate of translation.
+	 */
+	void AddTranslation(T x, T y)
+	{
+		this->matrix[0][2] += x;
+		this->matrix[1][2] += y;
+	}
+
+	/** Translation transformation. */
+	static AffineMap<T> Translation(T x, T y)
+	{
+		AffineMap<T> ret = { {
+			{ 1, 0, x },
+			{ 0, 1, y }
+		} };
+
+		return ret;
+	}
+
+	static const AffineMap<T> IDENTITY;
 };
 
+/** Identity transformation matrix. */
+template <typename T>
+const AffineMap<T> AffineMap<T>::IDENTITY = { {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 }
+} };
+
+/** Cast operator to convert LinearMap into AffineMap. */
+template <typename T>
+LinearMap<T>::operator AffineMap<T> () const
+{
+	AffineMap<T> ret;
+	ret = *this;
+	return ret;
+}
+
 #endif /* GEOMETRY_TYPE_HPP */
diff -ibruN src/core/math_func.hpp src/core/math_func.hpp
--- src/core/math_func.hpp	2009-12-15 04:38:55.000000000 +0300
+++ src/core/math_func.hpp	2010-06-20 15:22:46.000000000 +0400
@@ -104,6 +104,8 @@
  * @param x The min value
  * @param n The base of the number we are searching
  * @return The smallest multiple of n equal or greater than x
+ *
+ * @see AlignAny
  */
 template <typename T>
 static FORCEINLINE T Align(const T x, uint n)
@@ -114,6 +116,71 @@
 }
 
 /**
+ * Return the smallest multiple of n equal or greater than x.
+ * AlignAny is a little slower then Align but n doesn't need to be a power of 2.
+ *
+ * @param x The min value. Must be non-negative.
+ * @param n The base of the number we are searching.
+ * @return x rounded up to the nearest multiple of n.
+ *
+ * @see Align
+ */
+template <typename T, uint N, bool Tn_is_pow_2>
+struct Aligner;
+
+template <typename T, uint N>
+struct Aligner<T, N, true> {
+	assert_compile((N & (N - 1)) == 0 && N != 0);
+
+	FORCEINLINE static T Align(T x)
+	{
+		return (T)((x + (N - 1)) & ~(T)(N - 1));
+	}
+};
+
+template <typename T, uint N>
+struct Aligner<T, N, false> {
+	assert_compile(N != 0);
+
+	FORCEINLINE static T Align(T x)
+	{
+		x = (T)(x + N - 1);
+		return x - x % N;
+	}
+};
+
+/**
+ * Return the smallest multiple of N equal or greater than x.
+ * N doesn't need to be a power of 2, if it is then a little faster algorithm is used.
+ *
+ * @tparam T Type of the x.
+ * @tparam N The base of the number we are searching.
+ *
+ * @param x The min value. Must be non-negative.
+ * @return x rounded up to the nearest multiple of N.
+ */
+template <typename T, uint N>
+static FORCEINLINE T Align(T x) { return Aligner<T, N, (N & (N - 1)) == 0>::Align(x); }
+
+/**
+ * Return the smallest multiple of n equal or greater than x.
+ * AlignAny is a little slower then Align but n doesn't need to be a power of 2.
+ *
+ * @param x The min value. Must be non-negative.
+ * @param n The base of the number we are searching.
+ * @return x rounded up to the nearest multiple of n.
+ *
+ * @see Align
+ */
+template <typename T>
+static FORCEINLINE T AlignAny(T x, uint n)
+{
+	assert(n != 0);
+	x = (T)(x + n - 1);
+	return x - x % n;
+}
+
+/**
  * Return the smallest multiple of n equal or greater than x
  * Applies to pointers only
  *
diff -ibruN src/core/smallvec_type.hpp src/core/smallvec_type.hpp
--- src/core/smallvec_type.hpp	2010-02-04 00:45:48.000000000 +0300
+++ src/core/smallvec_type.hpp	2010-06-20 15:36:14.000000000 +0400
@@ -15,88 +15,57 @@
 #include "alloc_func.hpp"
 #include "math_func.hpp"
 
+/** Type of the SmallVector capacity growth. */
+enum SmallVectorGrowth {
+	SVG_LINEAR,     ///< Linear growth.
+	SVG_EXPONENTIAL ///< Exponential growth.
+};
+
 /**
- * Simple vector template class.
+ * Very-base class of SmallVector implementing all features
+ * except those related to buffer capacity growth.
  *
- * @note There are no asserts in the class so you have
- *       to care about that you grab an item which is
- *       inside the list.
- *
- * @param T The type of the items stored
- * @param S The steps of allocation
+ * @note This is an internal class, it shouldn't be used outside the header.
+ * @see SmallVector
  */
-template <typename T, uint S>
-class SmallVector {
+template <typename T>
+class SmallVectorBase {
 protected:
 	T *data;       ///< The pointer to the first item
 	uint items;    ///< The number of items stored
 	uint capacity; ///< The avalible space for storing items
 
-public:
-	SmallVector() : data(NULL), items(0), capacity(0) { }
+	SmallVectorBase() : data(NULL), items(0), capacity(0) { }
 
-	~SmallVector()
+public:
+	~SmallVectorBase()
 	{
 		free(this->data);
 	}
 
-	/**
-	 * Remove all items from the list.
-	 */
+	/** Remove all items from the vector. */
 	FORCEINLINE void Clear()
 	{
 		/* In fact we just reset the item counter avoiding the need to
-		 * probably reallocate the same amount of memory the list was
+		 * probably reallocate the same amount of memory the vector was
 		 * previously using. */
 		this->items = 0;
 	}
 
-	/**
-	 * Remove all items from the list and free allocated memory.
-	 */
+	/** Remove all items from the vector and free allocated memory. */
 	FORCEINLINE void Reset()
 	{
 		this->items = 0;
 		this->capacity = 0;
-		free(data);
-		data = NULL;
-	}
-
-	/**
-	 * Compact the list down to the smallest block size boundary.
-	 */
-	FORCEINLINE void Compact()
-	{
-		uint capacity = Align(this->items, S);
-		if (capacity >= this->capacity) return;
-
-		this->capacity = capacity;
-		this->data = ReallocT(this->data, this->capacity);
-	}
-
-	/**
-	 * Append an item and return it.
-	 * @param to_add the number of items to append
-	 * @return pointer to newly allocated item
-	 */
-	FORCEINLINE T *Append(uint to_add = 1)
-	{
-		uint begin = this->items;
-		this->items += to_add;
-
-		if (this->items > this->capacity) {
-			this->capacity = Align(this->items, S);
-			this->data = ReallocT(this->data, this->capacity);
-		}
-
-		return &this->data[begin];
+		free(this->data);
+		this->data = NULL;
 	}
 
 	/**
 	 * Search for the first occurence of an item.
 	 * The '!=' operator of T is used for comparison.
-	 * @param item Item to search for
-	 * @return The position of the item, or End() when not present
+	 * @param item Item to search for.
+	 * @return The position of the item, or End() when not present.
 	 */
 	FORCEINLINE const T *Find(const T &item) const
 	{
@@ -109,8 +78,8 @@
 	/**
 	 * Search for the first occurence of an item.
 	 * The '!=' operator of T is used for comparison.
-	 * @param item Item to search for
-	 * @return The position of the item, or End() when not present
+	 * @param item Item to search for.
+	 * @return The position of the item, or End() when not present.
 	 */
 	FORCEINLINE T *Find(const T &item)
 	{
@@ -123,8 +92,8 @@
 	/**
 	 * Search for the first occurence of an item.
 	 * The '!=' operator of T is used for comparison.
-	 * @param item Item to search for
-	 * @return The position of the item, or -1 when not present
+	 * @param item Item to search for.
+	 * @return The position of the item, or -1 when not present.
 	 */
 	FORCEINLINE int FindIndex(const T &item)
 	{
@@ -139,18 +108,17 @@
 	}
 
 	/**
-	 * Tests whether a item is present in the vector.
-	 * The '!=' operator of T is used for comparison.
-	 * @param item Item to test for
-	 * @return true iff the item is present
+	 * Test whether an item is present in the vector.
+	 * @param item The item to search for.
+	 * @return true if the item is present, false otherwise.
+	 * @note The '!=' operator of T is used for comparison.
 	 */
 	FORCEINLINE bool Contains(const T &item) const
 	{
 		return this->Find(item) != this->End();
 	}
 
-	/**
-	 * Removes given item from this vector
+	/** Removes given item from this map
 	 * @param item item to remove
 	 * @note it has to be pointer to item in this map. It is overwritten by the last item.
 	 */
@@ -161,20 +129,8 @@
 	}
 
 	/**
-	 * Tests whether a item is present in the vector, and appends it to the end if not.
-	 * The '!=' operator of T is used for comparison.
-	 * @param item Item to test for
-	 * @return true iff the item is was already present
-	 */
-	FORCEINLINE bool Include(const T &item)
-	{
-		bool is_member = this->Contains(item);
-		if (!is_member) *this->Append() = item;
-		return is_member;
-	}
-
-	/**
-	 * Get the number of items in the list.
+	 * Get the number of items in the vector.
+	 * @return The number of items.
 	 */
 	FORCEINLINE uint Length() const
 	{
@@ -182,9 +138,8 @@
 	}
 
 	/**
-	 * Get the pointer to the first item (const)
-	 *
-	 * @return the pointer to the first item
+	 * Get the pointer to the first item (const).
+	 * @return The pointer to the first item.
 	 */
 	FORCEINLINE const T *Begin() const
 	{
@@ -192,9 +147,8 @@
 	}
 
 	/**
-	 * Get the pointer to the first item
-	 *
-	 * @return the pointer to the first item
+	 * Get the pointer to the first item.
+	 * @return The pointer to the first item.
 	 */
 	FORCEINLINE T *Begin()
 	{
@@ -202,9 +156,8 @@
 	}
 
 	/**
-	 * Get the pointer behind the last valid item (const)
-	 *
-	 * @return the pointer behind the last valid item
+	 * Get the pointer behind the last item (const).
+	 * @return The pointer behind the last item.
 	 */
 	FORCEINLINE const T *End() const
 	{
@@ -212,9 +165,8 @@
 	}
 
 	/**
-	 * Get the pointer behind the last valid item
-	 *
-	 * @return the pointer behind the last valid item
+	 * Get the pointer behind the last item.
+	 * @return The pointer behind the last item.
 	 */
 	FORCEINLINE T *End()
 	{
@@ -222,10 +174,9 @@
 	}
 
 	/**
-	 * Get the pointer to item "number" (const)
-	 *
-	 * @param index the position of the item
-	 * @return the pointer to the item
+	 * Get the pointer to the item at given position (const).
+	 * @param index The position of the item.
+	 * @return The pointer to the item.
 	 */
 	FORCEINLINE const T *Get(uint index) const
 	{
@@ -235,10 +186,9 @@
 	}
 
 	/**
-	 * Get the pointer to item "number"
-	 *
-	 * @param index the position of the item
-	 * @return the pointer to the item
+	 * Get the pointer to the item at given position.
+	 * @param index The position of the item.
+	 * @return The pointer to the item.
 	 */
 	FORCEINLINE T *Get(uint index)
 	{
@@ -248,10 +198,9 @@
 	}
 
 	/**
-	 * Get item "number" (const)
-	 *
-	 * @param index the positon of the item
-	 * @return the item
+	 * Get the reference to the item at given position (const).
+	 * @param index The position of the item.
+	 * @return The reference to the item.
 	 */
 	FORCEINLINE const T &operator[](uint index) const
 	{
@@ -260,10 +209,9 @@
 	}
 
 	/**
-	 * Get item "number"
-	 *
-	 * @param index the positon of the item
-	 * @return the item
+	 * Get the reference to the item at given position.
+	 * @param index The position of the item.
+	 * @return The reference to the item.
 	 */
 	FORCEINLINE T &operator[](uint index)
 	{
@@ -272,16 +220,220 @@
 	}
 };
 
+/**
+ * Base class of SmallVector implementing buffer capacity growth.
+ * @note This is an internal class, it shouldn't be used outside the header.
+ * @see SmallVector
+ */
+template <typename T, uint S, SmallVectorGrowth Tgrowth>
+class GrowingSmallVector;
+
+template <typename T, uint S>
+class GrowingSmallVector<T, S, SVG_LINEAR> : public SmallVectorBase<T> {
+protected:
+	/**
+	 * Set the capacity aligned to a multiple of S.
+	 * @param capacity The capacity.
+	 */
+	void SetCapacity(uint capacity)
+	{
+		capacity = Align<uint, S>(capacity);
+		this->capacity = capacity;
+		this->data = ReallocT<T>(this->data, capacity);
+	}
+
+public:
+	/**
+	 * Resize the vector.
+	 * @param length New length.
+	 */
+	void Resize(uint length)
+	{
+		this->items = length;
+		if (length > this->capacity) this->SetCapacity(length);
+	}
+};
+
+template <typename T, uint S>
+class GrowingSmallVector<T, S, SVG_EXPONENTIAL> : public SmallVectorBase<T> {
+protected:
+	static const uint FACTOR_PER_256 = (S << 8) / 100; ///< S (growth factor) normalized from 1/100 units to 1/256 units.
+
+	/**
+	 * Set the capacity.
+	 * @param capacity The capacity.
+	 */
+	void SetCapacity(uint capacity)
+	{
+		this->capacity = capacity;
+		this->data = ReallocT<T>(this->data, capacity);
+	}
+
+public:
+	/**
+	 * Resize the vector.
+	 * @param length New length.
+	 */
+	void Resize(uint length)
+	{
+		this->items = length;
+		if (length > this->capacity) {
+			this->SetCapacity(max(length, this->capacity + ((this->capacity * FACTOR_PER_256) >> 8)));
+		}
+	}
+};
+
+/**
+ * Simple vector template class.
+ * Two kinds of capacity growth can be used - linear or exponential.
+ *
+ * @note There are no asserts in the class so you have to care about that you grab an item
+ *       which is inside the vector.
+ *
+ * @tparam T The type of the items stored.
+ * @tparam S For linear growth S is the allocation step. Size of memory block will always
+ *           be aligned to a multiply of S.
+ *           For exponential growth S is the growth factor in 1/100 units i.e. if S is 50
+ *           then size of allocated memory block will grow at least by 50% each time more
+ *           storage space is needed. No alignment is done.
+ * @tparam Tgrowth The type of growth. SVG_LINEAR for linear growth or SVG_EXPONENTIAL for
+ *                 exponential growth.
+ */
+template <typename T, uint S, SmallVectorGrowth Tgrowth = SVG_LINEAR>
+class SmallVector : public GrowingSmallVector<T, S, Tgrowth> {
+public:
+	/** Create an empty SmallVector. */
+	FORCEINLINE SmallVector() { }
+
+	/**
+	 * Create SmallVector reserving storage space for a given number of items.
+	 * @param capacity The number of items to reserve.
+	 */
+	FORCEINLINE SmallVector(uint capacity) { this->SetCapacity(capacity); }
+
+	/** Compact the vector down to the smallest block size boundary. */
+	FORCEINLINE void Compact()
+	{
+		this->SetCapacity(this->items);
+	}
+
+	/** Append an item and return it. */
+FORCEINLINE T *Append(uint to_add = 1)
+{
+	uint begin = this->items;
+	this->items += to_add;
+
+	if (this->items > this->capacity) {
+		this->capacity = Align(this->items, S);
+		this->data = ReallocT(this->data, this->capacity);
+	}
+
+	return &this->data[begin];
+}
+
+	/**
+	 * Test whether an item is present in the vector and append it to the end if not.
+	 * @param item The item to search for.
+	 * @return true if the item is present, false otherwise.
+	 * @note The '!=' operator of T is used for comparison.
+	 */
+	FORCEINLINE bool Include(const T &item)
+	{
+		bool is_member = this->Contains(item);
+		if (!is_member) *this->Append() = item;
+		return is_member;
+	}
+
+	/**
+	 * Reserve storage space to avoid multiple memory reallocation.
+	 * @param capacity Number of all items in the vector to reserve.
+	 */
+	FORCEINLINE void Reserve(uint capacity)
+	{
+		if (capacity > this->capacity) this->SetCapacity(capacity);
+	}
+};
+
+/**
+ * SmallVector extension allowing to insert, remove or move an item preserving items order.
+ *
+ * @note There are no asserts in the class so you have to care about that you grab an item
+ *       which is inside the vector.
+ *
+ * @tparam T The type of the items stored.
+ * @tparam S For linear growth S is the allocation step (must be a power of 2). Size of
+ *           memory block will always be aligned to a multiply of S.
+ *           For exponential growth S is the growth factor in 1/256 units i.e. if S is 128
+ *           then size of allocated memory block will grow at least by 50% each time more
+ *           storage space is needed. No alignment is done.
+ * @tparam Tgrowth The type of growth. SVG_LINEAR for linear growth or SVG_EXPONENTIAL for
+ *                 exponential growth.
+ */
+template <typename T, uint S, SmallVectorGrowth Tgrowth = SVG_LINEAR>
+class OrderedSmallVector : public SmallVector<T, S, Tgrowth> {
+public:
+	/**
+	 * Removes given item from this vector preserving items order.
+	 * Some items are shifted left to fill gap after removed item.
+	 * @param item Item to remove.
+	 */
+	FORCEINLINE void Erase(T *item)
+	{
+		MemMoveT(item, item + 1, this->End() - item - 1);
+		this->items--;
+	}
+
+	/**
+	 * Inserts new item into specified position preserving items order.
+	 * Some items are shifted right to make a space for the new item.
+	 * @param pos Position where to insert new item.
+	 * @return Pointer to inserted item (can be other then pos if reallocation takes place).
+	 */
+	FORCEINLINE T* Insert(T *pos)
+	{
+		if (this->items == this->capacity) {
+			ptrdiff_t pos_offset = pos - this->data;
+			this->Resize(this->capacity + 1);
+			pos = this->data + pos_offset;
+		}
+
+		MemMoveT(pos + 1, pos, this->End() - pos);
+		this->items++;
+		return pos;
+	}
+
+	/**
+	 * Move an item into given position preserving other items order.
+	 * Some items are shifted right or left to make new and fill old space for moved item.
+	 * @param source Item to move.
+	 * @param dest Position where to move item.
+	 */
+	FORCEINLINE void Move(T *source, T *dest)
+	{
+		T item = *source;
+		if (source < dest) {
+			MemMoveT(source, source + 1, dest - source);
+		} else {
+			MemMoveT(dest + 1, dest, source - dest);
+		}
+		*dest = item;
+	}
+};
 
 /**
  * Simple vector template class, with automatic free.
  *
- * @note There are no asserts in the class so you have
- *       to care about that you grab an item which is
- *       inside the list.
+ * @note There are no asserts in the class so you have to care about that you grab an item
+ *       which is inside the vector.
  *
- * @param T The type of the items stored, must be a pointer
- * @param S The steps of allocation
+ * @tparam T The type of the items stored.
+ * @tparam S For linear growth S is the allocation step (must be a power of 2). Size of
+ *           memory block will always be aligned to a multiply of S.
+ *           For exponential growth S is the growth factor in 1/256 units i.e. if S is 128
+ *           then size of allocated memory block will grow at least by 50% each time more
+ *           storage space is needed. No alignment is done.
+ * @tparam Tgrowth The type of growth. SVG_LINEAR for linear growth or SVG_EXPONENTIAL for
+ *                 exponential growth.
  */
 template <typename T, uint S>
 class AutoFreeSmallVector : public SmallVector<T, S> {
@@ -291,9 +443,7 @@
 		this->Clear();
 	}
 
-	/**
-	 * Remove all items from the list.
-	 */
+	/** Remove all items from the vector. */
 	FORCEINLINE void Clear()
 	{
 		for (uint i = 0; i < this->items; i++) {
diff -ibruN src/direction_func.h src/direction_func.h
--- src/direction_func.h	2009-08-22 00:21:05.000000000 +0400
+++ src/direction_func.h	2010-06-20 15:22:46.000000000 +0400
@@ -12,6 +12,7 @@
 #ifndef DIRECTION_FUNC_H
 #define DIRECTION_FUNC_H
 
+#include "core/bitmath_func.hpp"
 #include "direction_type.h"
 
 /**
@@ -202,7 +203,93 @@
 }
 
 /**
- * Checks if an interger value is a valid DiagDirection
+ * Combine two direction transformations into one.
+ * Performing returned transformation is the same as performing both a and b transformations in any order.
+ * @param a First transformation to combine.
+ * @param b Second transformation to combine.
+ * @return Combination of a and b transformations.
+ */
+static inline DirTransform CombineDirTransform(DirTransform a, DirTransform b)
+{
+	/* Read doc comment about DirTransform enum first!
+	 *
+	 * DirTransform transformation can be expressed as an equation:
+	 * y = I * x + R
+	 * where
+	 *   x - direction before transformation
+	 *   y - direction after transformation
+	 *   R - rotation, number formed by first 2 bits of DirTransform (bits of mask DT_ROTATION_MASK)
+	 *   I - reflection, +1 if reflection bit of mask DT_REFLECTION_BIT is cleared, -1 otherwise
+	 *
+	 * From above we can construct transformation function of an angle.
+	 * For simple rotation it is:
+	 *    f(x) = x + R
+	 * and for reflection:
+	 *    f(x) = -x + R
+	 *
+	 * Direction transformation expressed as an angle function can be calculated using modular arithmetic.
+	 * Modulus is 4, we measure rotations in 90 degree pieces, full circle has 360 degree that is 4 our
+	 * units. Thus every operation on angles can be bitmasked with DT_ROTATION_MASK to receive
+	 * proper value in range [0..3]. We can treat these first two rotation bits as overflowing integer
+	 * of size of 2 bits. Integer variables used to calculate rotation can safely overflow as our modulus
+	 * is a power of 2 like in every integer type.
+	 *
+	 * To combine two transformations we can compose their functions. Let:
+	 * a(x) - function of transformation a
+	 * b(x) - function of transformation b
+	 * RA - rotation of transformation a
+	 * RB - rotation of transformation b
+	 * RR - rotation of result transformation
+	 * IA - reflection bit of transformation a
+	 * IB - reflection bit of transformation b
+	 * IR - reflection bit of result transformation
+	 *
+	 * Consider 4 cases of reflection (each variation of IA and IB):
+	 * IA |IB ||  a(x)   |  b(x)   |    a and b functions composition    |IR |   RR
+	 * ---+---++---------+---------+-------------------------------------+---+--------
+	 *  0 | 0 ||  x + RA |  x + RB | b(a(x)) =  a(x) + RB =  x + RA + RB | 0 | RB + RA
+	 *  1 | 0 || -x + RA |  x + RB | b(a(x)) =  a(x) + RB = -x + RA + RB | 1 | RB + RA
+	 *  0 | 1 ||  x + RA | -x + RB | b(a(x)) = -a(x) + RB = -x - RA + RB | 1 | RB - RA
+	 *  1 | 1 || -x + RA | -x + RB | b(a(x)) = -a(x) + RB =  x - RA + RB | 0 | RB - RA
+	 *
+	 * From above table we can see how to calculate combination of two transformations:
+	 *   IR = IA ^ IB
+	 *   RR = IB ? (RB - RA) : (RB + RA)
+	 */
+	return (DirTransform)(((a ^ b) & DT_REFLECTION_BIT) | // calculate reflection bit
+		((((b & DT_REFLECTION_BIT) != 0) ? (b - a) : (b + a)) & DT_ROTATION_MASK)); // calculate rotation bits
+}
+
+/**
+ * Invert given DirTransform.
+ * @param dt Tranformation to invert.
+ * @return Inverted dt transformation, applied reverts changes made by dt transformation.
+ */
+static inline DirTransform InvertDirTransform(DirTransform dt)
+{
+	/* Let f(x) be a transformation function (see CombineDirTransform for more information).
+	 * To invert transformation we must find a function, lets name it g, which is the
+	 * inversion of function f. Function combined with it's inversion gives the identity:
+	 *   g(f(x)) = x   */
+
+	/* To invert a reflection against some axis:
+	 *   f(x) = -x + R
+	 * we must repeat this reflection and will get the identity:
+	 *   f(f(x)) = -f(x) + R = x - R + R = x
+	 * Reflection transformation is an involution - inversion of itself. */
+	if ((dt & DT_REFLECTION_BIT) != 0) return dt;
+
+	/* To invert simple rotation:
+	 *   f(x) = x + R
+	 * we must rotate by the same angle but in the opposite direction:
+	 *   g(x) = x - R
+	 * and we will get the identity as expected
+	 *   g(f(x)) = g(x + R) = x + R - R = x   */
+	return (DirTransform)((-dt) & DT_ROTATION_MASK);
+}
+
+/**
+ * Checks if an integer value is a valid DiagDirection
  *
  * @param d The value to check
  * @return True if the value belongs to a DiagDirection, else false
@@ -234,4 +321,49 @@
 	return d < AXIS_END;
 }
 
+/**
+ * Checks if an integer value is a valid DirTransform.
+ *
+ * @param dt The value to check.
+ * @return True if the value belongs to a DirTransform, false otherwise.
+ */
+static inline bool IsValidDirTransform(DirTransform dt)
+{
+	return dt < DT_END;
+}
+
+/**
+ * Transform Axis by given transformation.
+ * @param axis Axis to transform.
+ * @param dt Transformation to use.
+ * @return Transformed Axis.
+ */
+static inline Axis TransformAxis(Axis axis, DirTransform dt)
+{
+	return (Axis)(axis ^ (dt & 1));
+}
+
+/**
+ * Transform Direction by given transformation.
+ * @param direction Direction to transform.
+ * @param dt Transformation to use.
+ * @return Transformed Direction.
+ */
+static inline Direction TransformDir(Direction direction, DirTransform dt)
+{
+	dt = (DirTransform)(dt << 1);
+	return (Direction)((((dt & (DT_REFLECTION_BIT << 1)) == 0) ? dt + direction : dt - direction + 2) & 7);
+}
+
+/**
+ * Transform DiagDirection by given transformation.
+ * @param diag_dir DiagDirection to transform.
+ * @param dt Transformation to use.
+ * @return Transformed DiagDirection.
+ */
+static inline DiagDirection TransformDiagDir(DiagDirection diag_dir, DirTransform dt)
+{
+	return (DiagDirection)((((dt & DT_REFLECTION_BIT) == 0) ? dt + diag_dir : dt - diag_dir) & DT_ROTATION_MASK);
+}
+
 #endif /* DIRECTION_H */
diff -ibruN src/direction_type.h src/direction_type.h
--- src/direction_type.h	2010-04-18 02:27:49.000000000 +0400
+++ src/direction_type.h	2010-06-20 15:22:46.000000000 +0400
@@ -132,4 +132,30 @@
 };
 template <> struct EnumPropsT<Axis> : MakeEnumPropsT<Axis, byte, AXIS_X, AXIS_END, INVALID_AXIS, 1> {};
 
+/**
+ * Enum representing simple transformations to rotate/reflect NSWE directions.
+ *
+ * DT_REFLECTION_BIT bit of DirTransform indicates if reflect object in respect to
+ * Northeast-Southwest axis before rotating it. The number formed by DirTransform bits of mask
+ * DT_ROTATION_MASK tells how much to rotate object clockwise in 90 degree units.
+ */
+enum DirTransform {
+	DT_BEGIN           = 0, ///< Used for iterations.
+
+	DT_IDENTITY        = 0, ///< Identity transformation (no tranformation at all).
+	DT_ROTATE_90_RIGHT = 1, ///< Rotate by 90 degree clockwise.
+	DT_ROTATE_180      = 2, ///< Rotate by 180 degree.
+	DT_ROTATE_90_LEFT  = 3, ///< Rotate by 90 degree counterclockwise.
+
+	DT_REFLECT_NE_SW   = 4, ///< Reflect in respect to Northeast-Southwest axis.
+	DT_REFLECT_W_E     = 5, ///< Reflect in respect to West-East axis.
+	DT_REFLECT_NW_SE   = 6, ///< Reflect in respect to Northwest-Southeast axis.
+	DT_REFLECT_N_S     = 7, ///< Reflect in respect to North-South axis.
+
+	DT_END             = 8, ///< Used for iterations.
+
+	DT_ROTATION_MASK  = 3, ///< Bitmask with rotation bits.
+	DT_REFLECTION_BIT = 4, ///< Bitmask with bit distinguishing reflection from simple rotation.
+};
+
 #endif /* DIRECTION_TYPE_H */
diff -ibruN src/gfxinit.cpp src/gfxinit.cpp
--- src/gfxinit.cpp	2010-05-01 01:01:21.000000000 +0400
+++ src/gfxinit.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -172,6 +172,9 @@
 	/* Initialize the unicode to sprite mapping table */
 	InitializeUnicodeGlyphMap();
 
+	/* Load CopyPaste graphics */
+	LoadGrfFile("copypaste.grf", SPR_COPYPASTE_BASE, i++);
+
 	/*
 	 * Load the base NewGRF with OTTD required graphics as first NewGRF.
 	 * However, we do not want it to show up in the list of used NewGRFs,
diff -ibruN src/lang/english.txt src/lang/english.txt
--- src/lang/english.txt	2010-06-20 15:52:41.000000000 +0400
+++ src/lang/english.txt	2010-06-20 15:22:46.000000000 +0400
@@ -1951,6 +1951,28 @@
 STR_BRIDGE_NAME_TUBULAR_STEEL                                   :Tubular, Steel
 STR_BRIDGE_TUBULAR_SILICON                                      :Tubular, Silicon
 
+STR_COPY_PASTE_TOOLBAR                                          :{WHITE}Copy
+STR_COPY_PASTE_TOOLTIP                                          :{BLACK}Copy & Paste
+STR_COPY_PASTE_COPY_TOOLTIP                                     :{BLACK}Copies the selected area
+STR_COPY_PASTE_PASTE_TOOLTIP                                    :{BLACK}Pastes the copied area
+STR_COPY_PASTE_ROTATE_LEFT_TOOLTIP                              :{BLACK}Rotate 90 Degree CCW
+STR_COPY_PASTE_ROTATE_RIGHT_TOOLTIP                             :{BLACK}Rotate 90 Degree CW
+STR_COPY_PASTE_VACANT_TERRAIN_TOOLTIP                           :{BLACK}If vacant Terrain should be pasted
+STR_COPY_PASTE_LOAD_TOOLTIP                                     :{BLACK}Load a previously saved template
+STR_COPY_PASTE_SAVE_TOOLTIP                                     :{BLACK}Save the current selection to a template
+STR_COPY_PASTE_MIRROR_HORIZONTAL_TOOLTIP                        :{BLACK}Mirror the current selection at the horizontal axis
+STR_COPY_PASTE_MIRROR_VERTICAL_TOOLTIP                          :{BLACK}Mirror the current selection at the vertical axis
+STR_COPY_PASTE_BULLDOZE_BEFORE_BUILD_TOOLTIP                    :{BLACK}Bulldoze non-vacant terrain before pasting
+STR_COPY_PASTE_TOGGLE_SIGNAL_DIRECTION_TOOLTIP                  :{BLACK}Toggle the signal direction when pasting
+STR_COPY_PASTE_CONVERT_RAIL_TOOLTIP                             :{BLACK}Converts used Rail to current railtype when pasting
+STR_COPY_PASTE_WITHOUT_RAIL_TOOLTIP                             :{BLACK}If enabled, Rail will be copied
+STR_COPY_PASTE_WITHOUT_ROAD_TOOLTIP                             :{BLACK}If enabled, Road will be copied
+STR_COPY_PASTE_ONLY_OWN_TOOLTIP                                 :{BLACK}If disabled, only your own items will be copied
+STR_COPY_PASTE_LOAD_TEMPLATE                                    :{WHITE}Load Template
+STR_COPY_PASTE_SAVE_TEMPLATE                                    :{WHITE}Save Template
+
+STR_COPY_PASTE_PASTE_DISABLED                                   :{WHITE}Paste not allowed on this server...
+STR_CONFIG_PATCHES_CP_PASTE_SPEED                               :{LTBLUE}Pasting speed in multiplayer. (255 = off): {ORANGE}{STRING1}
 
 # Road construction toolbar
 STR_ROAD_TOOLBAR_ROAD_CONSTRUCTION_CAPTION                      :{WHITE}Road Construction
diff -ibruN src/misc/compact_array.hpp src/misc/compact_array.hpp
--- src/misc/compact_array.hpp	1970-01-01 03:00:00.000000000 +0300
+++ src/misc/compact_array.hpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,602 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file compact_array.hpp One- and two-dimensional, generic, resizable array classes with all items placed in tight memory block. */
+
+#include "../core/alloc_func.hpp"
+#include <new>
+
+/** Base class for CompactArray and Compact2DArray. */
+template <typename T>
+class CompactArrayBase {
+protected:
+	T *data; ///< Storage buffer.
+	uint length; ///< Arrays buffer size (in items), number of all items.
+
+	/* Create zero-length array without any memory allocated. */
+	CompactArrayBase() : data(NULL), length(0) { }
+
+	/**
+	 * Create array with given length of memory block (in items). Default constructor is called on each new item.
+	 * @param length Number of items.
+	 */
+	CompactArrayBase(uint length)
+		: data(MallocT<T>(length)), length(length)
+	{
+		this->ConstructAll();
+	}
+
+	/**
+	 * Create copy of an array. Copy constructor is called on each item.
+	 * @param array Array to copy.
+	 */
+	CompactArrayBase(const CompactArrayBase<T> &array)
+		: data(MallocT<T>(array.length)), length(array.length)
+	{
+		this->ConstructCopyAll(array.data);
+	}
+
+	/** Call default constructor on each item. */
+	void ConstructAll()
+	{
+		T *end = this->data + this->length;
+		for (T *addr = this->data; addr != end; addr++) new(addr) T;
+	}
+
+	/**
+	 * Call copy constructor on each item.
+	 * @param source Array of items to copy.
+	 */
+	void ConstructCopyAll(T *source)
+	{
+		T *end = this->data + this->length;
+		for (T *addr = this->data; addr != end; addr++) new(addr) T(*source++);
+	}
+
+	/** Call destructor on each item. */
+	void DestroyAll()
+	{
+		T *end = this->data + this->length;
+		for (T *addr = this->data; addr != end; addr++) addr->~T();
+	}
+
+	/**
+	 * Swap array contents with another array.
+	 * @param second Array with which the contents will be swapped.
+	 */
+	void Swap(CompactArrayBase<T> *second)
+	{
+		::Swap(this->data, second->data);
+		::Swap(this->length, second->length);
+	}
+
+	/**
+	 * Change the length to given reallocating memory and calling appropriate constructors/destructors
+	 * @param length New length.
+	 */
+	void SetLength(uint length)
+	{
+		if (this->length == length) return;
+		while (this->length > length) this->data[--this->length].~T();
+		this->data = ReallocT<T>(this->data, length);
+		while (this->length < length) new(this->data + this->length++) T;
+	}
+
+	/** Assign other array. Whole data is copied, no memory sharing/reference counting. */
+	CompactArrayBase<T> &operator = (const CompactArrayBase<T> &array)
+	{
+		if (this == &array) return *this; // do nothing if we are assigning the same array to itself
+
+		this->DestroyAll();
+
+		/* reallocate memory if needed */
+		if (this->length != array.length) {
+			this->length = array.length;
+			this->data = (T*)realloc(this->data, sizeof(T) * this->length);
+		}
+
+		this->ConstructCopyAll(array.data);
+
+		return *this;
+	}
+
+public:
+	~CompactArrayBase()
+	{
+		this->DestroyAll();
+		free(this->data);
+	}
+
+	/**
+	 * Get the pointer to the array memory block. Block size is fitted to number of array items.
+	 * It contains all items one by one, ordered by index. In two dimensional arrays items are
+	 * arranged row by row.
+	 * @return Pointer to the buffer of this array.
+	 */
+	FORCEINLINE const T *Data() const { return this->data; }
+
+	/**
+	 * Get the pointer to the array memory block. Block size is fitted to number of array items.
+	 * It contains all items one by one, ordered by index. In two dimensional arrays items are
+	 * arranged row by row.
+	 * @return Pointer to the buffer of this array.
+	 */
+	FORCEINLINE T *Data() { return this->data; }
+
+	/**
+	 * Return number of all items.
+	 * @return Array length.
+	 */
+	FORCEINLINE uint Length() const { return this->length; }
+};
+
+/**
+ * One-dimensional array with all items placed in tight memory block.
+ * Array may be resized, but it entails memory reallocation.
+ * Constructors/destructors are called automatically on items.
+ */
+template <typename T>
+class CompactArray : public CompactArrayBase<T> {
+public:
+	/** Create zero-length array. */
+	CompactArray() { }
+
+	/**
+	 * Create array with given number of items.
+	 * @param length Number of items.
+	 */
+	CompactArray(uint length) : CompactArrayBase<T>(length) { }
+
+	/**
+	 * Create arrays copy.
+	 * @param array Array to copy.
+	 */
+	CompactArray(const CompactArray<T> &array) : CompactArrayBase<T>(array) { }
+
+	void Resize(uint length) { this->SetLength(length); }
+
+	CompactArray &operator = (const CompactArray &array) { static_cast<CompactArrayBase<T>&>(*this) = array; }
+
+	/**
+	 * Allows to access an item at specified position using subscription operator.
+	 * @param index Index of item.
+	 * @return Reference to an item at specified position.
+	 */
+	template <typename Tindex>
+	FORCEINLINE T &operator [] (Tindex index)
+	{
+		return this->data[index];
+	}
+
+	/**
+	 * Allows to access an item at specified position using subscription operator.
+	 * @param index Index of item.
+	 * @return Constant reference to an item at specified position.
+	 */
+	template <typename Tindex>
+	FORCEINLINE const T &operator [] (Tindex index) const
+	{
+		return this->data[index];
+	}
+};
+
+struct Compact2DOffset
+{
+public:
+	int m_val;
+
+	FORCEINLINE Compact2DOffset() { }
+	FORCEINLINE explicit Compact2DOffset(int val) : m_val(val) { }
+	FORCEINLINE operator int& () { return this->m_val; }
+	FORCEINLINE operator const int& () const { return this->m_val; }
+};
+
+template <typename T>
+class Compact2DArray;
+
+template <typename T, typename Tno_const = T>
+struct Compact2DIter {
+	friend class Compact2DArray<Tno_const>;
+
+public:
+	typedef Compact2DIter<T, Tno_const> Iter;
+
+	struct RowColBase {
+		FORCEINLINE Iter *Owner()
+		{
+			return reinterpret_cast<Iter*>((ptrdiff_t)this - cpp_offsetof(Iter, x));
+		}
+	};
+
+	struct Col : public RowColBase {
+		FORCEINLINE Col &operator += (int delta_x) { this->Owner()->item += delta_x; return *this; }
+		FORCEINLINE Col &operator -= (int delta_x) { this->Owner()->item -= delta_x; return *this; }
+		FORCEINLINE void operator ++ (int) { this->Owner()->item++; }
+		FORCEINLINE void operator -- (int) { this->Owner()->item--; }
+		FORCEINLINE Col &operator ++ () { (*this)++; return *this; }
+		FORCEINLINE Col &operator -- () { (*this)--; return *this; }
+	};
+
+	struct Row : public RowColBase {
+		FORCEINLINE Row &operator += (int delta_y) { this->Owner()->item += delta_y * this->Owner()->array_width; return *this; }
+		FORCEINLINE Row &operator -= (int delta_y) { this->Owner()->item += delta_y * this->Owner()->array_width; return *this; }
+		FORCEINLINE void operator ++ (int) { this->Owner()->item += this->Owner()->array_width; }
+		FORCEINLINE void operator -- (int) { this->Owner()->item -= this->Owner()->array_width; }
+		FORCEINLINE Row &operator ++ () { (*this)++; return *this; }
+		FORCEINLINE Row &operator -- () { (*this)--; return *this; }
+	};
+
+	struct RowCol : public RowColBase {
+		template <typename Tindex>
+		FORCEINLINE RowCol &operator += (const PointT<Tindex> &delta)
+		{
+			return this->Move(delta.x, delta.y);
+		}
+
+		template <typename Tindex>
+		FORCEINLINE RowCol &operator -= (const PointT<Tindex> &delta)
+		{
+			this->Owner()->item -= this->Owner()->array_width * delta.y + delta.x;
+			return *this;
+		}
+	};
+
+	union {
+		T *item;
+		Col x;
+		Row y;
+		RowCol xy;
+	};
+
+private:
+	uint array_width;
+
+	FORCEINLINE Compact2DIter(T *item, const Compact2DArray<Tno_const> *array)
+	{
+		this->item = item;
+		this->array_width = array->Width();
+	}
+
+	FORCEINLINE Compact2DIter(T *item, uint array_width)
+	{
+		this->item = item;
+		this->array_width = array_width;
+	}
+
+public:
+	FORCEINLINE Compact2DIter() { }
+
+	template <typename Tother>
+	FORCEINLINE Compact2DIter(const Compact2DIter<Tother, Tno_const> &iter)
+	{
+		this->item = iter.item;
+		this->array_width = iter.array_width;
+	}
+
+	template <typename Tother>
+	FORCEINLINE Compact2DIter(const Compact2DIter<Tother, Tno_const> &iter, int delta_x, int delta_y)
+	{
+		this->item = iter.item;
+		this->array_width = iter.array_width;
+		this->Move(delta_x, delta_y);
+	}
+
+	FORCEINLINE T *Relative(int delta_x, int delta_y) { return this->item + this->array_width * delta_y + delta_x; }
+
+	template <typename Tindex>
+	FORCEINLINE T *Relative(const PointT<Tindex> &delta) { return this->Relative(delta.x, delta.y); }
+
+	FORCEINLINE Iter &Move(int delta_x, int delta_y)
+	{
+		this->item = this->Relative(delta_x, delta_y);
+		return *this;
+	}
+
+	template <typename Tindex>
+	FORCEINLINE Iter &Move(const PointT<Tindex> &delta) { return this->Move(delta.x, delta.y); }
+
+	FORCEINLINE T *operator -> () const { return this->item; }
+	FORCEINLINE T &operator * () const { return *this->item; }
+};
+
+
+#define DEFINE_COMPACT_2D_ITER_CMP_OPERATOR(o) \
+template <typename Tleft, typename Tright, typename Tno_const> \
+FORCEINLINE static bool operator o (const Compact2DIter<Tleft, Tno_const> &left, const Compact2DIter<Tright, Tno_const> &right) \
+{ \
+	return left.item o right.item; \
+} \
+template <typename T, typename Tno_const> \
+FORCEINLINE static bool operator o (const Tno_const *left, const Compact2DIter<T, Tno_const> &right) \
+{ \
+	return left o right.item; \
+} \
+template <typename T, typename Tno_const> \
+FORCEINLINE static bool operator o (const Compact2DIter<T, Tno_const> &left, const Tno_const *right) \
+{ \
+	return left.item o right; \
+}
+
+DEFINE_COMPACT_2D_ITER_CMP_OPERATOR(==);
+DEFINE_COMPACT_2D_ITER_CMP_OPERATOR(!=);
+DEFINE_COMPACT_2D_ITER_CMP_OPERATOR(<);
+DEFINE_COMPACT_2D_ITER_CMP_OPERATOR(>);
+DEFINE_COMPACT_2D_ITER_CMP_OPERATOR(<=);
+DEFINE_COMPACT_2D_ITER_CMP_OPERATOR(>=);
+
+#undef DEFINE_COMPACT_2D_ITER_CMP_OPERATOR
+
+
+template <typename T>
+class Compact2DArray : public CompactArrayBase<T> {
+protected:
+	Dimension size; ///< Arrays size
+
+public:
+	typedef Compact2DIter<T>          Iter;
+	typedef Compact2DIter<const T, T> IterC;
+
+	Compact2DArray() { size.width = size.height = 0; }
+
+	Compact2DArray(uint width, uint height)
+		: CompactArrayBase<T>(width * height)
+		, size(Dimension::Create(width, height))
+	{
+	}
+
+	Compact2DArray(Dimension size)
+		: CompactArrayBase<T>(size.width * size.height)
+		, size(size)
+	{
+	}
+
+	Compact2DArray(const Compact2DArray &array)
+		: CompactArrayBase<T>(array)
+		, size(array.width, array.height)
+	{
+	}
+
+	/**
+	 * Get the width.
+	 * @return Array width.
+	 */
+	FORCEINLINE uint Width() const { return this->size.width; }
+
+	/**
+	 * Get the height.
+	 * @return Array height.
+	 */
+	FORCEINLINE uint Height() const { return this->size.height; }
+
+	/**
+	 * Get the size.
+	 * @return Array size.
+	 */
+	FORCEINLINE const Dimension &Size() const { return this->size; }
+
+	/**
+	 * Resize array.
+	 * The buffer is only reallocked thus cell offsets are preserved, x/y indices are not.
+	 * @param width New width.
+	 * @param height New height.
+	 */
+	void Resize(uint width, uint height)
+	{
+		this->SetLength(width * height);
+		this->size.width = width;
+		this->size.height = height;
+	}
+
+	/**
+	 * Resize array.
+	 * The buffer is only reallocked thus cell offsets are preserved, x/y indices are not.
+	 * @param size New size.
+	 */
+	void Resize(Dimension size)
+	{
+		this->SetLength(size.width * size.height);
+		this->size = size;
+	}
+
+	/**
+	 * Swap array contents with another array.
+	 * @param second Array with which the contents will be swapped.
+	 */
+	void Swap(Compact2DArray<T> *second)
+	{
+		CompactArrayBase<T>::Swap(second);
+		::Swap(this->size, second->size);
+	}
+
+	FORCEINLINE Compact2DOffset IndexToOffset(int x, int y) const { return Compact2DOffset(y * this->Width() + x); }
+
+	template <typename Tindex>
+	FORCEINLINE Compact2DOffset IndexToOffset(const PointT<Tindex> &index) const { return this->IndexToOffset(index.x, index.y); }
+
+	template <typename Tindex>
+	FORCEINLINE PointT<Tindex> OffsetToIndex(Compact2DOffset offset) const
+	{
+		return PointT<Tindex>::Create(offset % this->size.width, offset / this->size.width);
+	}
+
+	FORCEINLINE Point OffsetToIndex(Compact2DOffset offset) const { return this->OffsetToIndex<int>(offset); }
+
+	//template <typename Tdst>
+	//void AssignCell(Tdst *dst_cell, const T *src_cell) { *dst_cell = *src_cell; }
+
+	//template <typename Tdst>
+	//void CopyTo(Compact2DArray<T> *dst_array, Compact2DOffset dst, Compact2DOffset src, uint width, uint height,
+	//            void (*cell_copy_proc)(Tdst *dst_cell, const T *src_cell) = Compact2DArray<T>::AssignCell<Tdst>) const
+	//{
+	//	assert(dst->Width() <= dst->OffsetToIndex(dst_pos).x + width);
+	//	assert(dst->Height() <= dst->OffsetToIndex(dst_pos).y + height);
+	//	assert(this->Width() <= this->OffsetToIndex(src_pos).x + width);
+	//	assert(this->Height() <= this->OffsetToIndex(src_pos).y + height);
+
+	//	Compact2DOffset src_end = Compact2DOffset(src + this->IndexToOffset(width, height));
+	//	while (src < src_end) {
+	//		for (Compact2DOffset dst_row_end = dst + width; dst < dst_row_end; dst++, src++) {
+	//			cell_copy_proc(&((*dst_array)[dst++]), &((*this)[src++]));
+	//		}
+	//		dst += dst_array->size.width - width;
+	//		src += this->size.width - width;
+	//	}
+	//}
+
+	Compact2DArray<T> &operator = (const Compact2DArray &array)
+	{
+		(CompactArray<T>&)(*this) = array;
+		this->size = array.size;
+		return *this;
+	}
+
+	/**
+	 * Allows to access an item at specified absolute offset.
+	 * @param offset Offset of an item.
+	 * @return Pointer to item at specified offset.
+	 */
+	FORCEINLINE T *At(Compact2DOffset offset) { return &this->data[offset]; }
+
+	/**
+	 * Allows to access an item at specified absolute offset (const).
+	 * @param offset Offset of an item.
+	 * @return Pointer to item at specified offset.
+	 */
+	FORCEINLINE const T *At(Compact2DOffset offset) const { return &this->data[offset]; }
+
+	/**
+	 * Allows to access an item at specified y (row) and x (column) coordinates.
+	 * @param y The y coordinate.
+	 * @param x The x coordinate.
+	 * @return Pointer to item at specified index.
+	 */
+	FORCEINLINE T *At(uint x, uint y) { return this->At(this->IndexToOffset(x, y)); }
+
+	/**
+	 * Allows to access an item at specified y (row) and x (column) coordinates (const).
+	 * @param y The y coordinate.
+	 * @param x The x coordinate.
+	 * @return Pointer to item at specified index.
+	 */
+	FORCEINLINE const T *At(uint x, uint y) const { return this->At(this->IndexToOffset(x, y)); }
+
+
+	/**
+	 * Allows to access an item at position specified by PointT structure.
+	 * @param index Item index expressad as a PointT (x - column, y - row).
+	 * @return Pointer to item at specified index.
+	 */
+	template <typename Tindex>
+	FORCEINLINE T *At(const PointT<Tindex> &index) { return this->At(this->IndexToOffset(index)); }
+
+	/**
+	 * Allows to access an item at position specified by PointT structure (const).
+	 * @param index Item index expressad as a PointT (x - column, y - row).
+	 * @return Pointer to item at specified index.
+	 */
+	template <typename Tindex>
+	FORCEINLINE const T *At(const PointT<Tindex> &index) const { return this->At(this->IndexToOffset(index)); }
+
+	FORCEINLINE T   *First() { return this->data;                                }
+	FORCEINLINE T     *End() { return this->data + this->length;                 }
+	FORCEINLINE T    *Last() { return this->data + this->length - 1;             }
+	FORCEINLINE T  *EndRow() { return this->data + this->length;                 }
+	FORCEINLINE T *LastRow() { return this->data + this->length - this->Width(); }
+	FORCEINLINE T  *EndCol() { return this->data + this->Width();                }
+	FORCEINLINE T *LastCol() { return this->data + this->Width() - 1;            }
+
+	FORCEINLINE const T   *First() const { return this->data;                                }
+	FORCEINLINE const T     *End() const { return this->data + this->length;                 }
+	FORCEINLINE const T    *Last() const { return this->data + this->length - 1;             }
+	FORCEINLINE const T  *EndRow() const { return this->data + this->length;                 }
+	FORCEINLINE const T *LastRow() const { return this->data + this->length - this->Width(); }
+	FORCEINLINE const T  *EndCol() const { return this->data + this->Width();                }
+	FORCEINLINE const T *LastCol() const { return this->data + this->Width() - 1;            }
+
+	FORCEINLINE Iter IterAt(uint x, uint y) { return Iter(this->At(x, y), this); }
+	FORCEINLINE IterC IterAtC(uint x, uint y) const { return IterC(this->At(x, y), this); }
+	
+	template <typename Tindex>
+	FORCEINLINE Iter IterAt(const PointT<Tindex> &index) { return Iter(this->At(index), this); }
+
+	template <typename Tindex>
+	FORCEINLINE IterC IterAtC(const PointT<Tindex> &index) const { return IterC(this->At(index), this); }
+
+	FORCEINLINE Iter   FirstIter() { return Iter(this->First(),   this); }
+	FORCEINLINE Iter    LastIter() { return Iter(this->Last(),    this); }
+	FORCEINLINE Iter     EndIter() { return Iter(this->End(),     this); }
+	FORCEINLINE Iter  EndRowIter() { return Iter(this->EndRow(),  this); }
+	FORCEINLINE Iter LastRowIter() { return Iter(this->LastRow(), this); }
+	FORCEINLINE Iter  EndColIter() { return Iter(this->EndCol(),  this); }
+	FORCEINLINE Iter LastColIter() { return Iter(this->LastCol(), this); }
+
+	FORCEINLINE IterC   FirstIterC() const { return IterC(this->First(),   this); }
+	FORCEINLINE IterC    LastIterC() const { return IterC(this->Last(),    this); }
+	FORCEINLINE IterC     EndIterC() const { return IterC(this->End(),     this); }
+	FORCEINLINE IterC  EndRowIterC() const { return IterC(this->EndRow(),  this); }
+	FORCEINLINE IterC LastRowIterC() const { return IterC(this->LastRow(), this); }
+	FORCEINLINE IterC  EndColIterC() const { return IterC(this->EndCol(),  this); }
+	FORCEINLINE IterC LastColIterC() const { return IterC(this->LastCol(), this); }
+
+	/**
+	 * Allows to access an item at specified absolute offset.
+	 * @param offset Offset of an item.
+	 * @return Reference to item at specified offset.
+	 */
+	FORCEINLINE T &operator [] (Compact2DOffset offset) { return *this->At(offset); }
+
+	/**
+	 * Allows to access an item at specified absolute offset (const).
+	 * @param offset Offset of an item.
+	 * @return Reference to item at specified offset.
+	 */
+	FORCEINLINE const T &operator [] (Compact2DOffset offset) const { return *this->At(offset); }
+
+	/**
+	 * Allows to access an item at specified row and column using double subscription operator.
+	 *
+	 * @param y Row index.
+	 * @return Pointer to the first item of specified row index.
+	 *
+	 * @warning Order of coordinates is reverted in opposition to other methods like At,
+	 *          IndexToOffset etc. The y coordinatete goes first, then goes the x:
+	 * @code
+	 *    array[y][x]; // Access array cell at position (x, y).
+	 * @endcode
+	 */
+	FORCEINLINE T *operator [] (uint y) { return this->At(0, y); }
+
+	/**
+	 * Allows to access an item at specified row and column using double subscription operator (const).
+	 *
+	 * @param y Row index.
+	 * @return Pointer to the first item of specified row index.
+	 *
+	 * @warning Order of coordinates is reverted in opposition to other methods like At,
+	 *          IndexToOffset etc. The y coordinatete goes first, then goes the x:
+	 * @code
+	 *    array[y][x]; // Access array cell at position (x, y).
+	 * @endcode
+	 */
+	FORCEINLINE const T *operator [] (uint y) const { return this->At(0, y); }
+
+	/**
+	 * Allows to access an item at position specified by PointT structure.
+	 * @param index Item index expressad as a PointT (x - column, y - row).
+	 * @return Reference to item at specified index.
+	 */
+	template <typename Tindex>
+	FORCEINLINE T &operator [] (const PointT<Tindex> &index) { return *this->At(index); }
+
+	/**
+	 * Allows to access an item at position specified by PointT structure (const).
+	 * @param index Item index expressad as a PointT (x - column, y - row).
+	 * @return Reference to item at specified index.
+	 */
+	template <typename Tindex>
+	FORCEINLINE const T &operator [] (const PointT<Tindex> &index) const { return *this->At(index); }
+};
diff -ibruN src/road_func.h src/road_func.h
--- src/road_func.h	2010-04-03 23:57:23.000000000 +0400
+++ src/road_func.h	2010-06-20 15:22:46.000000000 +0400
@@ -19,6 +19,17 @@
 #include "tile_type.h"
 
 /**
+ * Iterate through each set RoadType in a RoadTypes value.
+ * For more informations see FOR_EACH_SET_BIT_EX.
+ *
+ * @param var Loop index variable that stores fallowing set road type. Must be of type RoadType.
+ * @param road_types The value to iterate through (any expression).
+ *
+ * @see FOR_EACH_SET_BIT_EX
+ */
+#define FOR_EACH_SET_ROADTYPE(var, road_types) FOR_EACH_SET_BIT_EX(RoadType, var, RoadTypes, road_types)
+
+/**
  * Whether the given roadtype is valid.
  * @param rt the roadtype to check for validness
  * @return true if and only if valid
@@ -110,6 +121,82 @@
 }
 
 /**
+ * Convert given road bits of given road type to a road bits pack.
+ * @param road_bits The road bits to convert.
+ * @param road_type Type of the road bits.
+ * @return Road bits converted to road bits pack.
+ */
+static inline RoadBitsPack RoadBitsToRoadBitsPack(RoadBits road_bits, RoadType road_type)
+{
+	return (RoadBitsPack)MAKE_ROAD_BITS_PACK_OF_TYPE(road_bits, road_type);
+}
+
+/**
+ * Convert given road bits of given road types to a road bits pack.
+ * @param road_bits The road bits to convert.
+ * @param road_type Type of the road bits.
+ * @return Road bits converted to road bits pack.
+ */
+static inline RoadBitsPack RoadBitsToRoadBitsPack(RoadBits road_bits, RoadTypes road_types)
+{
+	uint ret = RBP_NONE;
+	for (uint bits = road_bits; road_types != 0; bits <<= ROADBITS_NUM_BITS) {
+		if (road_types & 1) ret |= bits;
+		road_types = (RoadTypes)(road_types >> 1);
+	}
+	return (RoadBitsPack)ret;
+}
+
+/**
+ * Extract a road bits of given road type from road bits pack.
+ * @param road_bits_pack The road bits pack.
+ * @param road_type Type of the road.
+ * @return Extracted bits.
+ */
+static inline RoadBits ExtractRoadBits(RoadBitsPack road_bits_pack, RoadType road_type)
+{
+	return (RoadBits)(ROAD_ALL & (road_bits_pack >> (ROADBITS_NUM_BITS * road_type)));
+}
+
+/**
+ * Add road bits of given road type into road bits pack.
+ * @param road_bits_pack The road bits pack where to add new road bits.
+ * @param road_bits The road bits to add.
+ * @param road_type Type of road.
+ * @return Road bits pack with added road bits.
+ */
+static inline RoadBitsPack AddBitsToRoadBitsPack(RoadBitsPack road_bits_pack, RoadBits road_bits, RoadType road_type)
+{
+	return (RoadBitsPack)(road_bits_pack | MAKE_ROAD_BITS_PACK_OF_TYPE(road_bits, road_type));
+}
+
+/**
+ * Pack given road bits into road bits pack.
+ * @param road_bits_of_road Road bits of ROADTYPE_ROAD road type.
+ * @param road_bits_of_tram Road bits of ROADTYPE_TRAM road type.
+ * @return Packed road bits.
+ */
+static inline RoadBitsPack PackRoadBits(RoadBits road_bits_of_road, RoadBits road_bits_of_tram)
+{
+	return (RoadBitsPack)(
+		MAKE_ROAD_BITS_PACK_OF_TYPE(road_bits_of_road, ROADTYPE_ROAD) |
+		MAKE_ROAD_BITS_PACK_OF_TYPE(road_bits_of_tram, ROADTYPE_TRAM)
+	);
+}
+
+/**
+ * Unpack road bits of all road types from road bits pack.
+ * @param road_bits_pack Road bits pack to unpack.
+ * @param road_bits_of_road Pointer where to unpack road bits of ROADTYPE_ROAD road type.
+ * @param road_bits_of_tram Pointer where to unpack road bits of ROADTYPE_TRAM road type.
+ */
+static inline void UnpackRoadBitsPack(RoadBitsPack road_bits_pack, RoadBits *road_bits_of_road, RoadBits *road_bits_of_tram)
+{
+	*road_bits_of_road = ExtractRoadBits(road_bits_pack, ROADTYPE_ROAD);
+	*road_bits_of_tram = ExtractRoadBits(road_bits_pack, ROADTYPE_TRAM);
+}
+
+/**
  * Create the road-part which belongs to the given DiagDirection
  *
  * This function returns a RoadBits value which belongs to
@@ -134,7 +221,7 @@
  */
 static inline RoadBits AxisToRoadBits(Axis a)
 {
-	return a == AXIS_X ? ROAD_X : ROAD_Y;
+	return (RoadBits)(ROAD_X >> a);
 }
 
 /**
@@ -161,4 +248,33 @@
 
 void UpdateLevelCrossing(TileIndex tile, bool sound = true);
 
+/**
+ * Transform RoadBits by given transformation.
+ * @param road_bits RoadBits to transform.
+ * @param dt Transformation to use.
+ * @return Transformed RoadBits.
+ */
+static inline RoadBits TransformRoadBits(RoadBits road_bits, DirTransform dt)
+{
+	extern const byte _road_bits_transformation_map[DT_END][ROAD_ALL + 1];
+	return (RoadBits)_road_bits_transformation_map[dt][road_bits];
+}
+
+/**
+ * Transform RoadBitsPack by given transformation.
+ * @param road_bits_pack RoadBitsPack to transform.
+ * @param dt Transformation to use.
+ * @return Transformed RoadBitsPack.
+ */
+static inline RoadBitsPack TransformRoadBitsPack(RoadBitsPack road_bits_pack, DirTransform dt)
+{
+	RoadBitsPack ret = RBP_NONE;
+	for (int bits_pos = 0; road_bits_pack != 0; bits_pos += ROADBITS_NUM_BITS) {
+		ret |= (RoadBitsPack)(TransformRoadBits((RoadBits)(road_bits_pack & ROAD_ALL), dt) << bits_pos);
+		//ret |= (, dt) );
+		road_bits_pack = (RoadBitsPack)(road_bits_pack >> ROADBITS_NUM_BITS);
+	}
+	return ret;
+}
+
 #endif /* ROAD_FUNC_H */
diff -ibruN src/road_map.h src/road_map.h
--- src/road_map.h	2010-04-18 02:27:49.000000000 +0400
+++ src/road_map.h	2010-06-20 15:22:46.000000000 +0400
@@ -120,6 +120,18 @@
 	return HasBit(GetRoadTypes(t), rt);
 }
 
+static inline RoadBitsPack GetRoadBitsPack(TileIndex t)
+{
+	RoadBitsPack ret = RBP_NONE;
+	RoadType road_type = ROADTYPE_END;
+	do {
+		road_type--;
+		ret = (RoadBitsPack)((ret << ROADBITS_NUM_BITS) | GetRoadBits(t, road_type));
+	}
+	while (road_type != ROADTYPE_BEGIN);
+	return ret;
+}
+
 static inline Owner GetRoadOwner(TileIndex t, RoadType rt)
 {
 	switch (rt) {
diff -ibruN src/road_type.h src/road_type.h
--- src/road_type.h	2010-04-21 23:20:28.000000000 +0400
+++ src/road_type.h	2010-06-20 15:40:45.000000000 +0400
@@ -68,9 +68,65 @@
 
 	ROAD_ALL  = ROAD_X  | ROAD_Y,    ///< Full 4-way crossing
 
-	ROAD_END  = ROAD_ALL + 1         ///< Out-of-range roadbits, used for iterations
+	ROAD_END  = ROAD_ALL + 1,         ///< Out-of-range roadbits, used for iterations
+	
+	ROADBITS_NUM_BITS = 4,           ///< How many bits does the RoadBits use.
 };
 DECLARE_ENUM_AS_BIT_SET(RoadBits);
 template <> struct EnumPropsT<RoadBits> : MakeEnumPropsT<RoadBits, byte, ROAD_NONE, ROAD_END, ROAD_NONE, 4> {};
+typedef SimpleTinyEnumT<RoadBits, byte> RoadBitsByte;
+
+#define MAKE_ROAD_BITS_PACK_OF_TYPE(road_bits, road_type) (road_bits << (ROADBITS_NUM_BITS * road_type))
+
+/** RoadBits for all road types packed in a single value. */
+enum RoadBitsPack {
+	RBP_NONE      = 0, ///< No road parts
+
+	RBP_ROAD_NW   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_NW,  ROADTYPE_ROAD), ///< North-west part of ROADTYPE_ROAD road
+	RBP_ROAD_SW   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_SW,  ROADTYPE_ROAD), ///< South-west part of ROADTYPE_ROAD road
+	RBP_ROAD_SE   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_SE,  ROADTYPE_ROAD), ///< South-east part of ROADTYPE_ROAD road
+	RBP_ROAD_NE   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_NE,  ROADTYPE_ROAD), ///< North-east part of ROADTYPE_ROAD road
+	RBP_ROAD_X    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_X,   ROADTYPE_ROAD), ///< Full road along the x-axis (south-west + north-east) of type ROADTYPE_ROAD
+	RBP_ROAD_Y    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_Y,   ROADTYPE_ROAD), ///< Full road along the y-axis (north-west + south-east) of type ROADTYPE_ROAD
+
+	RBP_ROAD_N    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_N,   ROADTYPE_ROAD), ///< Road of type ROADTYPE_ROAD at the two northern edges
+	RBP_ROAD_E    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_E,   ROADTYPE_ROAD), ///< Road of type ROADTYPE_ROAD at the two eastern edges
+	RBP_ROAD_S    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_S,   ROADTYPE_ROAD), ///< Road of type ROADTYPE_ROAD at the two southern edges
+	RBP_ROAD_W    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_W,   ROADTYPE_ROAD), ///< Road of type ROADTYPE_ROAD at the two western edges
+
+	RBP_TRAM_NW   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_NW,  ROADTYPE_TRAM), ///< North-west part of ROADTYPE_TRAM road
+	RBP_TRAM_SW   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_SW,  ROADTYPE_TRAM), ///< South-west part of ROADTYPE_TRAM road
+	RBP_TRAM_SE   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_SE,  ROADTYPE_TRAM), ///< South-east part of ROADTYPE_TRAM road
+	RBP_TRAM_NE   = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_NE,  ROADTYPE_TRAM), ///< North-east part of ROADTYPE_TRAM road
+	RBP_TRAM_X    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_X,   ROADTYPE_TRAM), ///< Full road along the x-axis (south-west + north-east) of type ROADTYPE_TRAM
+	RBP_TRAM_Y    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_Y,   ROADTYPE_TRAM), ///< Full road along the y-axis (north-west + south-east) of type ROADTYPE_TRAM
+
+	RBP_TRAM_N    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_N,   ROADTYPE_TRAM), ///< Road of type ROADTYPE_TRAM at the two northern edges
+	RBP_TRAM_E    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_E,   ROADTYPE_TRAM), ///< Road of type ROADTYPE_TRAM at the two eastern edges
+	RBP_TRAM_S    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_S,   ROADTYPE_TRAM), ///< Road of type ROADTYPE_TRAM at the two southern edges
+	RBP_TRAM_W    = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_W,   ROADTYPE_TRAM), ///< Road of type ROADTYPE_TRAM at the two western edges
+
+	RBP_ALL_NW    = RBP_ROAD_NW | RBP_TRAM_NW, ///< North-west part of road of all types
+	RBP_ALL_SW    = RBP_ROAD_SW | RBP_TRAM_SW, ///< South-west part of road of all types
+	RBP_ALL_SE    = RBP_ROAD_SE | RBP_TRAM_SE, ///< South-east part of road of all types
+	RBP_ALL_NE    = RBP_ROAD_NE | RBP_TRAM_NE, ///< North-east part of road of all types
+	RBP_ALL_X     = RBP_ROAD_X  | RBP_TRAM_X,  ///< Full road along the x-axis (south-west + north-east) of all types
+	RBP_ALL_Y     = RBP_ROAD_Y  | RBP_TRAM_Y,  ///< Full road along the y-axis (north-west + south-east) of all types
+
+	RBP_ALL_N     = RBP_ROAD_N  | RBP_TRAM_N,  ///< Road of all types at the two northern edges
+	RBP_ALL_E     = RBP_ROAD_E  | RBP_TRAM_E,  ///< Road of all types at the two eastern edges
+	RBP_ALL_S     = RBP_ROAD_S  | RBP_TRAM_S,  ///< Road of all types at the two southern edges
+	RBP_ALL_W     = RBP_ROAD_W  | RBP_TRAM_W,  ///< Road of all types at the two western edges
+
+	RBP_ROAD_ALL  = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_ALL, ROADTYPE_ROAD), ///< All road parts of ROADTYPE_ROAD road
+	RBP_TRAM_ALL  = MAKE_ROAD_BITS_PACK_OF_TYPE(ROAD_ALL, ROADTYPE_TRAM), ///< All road parts of ROADTYPE_TRAM road
+
+	RBP_ALL       = (1 << (ROADBITS_NUM_BITS * ROADTYPE_END)) - 1,        ///< All road parts of all road types
+};
+DECLARE_ENUM_AS_BIT_SET(RoadBitsPack);
+
+assert_compile(ROADTYPE_END * ROADBITS_NUM_BITS <= 8); // Change RoadBitsPackByte storage type from byte to some bigger type if new road types appear
+typedef SimpleTinyEnumT<RoadBitsPack, byte> RoadBitsPackByte;
+
 
 #endif /* ROAD_TYPE_H */
diff -ibruN src/saveload/saveload.h src/saveload/saveload.h
--- src/saveload/saveload.h	2010-01-30 02:54:00.000000000 +0300
+++ src/saveload/saveload.h	2010-06-20 15:22:46.000000000 +0400
@@ -156,6 +156,7 @@
 	SLE_NAME         = SLE_FILE_STRINGID | SLE_VAR_NAME,
 
 	/* Shortcut values */
+	SLE_BYTE  = SLE_UINT8,
 	SLE_UINT  = SLE_UINT32,
 	SLE_INT   = SLE_INT32,
 	SLE_STRB  = SLE_STRINGBUF,
@@ -171,6 +172,18 @@
 	/* 5 more possible flags */
 };
 
+#define SLE_VAR_IENUM(enum_type) (VarTypes)((2 * sizeof(enum_type) - 1) << 4)
+#define SLE_VAR_UENUM(enum_type) (VarTypes)((2 * sizeof(enum_type)) << 4)
+
+#define SLE_I8ENUM(enum_type) (VarTypes)(SLE_FILE_I8 | SLE_VAR_IENUM(enum_type))
+#define SLE_U8ENUM(enum_type) (VarTypes)(SLE_FILE_U8 | SLE_VAR_UENUM(enum_type))
+#define SLE_I16ENUM(enum_type) (VarTypes)(SLE_FILE_I16 | SLE_VAR_IENUM(enum_type))
+#define SLE_U16ENUM(enum_type) (VarTypes)(SLE_FILE_U16 | SLE_VAR_UENUM(enum_type))
+#define SLE_I32ENUM(enum_type) (VarTypes)(SLE_FILE_I32 | SLE_VAR_IENUM(enum_type))
+#define SLE_U32ENUM(enum_type) (VarTypes)(SLE_FILE_U32 | SLE_VAR_UENUM(enum_type))
+#define SLE_I64ENUM(enum_type) (VarTypes)(SLE_FILE_I64 | SLE_VAR_IENUM(enum_type))
+#define SLE_U64ENUM(enum_type) (VarTypes)(SLE_FILE_U64 | SLE_VAR_UENUM(enum_type))
+
 typedef uint32 VarType;
 
 enum SaveLoadTypes {
diff -ibruN src/saveload/template_sl.cpp src/saveload/template_sl.cpp
--- src/saveload/template_sl.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/saveload/template_sl.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,171 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file template_sl.cpp Template save/load handling. */
+
+#include "../stdafx.h"
+#include "../template_base.h"
+#include "saveload.h"
+
+static const uint32 INVALID_TEMPLATE_VERSION = UINT32_MAX; ///< Version number to indicate invalid template file
+
+static const SaveLoad _template_tile_saveload_desc[] = {
+	SLE_VAR(TemplateTile, type,   SLE_UINT8), 
+	SLE_VAR(TemplateTile, height, SLE_UINT8),
+	SLE_VAR(TemplateTile, m0,     SLE_UINT8),
+	SLE_VAR(TemplateTile, m1,     SLE_UINT8),
+	SLE_END()
+};
+
+#define SLE_OBJECT(type) \
+	SLE_VAR(type, tile.x, SLE_UINT16), \
+	SLE_VAR(type, tile.y, SLE_UINT16)
+
+#define SLE_AREA_OBJECT(type) \
+	SLE_OBJECT(type), \
+	SLE_VAR(type, area.x,      SLE_INT16 ), \
+	SLE_VAR(type, area.y,      SLE_INT16 ), \
+	SLE_VAR(type, area.width,  SLE_UINT16), \
+	SLE_VAR(type, area.height, SLE_UINT16)
+
+#define SLE_DIRECTED_OBJECT(type) \
+	SLE_OBJECT(type), \
+	SLE_VAR(type, direction, SLE_U8ENUM(DiagDirection))
+
+#define SLE_DOUBLE_ENDED_OBJECT(type) \
+	SLE_OBJECT(type), \
+	SLE_VAR(type, other_end_offset.x, SLE_INT16), \
+	SLE_VAR(type, other_end_offset.y, SLE_INT16)
+
+static const SaveLoad _bridge_saveload_desc[] = {
+	SLE_DOUBLE_ENDED_OBJECT(Template::Bridge),
+	SLE_VAR(Template::Bridge, bridge_type, SLE_UINT),
+	SLE_END()
+};
+
+static const SaveLoad _tunnel_saveload_desc[] = {
+	SLE_DOUBLE_ENDED_OBJECT(Template::Bridge),
+	SLE_END()
+};
+
+static const SaveLoad _station_part_saveload_desc[] = {
+	SLE_VAR(Template::StationPart, station_id, SLE_UINT16),
+	SLE_VAR(Template::StationPart, direction, SLE_U8ENUM(DiagDirection)),
+	SLE_END()
+};
+
+static const SaveLoad _rail_station_saveload_desc[] = {
+	SLE_END()
+};
+
+static const SaveLoad _road_stop_saveload_desc[] = {
+	SLE_VAR(Template::RoadStop, road_stop_type, SLE_U8ENUM(RoadStopType)),
+	SLE_END()
+};
+
+static const SaveLoad _dock_station_saveload_desc[] = {
+	SLE_END()
+};
+
+static const SaveLoad _airport_saveload_desc[] = {
+	SLE_VAR(Template::Airport, airport_type, SLE_UINT8),
+	SLE_END()
+};
+
+static const SaveLoad _signal_saveload_desc[] = {
+	SLE_VAR(Template::Signal, signal_type, SLE_U8ENUM(SignalType)   ),
+	SLE_VAR(Template::Signal, variant,     SLE_U8ENUM(SignalVariant)),
+	SLE_VAR(Template::Signal, location,    SLE_U8ENUM(Trackdir)     ),
+	SLE_VAR(Template::Signal, two_way,     SLE_BOOL                 ),
+	SLE_END()
+};
+
+static const SaveLoad _station_saveload_desc[] = {
+	SLE_VAR(Template::Station, id,                             SLE_UINT16),
+	SLE_VAR(Template::Station, properties.layout,              SLE_U8ENUM(TemplateStationLayoutBits)),
+	SLE_VAR(Template::Station, properties.has_station_of_type, SLE_U8ENUM(TemplateStationPartTypeBits)),
+	SLE_VAR(Template::Station, properties.spread,              SLE_UINT16),
+	SLE_VAR(Template::Station, properties.has_drive_through,   SLE_BOOL),
+	//TODO: name
+	SLE_END()
+};
+
+/* ===================================================================================== */
+/*                                                                                       */
+/*  TODO: Template file structure                                                        */
+/*                                                                                       */
+/*  V0                        V1                          V2                             */
+/*  +--------------------+    +---------------------+     +---------------------------+  */
+/*  |  "TMPL"   4 B      |    |  "TMPL"    4 B      |     |  "TMPL"          4 B      |  */
+/*  +--------------------+    +---------------------+     +---------------------------+  */
+/*  |  width    4 B, BE  |    |  version   4 B, BE  |     |  major version   2 B, BE  |  */
+/*  +--------------------+    +---------------------+     +---------------------------+  */
+/*  |  height   4 B, BE  |    |  width     4 B, BE  |     |  minor version   2 B, BE  |  */
+/*  +--------------------+    +---------------------+     +---------------------------+  */
+/*  |                    |    |  height    4 B, BE  |     |  width           4 B, BE  |  */
+/*  |     DATA V0        |    +---------------------+     +---------------------------+  */
+/*  |                    |    |                     |     |  height          4 B, BE  |  */
+/*  +--------------------+    |      DATA V1        |     +---------------------------+  */
+/*                            |                     |     |                           |  */
+/*                            +---------------------+     +---------------------------+  */
+/*                                                        |                           |  */
+/*                                                        +---------------------------+  */
+/*                                                        |                           |  */
+/*                                                        +---------------------------+  */
+/*                                                        |                           |  */
+/*                                                        |        DATA V2            |  */
+/*                                                        |                           |  */
+/*                                                        +---------------------------+  */
+/*                                                                                       */
+/* ===================================================================================== */
+
+//struct TemplateFileInfo
+//{
+//	uint32 version; ///< Version number
+//	uint32 width;   ///< Template width (including last dummy row for storing tiles height)
+//	uint32 height;  ///< Template height (including last dummy column for storing tiles height)
+//	//TODO: other
+//};
+//
+//class TemplateLoadBuilder : public TemplateBuilder {
+//protected:
+//	istream &input;
+//	const TemplateFileInfo &file_info;
+//
+//public:
+//	TemplateLoadBuilder(istream &input, const TemplateFileInfo &file_info)
+//		: TemplateBuilder(file_info.width, file_info.height)
+//		, input(input)
+//		, file_info(file_info)
+//	{
+//	}
+//};
+//
+//class TemplateV1LoadBuilder : public TemplateLoadBuilder {
+//protected:
+//	virtual TemplateBuilder::BuildReadinessFlags Build()
+//	{
+//		/* TODO: */
+//		return BRF_BASIC;
+//	}
+//
+//public:
+//	TemplateV1LoadBuilder(istream &input, const TemplateFileInfo &file_info) : TemplateLoadBuilder(input, file_info) { }
+//};
+//
+//class TemplateV2LoadBuilder : public TemplateLoadBuilder {
+//protected:
+//	virtual TemplateBuilder::BuildReadinessFlags Build()
+//	{
+//		/* TODO: */
+//		return BRF_BASIC;
+//	}
+//
+//public:
+//	TemplateV2LoadBuilder(istream &input, const TemplateFileInfo &file_info) : TemplateLoadBuilder(input, file_info) { }
+//};
+
diff -ibruN src/settings_type.h src/settings_type.h
--- src/settings_type.h	2010-04-04 00:19:26.000000000 +0400
+++ src/settings_type.h	2010-06-20 15:22:46.000000000 +0400
@@ -154,6 +154,52 @@
 #endif
 };
 
+/** The way how the heights should be restored when pasting template. */
+enum ClipboardHeightsRestoringMode {
+	CHRM_BEGIN   = 0,
+	CHRM_NONE    = 0, ///< Do not restore any heights.
+	CHRM_MINIMAL = 1, ///< Terraform as less as possible to paste all objects at right heights.
+	CHRM_FULL    = 2, ///< Restore all heights within template bounds.
+	CHRM_END
+};
+typedef SimpleTinyEnumT<ClipboardHeightsRestoringMode, byte> ClipboardHeightsRestoringModeByte;
+
+/** The way how the tiles should be buldozed when pasting template. */
+enum ClipboardBuldozingMode {
+	CBM_BEGIN            = 0,
+	CBM_NONE             = 0, ///< Do not buldoze any tiles.
+	CBM_MINIMAL_INTERIOR = 1, ///< Buldoze as less as possible not exceeding template bounds.
+	CBM_FULL_INTERIOR    = 2, ///< Buldoze all tiles within template bounds.
+	CBM_END
+};
+typedef SimpleTinyEnumT<ClipboardBuldozingMode, byte> ClipboardBuldozingModeByte;
+
+/** Settings related to the clipboard. */
+struct ClipboardSettings {
+	struct Copying {
+		bool with_rail;            ///< If rail should be copied
+		bool with_road;            ///< If road should be copied
+		bool with_tram;            ///< If tram should be copied
+		bool with_airports;        ///< If airports should be copied
+		bool with_water_transport; ///< If water transport should be
+		bool with_other;           ///< If stuff owned by other players should be copied
+		bool with_station_names;   ///< If station names should be copied
+	}
+	copying;
+
+	struct Pasting {
+		ClipboardHeightsRestoringModeByte restore_heights; ///< The way how the heights should be restored.
+		ClipboardBuldozingModeByte buldoze_mode;           ///< The way how the tiles should be buldozed.
+		bool convert_rail_type;                            ///< If rails should be converted to currently selected railtype
+		bool reverse_signals;                              ///< If signal direction should be toggled when pasting
+
+		//TODO: synchronize pasting with server?
+		//TODO: maybe automatically adjust network_paste_speed measuring tics per second and network lag?
+		uint8 network_paste_speed;                         ///< Paste speed in multiplayer games (ticks between sent commands).
+	}
+	pasting;
+};
+
 /** Settings related to the creation of games. */
 struct GameCreationSettings {
 	uint32 generation_seed;                  ///< noise seed for world generation
@@ -397,6 +443,7 @@
 	GUISettings          gui;                ///< settings related to the GUI
 	NetworkSettings      network;            ///< settings related to the network
 	CompanySettings      company;            ///< default values for per-company settings
+	ClipboardSettings    clipboard;          ///< settings related to the clipboard
 };
 
 /** The current settings for this game. */
diff -ibruN src/station.cpp src/station.cpp
--- src/station.cpp	2010-06-19 20:35:37.000000000 +0400
+++ src/station.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -248,12 +248,12 @@
 	/* Compute acceptance rectangle */
 	int catchment_radius = this->GetCatchmentRadius();
 
-	Rect ret = {
+	Rect ret = { { {
 		max<int>(this->rect.left   - catchment_radius, 0),
 		max<int>(this->rect.top    - catchment_radius, 0),
 		min<int>(this->rect.right  + catchment_radius, MapMaxX()),
 		min<int>(this->rect.bottom + catchment_radius, MapMaxY())
-	};
+	} } };
 
 	return ret;
 }
@@ -383,7 +383,7 @@
 	} else if (!PtInExtendedRect(x, y)) {
 		/* current rect is not empty and new point is outside this rect
 		 * make new spread-out rectangle */
-		Rect new_rect = {min(x, this->left), min(y, this->top), max(x, this->right), max(y, this->bottom)};
+		Rect new_rect = { { { min(x, this->left), min(y, this->top), max(x, this->right), max(y, this->bottom) } } };
 
 		/* check new rect dimensions against preset max */
 		int w = new_rect.right - new_rect.left + 1;
diff -ibruN src/station_gui.cpp src/station_gui.cpp
--- src/station_gui.cpp	2010-06-20 15:51:49.000000000 +0400
+++ src/station_gui.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -103,7 +103,7 @@
 			}
 			if (cargos[i] >= (supplies ? 1U : 8U)) SetBit(cargo_mask, i);
 		}
-		Rect r = {left, top, right, INT32_MAX};
+		Rect r = { { { left, top, right, INT32_MAX } } };
 		return DrawCargoListText(cargo_mask, r, supplies ? STR_STATION_BUILD_SUPPLIES_CARGO : STR_STATION_BUILD_ACCEPTS_CARGO);
 	}
 
@@ -982,7 +982,7 @@
 
 			/* Draw waiting cargo. */
 			NWidgetBase *nwi = this->GetWidget<NWidgetBase>(SVW_WAITING);
-			Rect waiting_rect = {nwi->pos_x, nwi->pos_y, nwi->pos_x + nwi->current_x - 1, nwi->pos_y + nwi->current_y - 1};
+			Rect waiting_rect = { { { nwi->pos_x, nwi->pos_y, nwi->pos_x + nwi->current_x - 1, nwi->pos_y + nwi->current_y - 1 } } };
 			this->DrawWaitingCargo(waiting_rect, cargolist, transfers);
 		}
 	}
@@ -1119,7 +1119,7 @@
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			if (HasBit(st->goods[i].acceptance_pickup, GoodsEntry::ACCEPTANCE)) SetBit(cargo_mask, i);
 		}
-		Rect s = {r.left + WD_FRAMERECT_LEFT, r.top + WD_FRAMERECT_TOP, r.right - WD_FRAMERECT_RIGHT, INT32_MAX};
+		Rect s = { { { r.left + WD_FRAMERECT_LEFT, r.top + WD_FRAMERECT_TOP, r.right - WD_FRAMERECT_RIGHT, INT32_MAX } } };
 		int bottom = DrawCargoListText(cargo_mask, s, STR_STATION_VIEW_ACCEPTS_CARGO);
 		return (bottom - r.top - WD_FRAMERECT_TOP + FONT_HEIGHT_NORMAL - 1) / FONT_HEIGHT_NORMAL;
 	}
@@ -1160,6 +1160,7 @@
 				this->SetWidgetDirty(SVW_WAITING);
 				break;
 			}
+
 		}
 	}
 
Binary files src/table/.DS_Store and src/table/.DS_Store differ
diff -ibruN src/table/settings.h src/table/settings.h
--- src/table/settings.h	2010-05-21 20:03:29.000000000 +0400
+++ src/table/settings.h	2010-06-20 15:22:46.000000000 +0400
@@ -649,6 +649,20 @@
 	 SDTC_VAR(gui.right_mouse_btn_emulation, SLE_UINT8, S, MS, 0, 0, 2, 0, STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU, NULL),
 #endif
 
+	/* Clipboard related settings */
+	SDTC_BOOL(clipboard.copying.with_rail,                          S|C,  0,  true,            STR_NULL,                          NULL),
+	SDTC_BOOL(clipboard.copying.with_road,                          S|C,  0,  true,            STR_NULL,                          NULL),
+	SDTC_BOOL(clipboard.copying.with_tram,                          S|C,  0,  true,            STR_NULL,                          NULL),
+	SDTC_BOOL(clipboard.copying.with_airports,                      S|C,  0,  true,            STR_NULL,                          NULL),
+	SDTC_BOOL(clipboard.copying.with_water_transport,               S|C,  0,  true,            STR_NULL,                          NULL),
+	SDTC_BOOL(clipboard.copying.with_other,                         S|C,  0, false,            STR_NULL,                          NULL),
+	SDTC_BOOL(clipboard.copying.with_station_names,                 S|C,  0, false,            STR_NULL,                          NULL),
+	 SDTC_VAR(clipboard.pasting.restore_heights,         SLE_UINT8, S|C,  0,CHRM_MINIMAL,CHRM_BEGIN,CHRM_END-1,0,STR_NULL,        NULL),
+	 SDTC_VAR(clipboard.pasting.buldoze_mode,            SLE_UINT8, S|C,  0,CBM_MINIMAL_INTERIOR,CBM_BEGIN,CBM_END-1,0,STR_NULL,  NULL),
+	SDTC_BOOL(clipboard.pasting.convert_rail_type,                  S|C,  0,  true,            STR_NULL,                          NULL),
+	SDTC_BOOL(clipboard.pasting.reverse_signals,                    S|C,  0, false,            STR_NULL,                          NULL),
+ 	 SDTC_VAR(clipboard.pasting.network_paste_speed,     SLE_UINT8,   S, NO,     5, 1, 255, 0, STR_NULL,                          NULL),
+
 	SDT_END()
 };
 
diff -ibruN src/table/sprites.h src/table/sprites.h
--- src/table/sprites.h	2010-02-04 18:42:38.000000000 +0300
+++ src/table/sprites.h	2010-06-20 15:45:42.000000000 +0400
@@ -180,7 +180,10 @@
 static const SpriteID SPR_ELRAIL_BASE   = SPR_AUTORAIL_BASE + AUTORAIL_SPRITE_COUNT;
 static const uint16 ELRAIL_SPRITE_COUNT = 48;
 
-static const SpriteID SPR_2CCMAP_BASE   = SPR_ELRAIL_BASE + ELRAIL_SPRITE_COUNT;
+static const SpriteID	SPR_COPYPASTE_BASE = SPR_ELRAIL_BASE + ELRAIL_SPRITE_COUNT;
+static const uint16	COPYPASTE_SPRITE_COUNT = 22;
+
+static const SpriteID	SPR_2CCMAP_BASE   = SPR_COPYPASTE_BASE + COPYPASTE_SPRITE_COUNT;
 static const uint16 TWOCCMAP_SPRITE_COUNT = 256;
 
 /* shore tiles - action 05-0D */
@@ -1055,6 +1058,23 @@
 static const SpriteID SPR_IMG_SIGN            = 4082;
 static const SpriteID SPR_IMG_BUY_LAND        = 4791;
 
+	/* clipboard_gui.cpp */
+	static const SpriteID SPR_IMG_COPY              = SPR_COPYPASTE_BASE;
+	static const SpriteID SPR_IMG_PASTE             = SPR_COPYPASTE_BASE + 1;
+	static const SpriteID SPR_IMG_ROTATE_LEFT       = SPR_COPYPASTE_BASE + 2;
+	static const SpriteID SPR_IMG_ROTATE_RIGHT      = SPR_COPYPASTE_BASE + 3;
+	static const SpriteID SPR_IMG_LOAD              = SPR_COPYPASTE_BASE + 4;
+	static const SpriteID SPR_IMG_MINUS_TERRAIN     = SPR_COPYPASTE_BASE + 5;
+	static const SpriteID SPR_IMG_NEUTRAL_TERRAIN   = SPR_COPYPASTE_BASE + 6;
+	static const SpriteID SPR_IMG_PLUS_TERRAIN      = SPR_COPYPASTE_BASE + 7;
+	static const SpriteID SPR_IMG_MINUS_DYNAMITE    = SPR_COPYPASTE_BASE + 10;
+	static const SpriteID SPR_IMG_MIRROR_HORIZONTAL = SPR_COPYPASTE_BASE + 12;
+	static const SpriteID SPR_IMG_MIRROR_VERTICAL   = SPR_COPYPASTE_BASE + 13;
+	static const SpriteID SPR_IMG_MINUS_SIGNAL      = SPR_COPYPASTE_BASE + 14;
+	static const SpriteID SPR_IMG_NO_RAIL           = SPR_COPYPASTE_BASE + 16;
+	static const SpriteID SPR_IMG_NO_ROAD           = SPR_COPYPASTE_BASE + 18;
+	static const SpriteID SPR_IMG_ONLY_OWN          = SPR_COPYPASTE_BASE + 20;
+
 /* OPEN TRANSPORT TYCOON in gamescreen */
 static const SpriteID SPR_OTTD_O                = 4842;
 static const SpriteID SPR_OTTD_P                = 4841;
@@ -1395,6 +1415,10 @@
 static const CursorID SPR_CURSOR_CLONE_SHIP     = SPR_OPENTTD_BASE + 112;
 static const CursorID SPR_CURSOR_CLONE_AIRPLANE = SPR_OPENTTD_BASE + 113;
 
+	/* The clipboard cursors */
+static const CursorID SPR_CURSOR_COPY           = SPR_COPYPASTE_BASE + 8;
+static const CursorID SPR_CURSOR_PASTE          = SPR_COPYPASTE_BASE + 9;
+
 /** Animation macro in table/animcursors.h (_animcursors[]) */
 
 /** Flag for saying a cursor sprite is an animated cursor. */
diff -ibruN src/template.cpp src/template.cpp
--- src/template.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/template.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,419 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file template.cpp Template core implementation, template builder. */
+
+#include "stdafx.h"
+
+#include "core/geometry_func.hpp"
+#include "core/endian_func.hpp"
+#include "core/alloc_func.hpp"
+#include "core/math_func.hpp"
+
+#include "saveload/saveload.h"
+
+#include "direction_func.h"
+#include "track_func.h"
+#include "road_func.h"
+
+#include <new>
+#include <algorithm>
+
+#include "template_base.h"
+
+static bool CompareStationsByID(const Template::Station *a, const Template::Station *b) { return a->id < b->id; }
+static bool CompareStationPartsByStationID(const Template::StationPart *a, const Template::StationPart *b) { return a->station_id < b->station_id; }
+
+void CopyWholeTile(TemplateTile &dest_tile, const TemplateTile &source_tile) { dest_tile = source_tile; }
+void CopyTileHeight(TemplateTile &dest_tile, const TemplateTile &source_tile) { dest_tile.height = source_tile.height; }
+
+/**
+ * Transform tile data.
+ * @param dt Transformation to use.
+ */
+void TemplateTile::Transform(DirTransform dt)
+{
+	switch (this->type) {
+		case TTT_RAIL_TRANSPORT:
+			this->rail.bits = TransformTrackBits(this->rail.bits, dt);
+			break;
+
+		case TTT_ROAD_TRANSPORT:
+			this->road.bits = TransformRoadBitsPack(this->road.bits, dt);
+			break;
+
+		case TTT_RAIL_X_ROAD_Y:
+			if (TransformAxis(AXIS_X, dt) != AXIS_X) this->type = TTT_RAIL_Y_ROAD_X;
+			break;
+
+		case TTT_RAIL_Y_ROAD_X:
+			if (TransformAxis(AXIS_X, dt) != AXIS_X) this->type = TTT_RAIL_X_ROAD_Y;
+			break;
+
+		default: break;
+	}
+}
+
+AffineMap<int16> TemplateTilesArray::Transform(DirTransform dt)
+{
+	if ((this->size.width < 2) || (this->size.height < 2)) return AffineMap<int16>::IDENTITY;
+
+	/* Indices transformation matrices for tiles content and tiles height. */
+	AffineMap<int16> content_indices_map, height_indices_map;
+
+	FillArrayIndicesMap(dt, this->size, &height_indices_map);
+	FillArrayIndicesMap(dt, this->size - Dimension::Create(1, 1), &content_indices_map);
+
+	Dimension new_size = this->size;
+	if (TransformAxis(AXIS_X, dt) != AXIS_X) ::Swap(new_size.width, new_size.height);
+
+	TemplateTilesArray transformed(new_size.width, new_size.height);
+
+	this->TransformIndices<CopyWholeTile>(&transformed, TemplateTileIndex::Create(0, 0),
+		TemplateTileIndex::Create(this->size.width - 2, this->size.height - 2), content_indices_map);
+
+	this->TransformIndices<CopyTileHeight>(&transformed, TemplateTileIndex::Create(0, 0),
+		TemplateTileIndex::Create(this->size.width - 1, this->size.height - 1), height_indices_map);
+
+	/* swap with transformed array */
+	this->Swap(&transformed);
+
+	/* transform tiles content */
+	for (Compact2DOffset i(0); i != (int)this->length; i++) this->At(i)->Transform(dt);
+
+	return content_indices_map;
+}
+
+template <TemplateTilesArray::TileCopyProc Ttile_copy_proc>
+void TemplateTilesArray::TransformIndices(TemplateTilesArray *transformed, TemplateTileIndex first, TemplateTileIndex last, const AffineMap<int16> &map)
+{
+	/* Tiles are stored in the compact array (see Compact2DArray) and we can use its properties.
+	 * Tiles that lie next to each other are distanced by constant offset. After transforming
+	 * them they still lie next to each other but in other dimension (along row/column) or order,
+	 * the offset is other but still constant. We will transform these offsets and use them instead
+	 * of transforming x/y indices. */
+
+	/* offset in the transformed array between tiles that in the
+	 * original array lie next to each other in the same row */
+	ptrdiff_t dst_diff_next_in_row;
+
+	/* offset in the transformed array between tiles that in the original array are the
+	 * last tile in a row and the first tile in a next row of being transformed rectangle */
+	ptrdiff_t dst_diff_next_row;
+
+	/* mapped pointer to the destionation tile */
+	TemplateTile *dst;
+
+	{
+		/* calculate transformed indices of tiles that lie on some specific positions in the original array */
+		TemplateTileIndex first_in_first_row  = map * first;
+		TemplateTileIndex second_in_first_row = map * TemplateTileIndex::Create(first.x + 1, first.y);
+		TemplateTileIndex last_in_first_row   = map * TemplateTileIndex::Create(last.x,      first.y);
+		TemplateTileIndex first_in_second_row = map * TemplateTileIndex::Create(first.x,     first.y + 1);
+
+		/* calculate transformed offsets */
+		dst = transformed->At(first_in_first_row);
+		dst_diff_next_in_row = transformed->IndexToOffset(second_in_first_row) - transformed->IndexToOffset(first_in_first_row);
+		dst_diff_next_row = transformed->IndexToOffset(first_in_second_row) - transformed->IndexToOffset(last_in_first_row);
+	}
+
+	int first_last_x_diff = last.x - first.x;
+	TemplateTile *src_last = this->At(last);
+
+	/* iterate through source rows */
+	for (Iter src = this->IterAt(first); src <= src_last; src.y++) {
+		/* iterate through tiles in source row and copy tiles content */
+		TemplateTile *src_last_in_row = src.item + first_last_x_diff; // the last tile to transform of current source row
+		for (; ; ) {
+			Ttile_copy_proc(*dst, *src); // copy tile
+			if (src == src_last_in_row) break; // if we copied the last tile, break the loop leaving iterators on that tile
+			src.x++, dst += dst_diff_next_in_row; // advance iterators to the next tile in current source row
+		}
+		src.x -= first_last_x_diff; // move source iterator back to the beggining of current source row
+		dst += dst_diff_next_row; // move mapped iterator to the beggining of next source row
+	}
+}
+
+Template::~Template()
+{
+	while (this->objects != NULL) {
+		Template::Object *tmp = this->objects;
+		this->objects = this->objects->NextObject();
+		delete tmp;
+	}
+}
+
+/**
+ * Swap template contents with another template
+ * @param second template with which the contents will be swapped
+ */
+void Template::Swap(Template *second)
+{
+	/* Swap TemplateFace members */
+	::Swap(this->width, second->width);
+	::Swap(this->height, second->height);
+	::Swap(this->properties, second->properties);
+
+	/* Swap Template members */
+	this->tiles.Swap(&second->tiles);
+	::Swap(this->objects, second->objects);
+}
+
+/**
+ * Transform template contents.
+ * @param dt Transformation to use.
+ */
+void Template::Transform(DirTransform dt)
+{
+	if ((this->height < 1) || (this->width < 1)) return;
+
+	/* Transform tiles array */
+	AffineMap<int16> indices_map = this->tiles.Transform(dt);
+	this->width = this->tiles.Width() - 1;
+	this->height = this->tiles.Height() - 1;
+
+	/* Transform collection of map objects */
+	for (Template::Object* object = this->objects; object != NULL; object = object->NextObject()) {
+		object->tile = indices_map * object->tile;
+		object->Transform(dt);
+	}
+}
+
+/* virtual */ bool Template::Load(const char *filename)
+{
+	/* TODO: */
+	return true;
+}
+
+/* virtual */ bool Template::Save(const char *filename) const
+{
+	/* TODO: */
+	return true;
+}
+
+/* virtual */ void Template::AreaObject::Transform(DirTransform dt)
+{
+	AffineMap<int> map;
+	FillArrayIndicesMap(dt, this->area.dimension, &map);
+	/* nagete area position to get the base tile position relative to the area, then
+	 * transform this position with area transformation map and nagate it again to
+	 * get transformed position of the area relative to base tile */
+	this->area.point = -(map * -this->area.point);
+
+	if (TransformAxis(AXIS_X, dt) != AXIS_X) ::Swap(this->area.width, this->area.height);
+}
+
+/* virtual */ void Template::DirectedObject::Transform(DirTransform dt)
+{
+	this->direction = TransformDiagDir(this->direction, dt);
+}
+
+/* virtual */ void Template::DoubleEndedObject::Transform(DirTransform dt)
+{
+	this->other_end_offset = DirTransformToLinearMap<int>(dt) * this->other_end_offset;
+}
+
+/* virtual */ void Template::StationPart::Transform(DirTransform dt)
+{
+	AreaObject::Transform(dt);
+	this->direction = TransformDiagDir(this->direction, dt);
+}
+
+/* virtual */ void Template::Signal::Transform(DirTransform dt)
+{
+	this->location = TransformTrackdir(this->location, dt);
+}
+
+/* virtual */ TemplateBuilder::~TemplateBuilder()
+{
+	this->FreeObjects();
+}
+
+/**
+ * Create new template station object, add it to the objects list and stations vector (optionally at given position).
+ *
+ * @param pos Position where to add new station in the stations vector. If NULL then station is added at the end of vector.
+ * @return Added station.
+ */
+Template::Station *TemplateBuilder::AddStation(Template::Station * const *pos)
+{
+	Template::Station *ret = this->AddObject(new Template::Station, TemplateTileIndex::Create(0, 0));
+	if (pos == NULL) pos = this->stations.End();
+	return *(this->stations.Insert(const_cast<Template::Station**>(pos))) = ret;
+}
+
+void TemplateBuilder::BuildTemplate(Template *out_template)
+{
+	this->FreeObjects();
+	this->tiles.Resize(0, 0);
+	MemSetT(&this->properties, 0);
+
+	try {
+		this->Build();
+
+		if ((this->tiles.Width() <= 1) || (this->tiles.Height() <= 1)) throw TMPL_BuildException();
+
+		this->ProcessStations();
+
+		//TODO: template properties
+	} catch (TMPL_BuildException&) {
+		this->FreeObjects();
+		throw;
+	}
+
+	out_template->width = this->tiles.Width() - 1;
+	out_template->height = this->tiles.Height() - 1;
+	Swap(out_template->objects, this->first_object);
+	out_template->tiles.Swap(&this->tiles);
+	out_template->properties = this->properties;
+	this->FreeObjects();
+	this->tiles.Resize(0, 0);
+}
+
+void TemplateBuilder::ProcessStations()
+{
+	for (uint i = 0; i < this->stations.Length(); i++) MemSetT(&this->stations[i]->properties, 0);
+
+	SmallVector<Template::StationPart*, 4> station_parts;
+
+	/* List station parts and add missing stations */
+	for (Template::Object *object = this->first_object; object != NULL; object = object->next) {
+		if (object->object_type == TOT_STATION_PART) {
+			Template::StationPart *part = reinterpret_cast<Template::StationPart*>(object);
+			*(station_parts.Append()) = part;
+			for (Template::Station **station = this->stations.Begin(); ; station++) {
+				if (station == this->stations.End()) {
+					this->AddStation()->id = part->station_id;
+					break;
+				}
+				if ((*station)->id == part->station_id) break;
+			}
+		}
+	}
+
+	if (this->stations.Length() == 0) return;
+
+	this->SortStations();
+	std::sort(station_parts.Begin(), station_parts.End(), CompareStationPartsByStationID);
+
+	//SmallVector<Template::StationPart*, 4> station_first_parts_idx;
+	//station_first_parts_idx.Reserve(this->stations.Length());
+
+	uint station_idx = 0;
+	Template::Station *station = this->stations[0];
+	for (uint i = 0; i < station_parts.Length(); i++) {
+		Template::StationPart *part = station_parts[i];
+		while (part->station_id > station->id) station = this->stations[++station_idx];
+		part->next_part = station->parts_list;
+		station->parts_list = part;
+
+		/* if the station contains waypoint part it must be the only part */
+		if (part->part_type == TSPT_WAYPOINT) {
+			if (station->properties.has_station_of_type != TSPTB_NONE) throw TMPL_BuildException();
+		} else {
+			if (HasBit(station->properties.has_station_of_type, TSPT_WAYPOINT)) throw TMPL_BuildException();
+		}
+
+		SetBit(station->properties.has_station_of_type, part->part_type);
+	}
+
+	//TODO: station layout, stations adjacent
+
+/*
+	//if (this->stations.Length() < 2) return;
+	//std::sort(this->stations.Begin(), this->stations.End(), Template::CompareStationsByID);
+	//TemplateStationID last_id = this->stations.Begin()->id;
+	//for (Template::Station **station = this->stations.Begin() + 1; station != this->stations.End(); station++) {
+	//	if ((*station)->id == last_id) throw TMPL_BuildException();
+	//	last_id = (*station)->id;
+	//}
+*/
+
+/*
+	Template::StationPart *part;
+	Template::Station *station;
+
+	RectT<uint16> bounds;
+
+	for (uint i = 0; i < this->Stations().Length(); i++) {
+		station = this->stations[i];
+		if (station->parts_list == NULL) {
+			MemSetT(&station->properties, 0);
+		} else {
+			part = station->parts_list;
+			bounds = RectT<uint16>::Create(part->tile, part->tile);
+			while (part->next_part != NULL) {
+				part = part->next_part;
+				BoundsInclude(&bounds, part->tile);
+				Template::RailStation *as_rail = part->AsRailStation();
+				if (as_rail != NULL) {
+					BoundsInclude(&bounds, PointT<uint16>::Create(as_rail->tile.x + as_rail->size.width - 1, as_rail->tile.y + as_rail->size.height - 1));
+				}
+			}
+			station->properties.spread = max(bounds.right - bounds.left, bounds.bottom - bounds.top) + 1;
+			TemplateBuilder::ComputeStationLayout(station, bounds);
+		}
+	}
+*/
+
+/*
+	int width = bounds.right - bounds.left + 1;
+	int height = bounds.bottom - bounds.top + 1;
+
+	// bit to mark parts as visited
+	static const TemplateStationPartType TSPT_VISITED = TSPT_END;
+	static const TemplateStationPartTypeBits TSPTB_VISITED = 1 << TSPT_VISITED;
+
+	BoundsT<uint16> rail_bounds = BoundsT<uint16>::EMPTY;
+	TemplateStationPartTypeBitsByte *station_parts_tilemap = AllocaM(TemplateStationPartTypeBitsByte, width * height);
+	MemSetT(station_parts_tilemap, 0, width * height);
+
+	for (Template::StationPart *part = station->parts_list; part != NULL; part = part->NextPart()) {
+		for (int y = 0; y < part->size.height; y++) {
+			for (int x = 0; x < part->size.width; x++) {
+				station_parts_tilemap[y * width + x] = part->part_type;
+				if (part->part_type == TSPT_RAIL_STATION) {
+					rail_bounds.Include(part->tile);
+					rail_bounds.Include(part->tile + part->size);
+				}
+			}
+		}
+	}
+
+	Template::StationPart **islands = AllocaM(Template::StationPart, width * height);
+	int num_islands = 0;
+*/
+}
+
+/** Free objects list. */
+void TemplateBuilder::FreeObjects()
+{
+	while (this->first_object != NULL) {
+		Template::Object *object = this->first_object;
+		this->first_object = object->next;
+		delete object;
+	}
+	this->last_object = NULL;
+	this->stations.Clear();
+}
+
+/**
+ * Sort stations vector by station ID.
+ * Any two of these stations can't have the same ID.
+ *
+ * @throw TMPL_StationsIDNotUnique Some of stations have the same ID.
+ */
+void TemplateBuilder::SortStations()
+{
+	if (this->stations.Length() < 2) return;
+	std::sort(this->stations.Begin(), this->stations.End(), CompareStationsByID);
+	TemplateStationID prev_id = this->stations[0]->id;
+	for (uint i = 1; i < this->stations.Length(); i++) {
+		if (this->stations[i]->id == prev_id) throw TMPL_BuildException();
+		prev_id = this->stations[i]->id;
+	}
+}
diff -ibruN src/template.h src/template.h
--- src/template.h	1970-01-01 03:00:00.000000000 +0300
+++ src/template.h	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,406 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file template.h Header file for templates. */
+
+#ifndef TEMPLATE_H
+#define TEMPLATE_H
+
+#include "template_base.h"
+#include "map_type.h"
+#include "track_type.h"
+#include "rail_type.h"
+#include "road_type.h"
+#include "signal_type.h"
+#include "station_type.h"
+#include "bridge.h"
+#include "strings_func.h"
+#include "core/alloc_type.hpp"
+#include "core/smallvec_type.hpp"
+#include "misc/compact_array.hpp"
+
+#include "table/strings.h"
+
+#include <istream>
+#include <ostream>
+
+class Template;
+class TemplateBuilder;
+
+static const uint32 TEMPLATE_VERSION = 2; ///< Major version for saved templates
+
+/** Type of template tile. */
+enum TemplateTileType {
+	TTT_BEGIN = 0,         ///< Used for iterations.
+
+	TTT_CLEAR = 0,         ///< Clear tile.
+	TTT_RAIL_TRANSPORT,    ///< Tile with rail transport infrastructure.
+	TTT_ROAD_TRANSPORT,    ///< Tile with road transport infrastructure.
+	TTT_WATER_TRANSPORT,   ///< Tile with water transport infrastructure.
+	TTT_AIR_TRANSPORT,     ///< Tile with air transport infrastructure.
+	TTT_RAIL_X_ROAD_Y,     ///< Crossing with railway along x-axis and road along y-axis.
+	TTT_RAIL_Y_ROAD_X,     ///< Crossing with road along x-axis and railway along y-axis.
+
+	TTT_END                ///< Used for iterations.
+};
+typedef SimpleTinyEnumT<TemplateTileType, byte> TemplateTileTypeByte;
+
+typedef StationID TemplateStationID; ///< ID of template station.
+
+static const TemplateStationID INVALID_TEMPLATE_STATION_ID = 0xFFFF; ///< Invalid ID of template station.
+
+struct TMPL_Exception { };
+struct TMPL_BuildException : public TMPL_Exception { };
+
+/** Structure describing one tile of template tiles array. */
+struct TemplateTile {
+	TemplateTileTypeByte type; ///< Type of a tile.
+	uint8 height;              ///< Height of a tile.
+
+	union {
+		struct {
+			byte m0; ///< Rail type for rail and crossing tile, road bits pack for road tile. Store as SimpleTinyEnumT to be sure about same memeory model for each union member.
+			byte m1; ///< Rail bits for rail tile, road types for road and crossing tile. Store as SimpleTinyEnumT to be sure about same memeory model for each union member.
+		};
+
+		struct {
+			RailTypeByte type;  ///< Type of rail track or rail transport building.
+			TrackBitsByte bits; ///< Rail track bits.
+		}
+		rail; ///< Additional tile data if tile is of type TTT_RAIL_TRANSPORT.
+
+		struct {
+			RoadBitsPackByte bits; ///< Road bits of all road types.
+			RoadTypesByte types;   ///< Type of road.
+		}
+		road; ///< Additional tile data if tile is of type TTT_ROAD_TRANSPORT.
+
+		struct {
+			RailTypeByte rail_type;   ///< Type of rail track.
+			RoadTypesByte road_types; ///< Type of road.
+		}
+		crossing; ///< Additional tile data if tile is of type TTT_RAIL_X_ROAD_Y or TTT_RAIL_Y_ROAD_X.
+	};
+
+	/**
+	 * Rotate and/or mirror a tile.
+	 * @param dt Transformation to use.
+	 */
+	void Transform(DirTransform dt);
+};
+
+typedef PointT<uint16> TemplateTileIndex; ///< Index of a tile in template tiles array.
+
+/** Array of template tiles. */
+class TemplateTilesArray : public Compact2DArrayT<TemplateTile> {
+private:
+	typedef void (*TileCopyProc)(TemplateTile &dest_tile, TemplateTile &source_tile);
+	static void CopyWholeTile(TemplateTile &dest_tile, TemplateTile &source_tile) { dest_tile = source_tile; }
+	static void CopyTileHeight(TemplateTile &dest_tile, TemplateTile &source_tile) { dest_tile.height = source_tile.height; }
+
+	template <TemplateTilesArray::TileCopyProc Ttile_copy_proc>
+	void TransformIndices(TemplateTilesArray *transformed, TemplateTileIndex first, TemplateTileIndex last, const AffineMap<int16> &map);
+
+public:
+	TemplateTilesArray() { }
+	TemplateTilesArray(uint width, uint height) : Compact2DArrayT<TemplateTile>(width, height) { }
+
+	AffineMap<int16> Transform(DirTransform dt);
+};
+
+class Template : public TemplateBase {
+	friend class TemplateBuilder;
+
+public:
+	class Object : public ZeroedMemoryAllocator {
+		friend class TemplateBuilder;
+
+	private:
+		Object *next;
+
+	public:
+		const TemplateObjectType object_type;
+		TemplateTileIndex tile;
+
+	protected:
+		Object(TemplateObjectType object_type) : object_type(object_type) { }
+
+	public:
+		virtual ~Object() { }
+
+		FORCEINLINE Template::Object *NextObject() { return this->next; }
+		FORCEINLINE const Template::Object *NextObject() const { return this->next; }
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class AreaObject : public Template::Object {
+	protected:
+		AreaObject(TemplateObjectType object_type) : Template::Object(object_type) { }
+
+	public:
+		DimensionT<uint16> dimension;
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class DirectedObject : public Template::Object {
+	protected:
+		DirectedObject(TemplateObjectType object_type) : Template::Object(object_type) { }
+
+	public:
+		DiagDirection direction;
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class DoubleEndedObject : public Template::Object {
+	protected:
+		DoubleEndedObject(TemplateObjectType object_type) : Template::Object(object_type) { }
+
+	public:
+		PointT<int16> other_end_offset;
+		
+		virtual void Transform(DirTransform dt);
+	};
+
+	class Bridge : public Template::DoubleEndedObject {
+	public:
+		BridgeType bridge_type;
+
+		Bridge() : Template::DoubleEndedObject(TOT_BRIDGE) { }
+	};
+
+	class Tunnel : public Template::DoubleEndedObject {
+	public:
+		Tunnel() : Template::DoubleEndedObject(TOT_TUNNEL) { }
+	};
+
+	class RailStation;
+	class RoadStop;
+	class Dock;
+	class Airport;
+	class Waypoint;
+
+	class StationPart : public Template::AreaObject {
+		friend class TemplateBuilder;
+
+	private:
+		StationPart *next_part;
+
+		template <typename Tpart_class, TemplateStationPartType Tpart_type>
+		FORCEINLINE Tpart_class *As() { return (this->part_type != Tpart_type) ? NULL : reinterpret_cast<Tpart_class*>(this); }
+
+	protected:
+		StationPart(TemplateStationPartType part_type)
+			: Template::AreaObject(TOT_STATION_PART)
+			, part_type(part_type)
+		{
+			this->dimension.width = this->dimension.height = 1;
+		}
+
+	public:
+		const TemplateStationPartType part_type;
+		TemplateStationID station_id;
+		DiagDirection direction;
+
+		FORCEINLINE StationPart *NextPart() { return this->next_part; }
+		FORCEINLINE const StationPart *NextPart() const { return this->next_part; }
+
+		FORCEINLINE Template::RailStation *AsRailStation() { return this->As<Template::RailStation, TSPT_RAIL_STATION>(); }
+		FORCEINLINE Template::RoadStop    *AsRoadStop()    { return this->As<Template::RoadStop,    TSPT_ROAD_STOP>(); }
+		FORCEINLINE Template::Airport     *AsAirport()     { return this->As<Template::Airport,     TSPT_AIRPORT>();      }
+		FORCEINLINE Template::Dock        *AsDock()        { return this->As<Template::Dock,        TSPT_DOCK>();         }
+		FORCEINLINE Template::Waypoint    *AsWaypoint()    { return this->As<Template::Waypoint,    TSPT_WAYPOINT>();     }
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class RailStation : public Template::StationPart {
+	public:
+		RailStation() : Template::StationPart(TSPT_RAIL_STATION) { }
+	};
+
+	/**
+	 * Bus or truck stop.
+	 * @note If this is a drive-through stop, proper road bits and types are set on the underlying tile.
+	 * @see TemplteTile
+	 */
+	class RoadStop : public Template::StationPart {
+	public:
+		RoadStopType road_stop_type;
+
+		RoadStop() : Template::StationPart(TSPT_ROAD_STOP) { }
+	};
+
+	class Airport : public Template::StationPart {
+	public:
+		byte airport_type;
+
+		Airport() : Template::StationPart(TSPT_AIRPORT) { }
+	};
+
+	typedef Template::SimpleStationPart<TSPT_DOCK> Dock;
+
+	/**
+	 * Waypoint.
+	 * @note Its type depends on type of underlying tile i.e. waypoint on TTT_WATER_TRANSPORT tile is a buoy.
+	 * @note Proper track is placed on the underlying tile i.e. tile under monorail waypoint contains
+	 *       TRACK_BIT_X or TRACK_BIT_Y monorail track.
+	 * @see TemplteTileType
+	 * @see TemplteTile
+	 */
+	class Waypoint : public Template::StationPart {
+	public:
+		Waypoint() : Template::StationPart(TSPT_WAYPOINT) { }
+	};
+
+	class Signal : public Template::Object {
+	public:
+		SignalType signal_type;
+		SignalVariant variant;
+		Trackdir location;
+		bool two_way;
+
+		Signal() : Template::Object(TOT_SIGNAL) { }
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class Station : public Template::Object {
+		friend class TemplateBuilder;
+
+	public:
+		struct Properties {
+			TemplateStationLayoutBits layout;
+			TemplateStationPartTypeBits has_station_of_type;
+			uint16 spread;
+			bool has_drive_through;
+		};
+
+	private:
+		Template::StationPart *parts_list;
+		uint num_parts;
+
+	public:
+		Template::Station::Properties properties;
+		TemplateStationID id;
+		const char *name;
+
+		Station() : Template::Object(TOT_STATION), parts_list(NULL), name(NULL) { }
+
+		FORCEINLINE Template::StationPart *FirstPart() { return this->parts_list; }
+
+		FORCEINLINE const Template::StationPart *FirstPart() const { return this->parts_list; }
+
+		FORCEINLINE uint NumParts() const { return this->num_parts; };
+	};
+
+	/**
+	 * Depot.
+	 * @note Type of a depot depends on the underlying tile type and road/track type i.e. monorail depot
+	 *       lies on a TTT_RAIL_TRANSPORT tile with track type set to monorail. No track bits are set.
+	 * @see TemplteTileType
+	 * @see TemplteTile
+	 */
+	class Depot : public Template::Object {
+	public:
+		Depot() : Template::Object(TOT_DEPOT) { }
+	};
+
+private:
+	TemplateTilesArray tiles;  ///< Array of template tiles (one additional row and column for heights on SE and SW borders)
+	Template::Object *objects; ///< List of template objects (bridges, stations, signals...)
+
+	/* Disallow to copy Template object (not supported) */
+	Template(const Template &template_) : TemplateBase(template_) { }
+	Template &operator = (const Template &template_) { return *this; }
+
+	void TransformTilesArrayIndices(DirTransform dt);
+
+public:
+	Template() : objects(NULL) { }
+	virtual ~Template();
+
+	FORCEINLINE const TemplateTilesArray &Tiles() const { return this->tiles; }
+	FORCEINLINE Template::Object* Objects() { return this->objects; }
+	FORCEINLINE const Template::Object* Objects() const { return this->objects; }
+
+	void Swap(Template *second);
+	virtual bool Load(const char *filename);
+	virtual bool Save(const char *filename) const;
+	virtual void Transform(DirTransform dt);
+};
+
+/** Base class for template builders. */
+class TemplateBuilder {
+private:
+	Template::Object *first_object;
+	Template::Object *last_object;
+	OrderedSmallVector<Template::Station*, 4> stations;
+
+	template <typename Tobject_class>
+	Tobject_class *AddObject(Tobject_class* object, TemplateTileIndex tile)
+	{
+		if (this->last_object == NULL) {
+			this->first_object = object;
+		} else {
+			this->last_object->next = object;
+		}
+		this->last_object = object;
+
+		object->tile = tile;
+		return object;
+	}
+
+	void SortStations();
+	void ProcessStations();
+
+protected:
+	enum BuildReadinessFlags {
+		BRF_BASIC                    = 0,
+		BRF_STATION_PROPERTIES_READY = 1 << 0,
+	};
+
+	TemplateTilesArray tiles;      ///< Tiles array for being built template
+	TemplateProperties properties; ///< Attributes for being built template
+
+	TemplateBuilder(uint width, uint height) : first_object(NULL), last_object(NULL), tiles(width + 1, height + 1) { }
+
+	virtual TemplateBuilder::BuildReadinessFlags Build() = 0;
+
+	FORCEINLINE Template::Object *FirstObject() { return this->first_object; }
+	FORCEINLINE Template::Object *LastObject() { return this->last_object; }
+
+	template <typename Tobject_class>
+	inline Tobject_class *Add(TemplateTileIndex tile);
+
+	FORCEINLINE const SmallVector<Template::Station*, 4> &Stations() { return this->stations; }
+
+	Template::Station *AddStation(Template::Station * const *pos = NULL);
+
+	void ResetObjects();
+
+public:
+	virtual ~TemplateBuilder();
+
+	void BuildTemplate(Template *out_template);
+};
+
+template <>
+inline Template::Station *TemplateBuilder::Add<Template::Station>(TemplateTileIndex tile)
+{
+	return this->AddStation();
+}
+
+template <typename Tobject_class>
+inline Tobject_class *TemplateBuilder::Add(TemplateTileIndex tile)
+{
+	return this->AddObject(new Tobject_class, tile);
+}
+
+#endif /* TEMPLATE_H */
\ No newline at end of file
diff -ibruN src/template_base.h src/template_base.h
--- src/template_base.h	1970-01-01 03:00:00.000000000 +0300
+++ src/template_base.h	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,422 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file template_base.h Base class for templates and template builders. */
+
+#ifndef TEMPLATE_BASE_H
+#define TEMPLATE_BASE_H
+
+#include "template_face.h"
+#include "map_type.h"
+#include "track_type.h"
+#include "rail_type.h"
+#include "road_type.h"
+#include "signal_type.h"
+#include "station_type.h"
+#include "bridge.h"
+#include "string_func.h"
+#include "strings_func.h"
+#include "core/alloc_type.hpp"
+#include "core/smallvec_type.hpp"
+#include "misc/compact_array.hpp"
+
+#include "table/strings.h"
+
+#include <istream>
+#include <ostream>
+
+class Template;
+class TemplateBuilder;
+
+static const uint32 TEMPLATE_VERSION = 2; ///< Major version for saved templates
+
+/** Type of template tile. */
+enum TemplateTileType {
+	TTT_BEGIN = 0,         ///< Used for iterations.
+
+	TTT_CLEAR = 0,         ///< Clear tile.
+	TTT_RAIL_TRANSPORT,    ///< Tile with rail transport infrastructure.
+	TTT_ROAD_TRANSPORT,    ///< Tile with road transport infrastructure.
+	TTT_WATER_TRANSPORT,   ///< Tile with water transport infrastructure.
+	TTT_AIR_TRANSPORT,     ///< Tile with air transport infrastructure.
+	TTT_RAIL_X_ROAD_Y,     ///< Crossing with railway along x-axis and road along y-axis.
+	TTT_RAIL_Y_ROAD_X,     ///< Crossing with road along x-axis and railway along y-axis.
+
+	TTT_END                ///< Used for iterations.
+};
+typedef SimpleTinyEnumT<TemplateTileType, byte> TemplateTileTypeByte;
+
+typedef StationID TemplateStationID; ///< ID of template station.
+
+static const TemplateStationID INVALID_TEMPLATE_STATION_ID = 0xFFFF; ///< Invalid ID of template station.
+
+struct TMPL_BuildException { };
+
+/** Structure describing one tile of template tiles array. */
+struct TemplateTile {
+	TemplateTileTypeByte type; ///< Type of a tile.
+	uint8 height;              ///< Height of a tile.
+
+	union {
+		struct {
+			byte m0; ///< Rail type for rail and crossing tile, road bits pack for road tile.
+			byte m1; ///< Rail bits for rail tile, road types for road and crossing tile.
+		};
+
+		struct {
+			RailTypeByte type;  ///< Type of rail track or rail transport building.
+			TrackBitsByte bits; ///< Rail track bits.
+		}
+		rail; ///< Additional tile data if tile is of type TTT_RAIL_TRANSPORT.
+
+		struct {
+			RoadBitsPackByte bits; ///< Road bits of all road types.
+			RoadTypesByte types;   ///< Type of road.
+		}
+		road; ///< Additional tile data if tile is of type TTT_ROAD_TRANSPORT.
+
+		struct {
+			RailTypeByte rail_type;   ///< Type of rail track.
+			RoadTypesByte road_types; ///< Type of road.
+		}
+		crossing; ///< Additional tile data if tile is of type TTT_RAIL_X_ROAD_Y or TTT_RAIL_Y_ROAD_X.
+	};
+
+	/**
+	 * Rotate and/or mirror a tile.
+	 * @param dt Transformation to use.
+	 */
+	void Transform(DirTransform dt);
+};
+
+typedef PointT<uint16> TemplateTileIndex; ///< Index of a tile in template tiles array.
+
+/** Array of template tiles. */
+class TemplateTilesArray : public Compact2DArray<TemplateTile> {
+private:
+	typedef void (*TileCopyProc)(TemplateTile &dest_tile, const TemplateTile &source_tile);
+
+	template <TemplateTilesArray::TileCopyProc Ttile_copy_proc>
+	void TransformIndices(TemplateTilesArray *transformed, TemplateTileIndex first, TemplateTileIndex last, const AffineMap<int16> &map);
+
+public:
+	TemplateTilesArray() { }
+	TemplateTilesArray(uint width, uint height) : Compact2DArray<TemplateTile>(width, height) { }
+
+	AffineMap<int16> Transform(DirTransform dt);
+};
+
+class Template : public TemplateFace {
+	friend class TemplateBuilder;
+
+public:
+	class Object : public ZeroedMemoryAllocator {
+		friend class TemplateBuilder;
+
+	private:
+		Object *next;
+
+	public:
+		const TemplateObjectType object_type;
+		TemplateTileIndex tile; ///< Base tile of an object.
+
+	protected:
+		Object(TemplateObjectType object_type) : object_type(object_type) { }
+
+	public:
+		virtual ~Object() { }
+
+		/**
+		 * Transform template object by a given DirTransform.
+		 * @param dt Transformation to use.
+		 */
+		virtual void Transform(DirTransform dt) { }
+
+		FORCEINLINE Template::Object *NextObject() { return this->next; }
+		FORCEINLINE const Template::Object *NextObject() const { return this->next; }
+	};
+
+	class AreaObject : public Template::Object {
+	protected:
+		AreaObject(TemplateObjectType object_type) : Template::Object(object_type) { }
+
+	public:
+		typedef PointDimensionT<int16, uint16> AreaType;
+
+		AreaType area; ///< Position (relative to base tile) and size of the rectangular area.
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class DirectedObject : public Template::Object {
+	protected:
+		DirectedObject(TemplateObjectType object_type) : Template::Object(object_type) { }
+
+	public:
+		DiagDirection direction;
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class DoubleEndedObject : public Template::Object {
+	protected:
+		DoubleEndedObject(TemplateObjectType object_type) : Template::Object(object_type) { }
+
+	public:
+		PointT<int16> other_end_offset;
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class Bridge : public Template::DoubleEndedObject {
+	public:
+		BridgeType bridge_type;
+
+		Bridge() : Template::DoubleEndedObject(TOT_BRIDGE) { }
+	};
+
+	class Tunnel : public Template::DoubleEndedObject {
+	public:
+		Tunnel() : Template::DoubleEndedObject(TOT_TUNNEL) { }
+	};
+
+	class RailStation;
+	class RoadStop;
+	class Dock;
+	class Airport;
+	class Waypoint;
+
+	class StationPart : public Template::AreaObject {
+		friend class TemplateBuilder;
+
+	private:
+		StationPart *next_part;
+
+		template <typename Tpart_class, TemplateStationPartType Tpart_type>
+		FORCEINLINE Tpart_class *As() { return (this->part_type != Tpart_type) ? NULL : reinterpret_cast<Tpart_class*>(this); }
+
+	protected:
+		StationPart(TemplateStationPartType part_type)
+			: Template::AreaObject(TOT_STATION_PART)
+			, part_type(part_type)
+		{
+			this->area.width = this->area.height = 1;
+		}
+
+	public:
+		const TemplateStationPartType part_type;
+		TemplateStationID station_id;
+		DiagDirection direction;
+
+		FORCEINLINE StationPart *NextPart() { return this->next_part; }
+		FORCEINLINE const StationPart *NextPart() const { return this->next_part; }
+
+		FORCEINLINE Template::RailStation *AsRailStation() { return this->As<Template::RailStation, TSPT_RAIL_STATION>(); }
+		FORCEINLINE Template::RoadStop    *AsRoadStop()    { return this->As<Template::RoadStop,    TSPT_ROAD_STOP>(); }
+		FORCEINLINE Template::Dock        *AsDock()        { return this->As<Template::Dock,        TSPT_DOCK>();         }
+		FORCEINLINE Template::Airport     *AsAirport()     { return this->As<Template::Airport,     TSPT_AIRPORT>();      }
+		FORCEINLINE Template::Waypoint    *AsWaypoint()    { return this->As<Template::Waypoint,    TSPT_WAYPOINT>();     }
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class RailStation : public Template::StationPart {
+	public:
+		RailStation() : Template::StationPart(TSPT_RAIL_STATION) { }
+	};
+
+	/**
+	 * Bus or truck stop.
+	 * If this is a drive-through stop, proper road bits and types are set on the underlying tile.
+	 * Otherwise 
+	 * @see TemplteTile
+	 */
+	class RoadStop : public Template::StationPart {
+	public:
+		RoadStopType road_stop_type;
+
+		RoadStop() : Template::StationPart(TSPT_ROAD_STOP) { }
+	};
+
+	class Dock : public Template::StationPart {
+	public:
+		Dock() : Template::StationPart(TSPT_DOCK) { }
+	};
+
+	class Airport : public Template::StationPart {
+	public:
+		byte airport_type;
+
+		Airport() : Template::StationPart(TSPT_AIRPORT) { }
+	};
+
+	/**
+	 * Waypoint.
+	 * Waypoint type depends on the underlying tile i.e. monorail waypoint lies on
+	 * a TTT_RAIL_TRANSPORT tile with TRACK_BIT_X or TRACK_BIT_Y monorail track on it.
+	 *
+	 * @see TemplteTileType
+	 * @see TemplteTile
+	 */
+	class Waypoint : public Template::StationPart {
+	public:
+		Waypoint() : Template::StationPart(TSPT_WAYPOINT) { }
+	};
+
+	class Signal : public Template::Object {
+	public:
+		SignalType signal_type;
+		SignalVariant variant;
+		Trackdir location;
+		bool two_way;
+
+		Signal() : Template::Object(TOT_SIGNAL) { }
+
+		virtual void Transform(DirTransform dt);
+	};
+
+	class Station : public Template::Object {
+		friend class TemplateBuilder;
+
+	public:
+		struct Properties {
+			TemplateStationLayoutBits layout;
+			TemplateStationPartTypeBits has_station_of_type;
+			uint16 spread;
+			bool has_drive_through;
+		};
+
+	private:
+		Template::StationPart *parts_list;
+		uint num_parts;
+
+	public:
+		Template::Station::Properties properties;
+		TemplateStationID id;
+		char *name;
+
+		Station() : Template::Object(TOT_STATION) { }
+		virtual ~Station() { free(this->name); }
+
+		void SetName(const char *name)
+		{
+			free(this->name);
+			this->name = StrEmpty(name) ? NULL : strdup(name);
+		}
+
+		FORCEINLINE Template::StationPart *FirstPart() { return this->parts_list; }
+
+		FORCEINLINE const Template::StationPart *FirstPart() const { return this->parts_list; }
+
+		FORCEINLINE uint NumParts() const { return this->num_parts; };
+	};
+
+	/**
+	 * Depot.
+	 * @note Type of a depot depends on the underlying tile i.e. monorail depot lies on
+	 *       TTT_RAIL_TRANSPORT tile with track type set to monorail (no track bits set).
+	 * @see TemplteTileType
+	 * @see TemplteTile
+	 */
+	class Depot : public Template::DirectedObject {
+	public:
+		Depot() : Template::DirectedObject(TOT_DEPOT) { }
+	};
+
+private:
+	TemplateTilesArray tiles;  ///< Array of template tiles (one additional row and column for heights on SE and SW borders)
+	Template::Object *objects; ///< List of template objects (bridges, stations, signals...)
+	Bounds objects_bounds;
+
+	/* Disallow to copy Template object (not supported) */
+	Template(const Template &template_) : TemplateFace(template_) { }
+	Template &operator = (const Template &template_) { return *this; }
+
+	void TransformTilesArrayIndices(DirTransform dt);
+
+public:
+	Template() : objects(NULL) { }
+	virtual ~Template();
+
+	FORCEINLINE const TemplateTilesArray &Tiles() const { return this->tiles; }
+	FORCEINLINE Template::Object* Objects() { return this->objects; }
+	FORCEINLINE const Template::Object* Objects() const { return this->objects; }
+
+	void Swap(Template *second);
+	virtual bool Load(const char *filename);
+	virtual bool Save(const char *filename) const;
+	virtual void Transform(DirTransform dt);
+};
+
+/** Base class for template builders. */
+class TemplateBuilder {
+private:
+	Template::Object *first_object;
+	Template::Object *last_object;
+	OrderedSmallVector<Template::Station*, 4> stations;
+
+	template <typename Tobject_class>
+	Tobject_class *AddObject(Tobject_class* object, TemplateTileIndex tile)
+	{
+		if (this->last_object == NULL) {
+			this->first_object = object;
+		} else {
+			this->last_object->next = object;
+		}
+		this->last_object = object;
+
+		object->tile = tile;
+		return object;
+	}
+
+	void SortStations();
+	void ProcessStations();
+
+protected:
+	enum BuildReadinessFlags {
+		BRF_BASIC                = 0,
+		BRF_PROPERTIES_READY     = 1 << 0,
+	};
+
+	TemplateTilesArray tiles;      ///< Tiles array for being built template
+	TemplateProperties properties; ///< Attributes for being built template
+
+	TemplateBuilder() : first_object(NULL), last_object(NULL) { }
+
+	virtual TemplateBuilder::BuildReadinessFlags Build() = 0;
+
+	FORCEINLINE Template::Object *FirstObject() { return this->first_object; }
+	FORCEINLINE Template::Object *LastObject() { return this->last_object; }
+
+	template <typename Tobject_class>
+	inline Tobject_class *Add(TemplateTileIndex tile);
+
+	FORCEINLINE const SmallVector<Template::Station*, 4> &Stations() { return this->stations; }
+
+	Template::Station *AddStation(Template::Station * const *pos = NULL);
+
+	void FreeObjects();
+
+public:
+	virtual ~TemplateBuilder();
+
+	void BuildTemplate(Template *out_template);
+};
+
+template <>
+inline Template::Station *TemplateBuilder::Add<Template::Station>(TemplateTileIndex tile)
+{
+	return this->AddStation();
+}
+
+template <typename Tobject_class>
+inline Tobject_class *TemplateBuilder::Add(TemplateTileIndex tile)
+{
+	return this->AddObject(new Tobject_class, tile);
+}
+
+#endif /* TEMPLATE_BASE_H */
diff -ibruN src/template_face.h src/template_face.h
--- src/template_face.h	1970-01-01 03:00:00.000000000 +0300
+++ src/template_face.h	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,40 @@
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file template_face.h Base class of the Template class, mostly interface. */
+
+#ifndef TEMPLATE_FACE_H
+#define TEMPLATE_FACE_H
+
+#include "direction_type.h"
+#include "core/mem_func.hpp"
+#include "template_type.h"
+
+class TemplateFace {
+protected:
+	uint width;
+	uint height;
+	TemplateProperties properties; ///< Template properties.
+
+	TemplateFace() : width(0), height(0) { MemSetT(&this->properties, 0); }
+
+public:
+	/** Template width */
+	FORCEINLINE uint Width() const { return this->width; }
+
+	/** Template height */
+	FORCEINLINE uint Height() const { return this->height; }
+
+	/** Template properties */
+	FORCEINLINE const TemplateProperties &Properties() const { return this->properties; }
+
+	virtual bool Load(const char *filename) = 0;
+	virtual bool Save(const char *filename) const = 0;
+	virtual void Transform(DirTransform dt) = 0;
+};
+
+#endif /* TEMPLATE_FACE_H */
diff -ibruN src/template_type.h src/template_type.h
--- src/template_type.h	1970-01-01 03:00:00.000000000 +0300
+++ src/template_type.h	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,84 @@
+/* $Id: signs_type.h 17248 2009-08-21 20:21:05Z rubidium $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file signs_type.h Types related to the templates. */
+
+#ifndef TEMPLATE_TYPE_H
+#define TEMPLATE_TYPE_H
+
+#include "core/enum_type.hpp"
+
+enum TemplateObjectType {
+	TOT_BEGIN,
+	TOT_BRIDGE = TOT_BEGIN,
+	TOT_TUNNEL,
+	TOT_STATION,
+	TOT_SIGNAL,
+	TOT_DEPOT,
+	TOT_STATION_PART,
+
+	TOT_END
+};
+
+enum TemplateObjectTypeBits {
+	TOTB_NONE     = 0,
+	TOTB_BRIDGE   = 1 << TOT_BRIDGE,
+	TOTB_TUNNEL   = 1 << TOT_TUNNEL,
+	TOTB_STATION  = 1 << TOT_STATION,
+	TOTB_SIGNAL   = 1 << TOT_SIGNAL,
+	TOTB_DEPOT    = 1 << TOT_DEPOT,
+};
+DECLARE_ENUM_AS_BIT_SET(TemplateObjectTypeBits);
+
+enum TemplateStationPartType {
+	TSPT_BEGIN,
+	TSPT_RAIL_STATION = TSPT_BEGIN,
+	TSPT_ROAD_STOP,
+	TSPT_AIRPORT,
+	TSPT_DOCK,
+	TSPT_WAYPOINT,
+	TSPT_END
+};
+typedef SimpleTinyEnumT<TemplateStationPartType, byte> TemplateStationPartTypeByte;
+
+enum TemplateStationPartTypeBits {
+	TSPTB_NONE         = 0,
+	TSPTB_RAIL_STATION = 1 << TSPT_RAIL_STATION,
+	TSPTB_ROAD_STATION = 1 << TSPT_ROAD_STOP,
+	TSPTB_AIRPORT      = 1 << TSPT_AIRPORT,
+	TSPTB_DOCK         = 1 << TSPT_DOCK,
+	TSPTB_WAYPOINT     = 1 << TSPT_WAYPOINT,
+};
+DECLARE_ENUM_AS_BIT_SET(TemplateStationPartTypeBits);
+typedef SimpleTinyEnumT<TemplateStationPartTypeBits, byte> TemplateStationPartTypeBitsByte;
+
+enum TemplateStationLayout {
+	TSL_NONUNIFORM,
+	TSL_DISTANT_JOIN,
+};
+
+enum TemplateStationLayoutBits {
+	TSLB_BEGIN        = 0,
+	TSLB_NONE         = 0,
+	TSLB_NONUNIFORM   = 1 << TSL_NONUNIFORM,
+	TSLB_DISTANT_JOIN = 1 << TSL_DISTANT_JOIN,
+	TSLB_ALL          = TSLB_NONUNIFORM | TSLB_DISTANT_JOIN,
+	TSLB_END
+};
+DECLARE_ENUM_AS_BIT_SET(TemplateStationLayoutBits);
+
+struct TemplateProperties {
+	TemplateObjectTypeBits object_types;       ///< Set of types of objects contained in a template
+	TemplateStationPartTypeBits station_types; ///< Set of types of station parts contained in a template
+	TemplateStationLayoutBits station_layouts; ///< Set of station layouts existing in a template
+	uint max_station_spread;                   ///< Spread of the most spreaded station
+	bool adjacent_stations;                    ///< If template contains adjacent stations
+};
+
+#endif /* TEMPLATE_TYPE_H */
diff -ibruN src/tile_type.h src/tile_type.h
--- src/tile_type.h	2010-01-15 19:41:15.000000000 +0300
+++ src/tile_type.h	2010-06-20 15:22:46.000000000 +0400
@@ -34,7 +34,8 @@
  * @note A railway with a crossing street is marked as MP_ROAD.
  */
 enum TileType {
-	MP_CLEAR,               ///< A tile without any structures, i.e. grass, rocks, farm fields etc.
+	MP_BEGIN,               ///< For iterations.
+	MP_CLEAR = MP_BEGIN,    ///< A tile without any structures, i.e. grass, rocks, farm fields etc.
 	MP_RAILWAY,             ///< A railway
 	MP_ROAD,                ///< A tile with road (or tram tracks)
 	MP_HOUSE,               ///< A house by a town
@@ -45,6 +46,7 @@
 	MP_INDUSTRY,            ///< Part of an industry
 	MP_TUNNELBRIDGE,        ///< Tunnel entry/exit and bridge heads
 	MP_UNMOVABLE,           ///< Contains an object with cannot be removed like transmitters
+	MP_END                  ///< For iterations.
 };
 
 /**
diff -ibruN src/toolbar_gui.cpp src/toolbar_gui.cpp
--- src/toolbar_gui.cpp	2010-03-16 23:54:26.000000000 +0300
+++ src/toolbar_gui.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -43,6 +43,8 @@
 #include "company_base.h"
 #include "smallmap_gui.h"
 #include "graph_gui.h"
+#include "clipboard.h"
+#include "command_queue.h"
 
 #include "network/network.h"
 #include "network/network_gui.h"
@@ -1213,6 +1215,19 @@
 	ToolbarSwitchClick,
 };
 
+/* TODO: temporary, remove when clipboard toolbar is done */
+void PlaceProc_Copy(TileIndex tile)
+{
+	VpStartPlaceSizing(tile, VPM_X_AND_Y_LIMITED, DDSP_COPY_TO_CLIPBOARD);
+	VpSetPlaceSizingLimit(255);
+}
+
+/* TODO: temporary, remove when clipboard toolbar is done */
+void PlaceProc_Paste(TileIndex tile)
+{
+	_clipboard.Paste(tile);
+}
+
 struct MainToolbarWindow : Window {
 	MainToolbarWindow(const WindowDesc *desc) : Window()
 	{
@@ -1291,11 +1306,59 @@
 			case 'Q': case 'W': case 'E': case 'D': ShowTerraformToolbarWithTool(key, keycode); break;
 			case 'M': ShowSmallMap(); break;
 			case 'V': ShowExtraViewPortWindow(); break;
+
+			/* TODO: restore when clipboard toolbar is done
+			case WKC_CTRL | 'A': CommandQueue::ClearCommandQueue(); break; // Stop pasting in multiplayer
+			case WKC_CTRL | 'C': case WKC_CTRL | WKC_INSERT: ShowCopyPasteToolbar(6); break; // Invoke Copy
+			case WKC_CTRL | 'V': case WKC_SHIFT | WKC_INSERT: ShowCopyPasteToolbar(7); break; // Invoke Paste */
+
+			/* TODO: temporary, remove when clipboard toolbar is done */
+			case WKC_CTRL | WKC_LEFT: _clipboard.Content()->Transform(DT_ROTATE_90_LEFT); break;
+			case WKC_CTRL | WKC_RIGHT: _clipboard.Content()->Transform(DT_ROTATE_90_RIGHT); break;
+			case WKC_CTRL | WKC_UP: _clipboard.Content()->Transform(DT_REFLECT_NE_SW); break;
+			case WKC_CTRL | WKC_DOWN: _clipboard.Content()->Transform(DT_REFLECT_NW_SE); break;
+			case WKC_CTRL | 'C':
+			case WKC_CTRL | WKC_INSERT:
+				ResetObjectToPlace();
+				SetObjectToPlace(SPR_CURSOR_COPY, PAL_NONE, HT_RECT, this->window_class, this->window_number);
+				_place_proc = PlaceProc_Copy;
+				SetTileSelectSize(1, 1);
+				break;
+			case WKC_CTRL | 'V':
+			case WKC_SHIFT | WKC_INSERT:
+				if (_clipboard.Content()->Width() <= 0) break;
+				ResetObjectToPlace();
+				SetObjectToPlace(SPR_CURSOR_PASTE, PAL_NONE, HT_POINT, this->window_class, this->window_number);
+				_place_proc = PlaceProc_Paste;
+				SetTileSelectSize(_clipboard.Content()->Width() + 1, _clipboard.Content()->Height() + 1);
+				break;
+
 			default: return ES_NOT_HANDLED;
 		}
 		return ES_HANDLED;
 	}
 
+	/* TODO: temporary, remove when clipboard toolbar is done */
+	virtual void OnPlaceDrag(ViewportPlaceMethod select_method, ViewportDragDropSelectionProcess select_proc, Point pt)
+	{
+		VpSelectTilesWithMethod(pt.x, pt.y, select_method);
+	}
+
+	/* TODO: temporary, remove when clipboard toolbar is done */
+	virtual void OnPlaceMouseUp(ViewportPlaceMethod select_method, ViewportDragDropSelectionProcess select_proc, Point pt, TileIndex start_tile, TileIndex end_tile)
+	{
+		if (pt.x != -1) {
+			switch (select_proc) {
+				case DDSP_COPY_TO_CLIPBOARD:
+					ResetObjectToPlace();
+					_clipboard.Copy(start_tile, end_tile);
+					break;
+				default:
+					break;
+			}
+		}
+	}
+
 	virtual void OnPlaceObject(Point pt, TileIndex tile)
 	{
 		_place_proc(tile);
diff -ibruN src/track_func.h src/track_func.h
--- src/track_func.h	2010-01-15 19:41:15.000000000 +0300
+++ src/track_func.h	2010-06-20 15:22:46.000000000 +0400
@@ -14,9 +14,21 @@
 
 #include "core/bitmath_func.hpp"
 #include "track_type.h"
+#include "direction_func.h"
 #include "slope_func.h"
 
 /**
+ * Iterate through each set Track in a TrackBits value.
+ * For more informations see FOR_EACH_SET_BIT_EX.
+ *
+ * @param var Loop index variable that stores fallowing set track. Must be of type Track.
+ * @param track_bits The value to iterate through (any expression).
+ *
+ * @see FOR_EACH_SET_BIT_EX
+ */
+#define FOR_EACH_SET_TRACK(var, track_bits) FOR_EACH_SET_BIT_EX(Track, var, TrackBits, track_bits)
+
+/**
  * Convert an Axis to the corresponding Track
  * AXIS_X -> TRACK_X
  * AXIS_Y -> TRACK_Y
@@ -644,4 +656,41 @@
 	return HasBit(_uphill_trackdirs[RemoveHalftileSlope(slope)], dir);
 }
 
+/**
+ * Transform Track by given transformation.
+ * @param track Track to transform.
+ * @param dt Transformation to use.
+ * @return Transformed Track.
+ */
+static inline Track TransformTrack(Track track, DirTransform dt)
+{
+	extern const byte _track_transformation_map[DT_END][TRACK_END];
+	return (Track)_track_transformation_map[dt][track];
+}
+
+/**
+ * Transform TrackBits by given transformation.
+ * @param track_bits TrackBits to transform.
+ * @param dt Transformation to use.
+ * @return Transformed TrackBits.
+ */
+static inline TrackBits TransformTrackBits(TrackBits track_bits, DirTransform dt)
+{
+	extern const byte _track_bits_transformation_map[DT_END][1 << TRACK_END];
+	/* Transfrom track bits using lookup table. Only bits of mask TRACK_BIT_ALL are
+	 * trasformed as they are related to tracks, other bits are special thus left unchanged. */
+	return (track_bits & ~TRACK_BIT_ALL) | (TrackBits)_track_bits_transformation_map[dt][track_bits & TRACK_BIT_ALL];
+}
+
+/**
+ * Transform Trackdir by given transformation.
+ * @param trackdir Trackdir to transform.
+ * @param dt Transformation to use.
+ * @return Transformed Trackdir.
+ */
+static inline Trackdir TransformTrackdir(Trackdir trackdir, DirTransform dt)
+{
+	return TrackExitdirToTrackdir(TransformTrack(TrackdirToTrack(trackdir), dt), TransformDiagDir(TrackdirToExitdir(trackdir), dt));
+}
+
 #endif /* TRACK_FUNC_H */
diff -ibruN src/transform_tables.cpp src/transform_tables.cpp
--- src/transform_tables.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/transform_tables.cpp	2010-06-20 15:22:46.000000000 +0400
@@ -0,0 +1,79 @@
+/** @file transformations.cpp Lookup tables for transformations. */
+
+#include "stdafx.h"
+#include "track_func.h"
+#include "road_func.h"
+
+/** Lookup table to transform a Track by a given DirTransform. */
+extern const byte _track_transformation_map[DT_END][TRACK_END] = {
+	{ TRACK_X, TRACK_Y, TRACK_UPPER, TRACK_LOWER, TRACK_LEFT,  TRACK_RIGHT }, // DT_IDENTITY
+	{ TRACK_Y, TRACK_X, TRACK_RIGHT, TRACK_LEFT,  TRACK_UPPER, TRACK_LOWER }, // DT_ROTATE_90_RIGHT
+	{ TRACK_X, TRACK_Y, TRACK_LOWER, TRACK_UPPER, TRACK_RIGHT, TRACK_LEFT  }, // DT_ROTATE_180
+	{ TRACK_Y, TRACK_X, TRACK_LEFT,  TRACK_RIGHT, TRACK_LOWER, TRACK_UPPER }, // DT_ROTATE_90_LEFT
+	{ TRACK_X, TRACK_Y, TRACK_RIGHT, TRACK_LEFT,  TRACK_LOWER, TRACK_UPPER }, // DT_REFLECT_NE_SW
+	{ TRACK_Y, TRACK_X, TRACK_LOWER, TRACK_UPPER, TRACK_LEFT,  TRACK_RIGHT }, // DT_REFLECT_W_E
+	{ TRACK_X, TRACK_Y, TRACK_LEFT,  TRACK_RIGHT, TRACK_UPPER, TRACK_LOWER }, // DT_REFLECT_NW_SE
+	{ TRACK_Y, TRACK_X, TRACK_UPPER, TRACK_LOWER, TRACK_RIGHT, TRACK_LEFT  }, // DT_REFLECT_N_S
+};
+
+/** Lookup table to transform a TrackBits by a given DirTransform. */
+extern const byte _track_bits_transformation_map[DT_END][1 << TRACK_END] = {
+	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f },
+	{ 0x00, 0x02, 0x01, 0x03, 0x20, 0x22, 0x21, 0x23, 0x10, 0x12, 0x11, 0x13, 0x30, 0x32, 0x31, 0x33, 0x04, 0x06, 0x05, 0x07, 0x24, 0x26, 0x25, 0x27, 0x14, 0x16, 0x15, 0x17, 0x34, 0x36, 0x35, 0x37, 0x08, 0x0a, 0x09, 0x0b, 0x28, 0x2a, 0x29, 0x2b, 0x18, 0x1a, 0x19, 0x1b, 0x38, 0x3a, 0x39, 0x3b, 0x0c, 0x0e, 0x0d, 0x0f, 0x2c, 0x2e, 0x2d, 0x2f, 0x1c, 0x1e, 0x1d, 0x1f, 0x3c, 0x3e, 0x3d, 0x3f },
+	{ 0x00, 0x01, 0x02, 0x03, 0x08, 0x09, 0x0a, 0x0b, 0x04, 0x05, 0x06, 0x07, 0x0c, 0x0d, 0x0e, 0x0f, 0x20, 0x21, 0x22, 0x23, 0x28, 0x29, 0x2a, 0x2b, 0x24, 0x25, 0x26, 0x27, 0x2c, 0x2d, 0x2e, 0x2f, 0x10, 0x11, 0x12, 0x13, 0x18, 0x19, 0x1a, 0x1b, 0x14, 0x15, 0x16, 0x17, 0x1c, 0x1d, 0x1e, 0x1f, 0x30, 0x31, 0x32, 0x33, 0x38, 0x39, 0x3a, 0x3b, 0x34, 0x35, 0x36, 0x37, 0x3c, 0x3d, 0x3e, 0x3f },
+	{ 0x00, 0x02, 0x01, 0x03, 0x10, 0x12, 0x11, 0x13, 0x20, 0x22, 0x21, 0x23, 0x30, 0x32, 0x31, 0x33, 0x08, 0x0a, 0x09, 0x0b, 0x18, 0x1a, 0x19, 0x1b, 0x28, 0x2a, 0x29, 0x2b, 0x38, 0x3a, 0x39, 0x3b, 0x04, 0x06, 0x05, 0x07, 0x14, 0x16, 0x15, 0x17, 0x24, 0x26, 0x25, 0x27, 0x34, 0x36, 0x35, 0x37, 0x0c, 0x0e, 0x0d, 0x0f, 0x1c, 0x1e, 0x1d, 0x1f, 0x2c, 0x2e, 0x2d, 0x2f, 0x3c, 0x3e, 0x3d, 0x3f },
+	{ 0x00, 0x01, 0x02, 0x03, 0x20, 0x21, 0x22, 0x23, 0x10, 0x11, 0x12, 0x13, 0x30, 0x31, 0x32, 0x33, 0x08, 0x09, 0x0a, 0x0b, 0x28, 0x29, 0x2a, 0x2b, 0x18, 0x19, 0x1a, 0x1b, 0x38, 0x39, 0x3a, 0x3b, 0x04, 0x05, 0x06, 0x07, 0x24, 0x25, 0x26, 0x27, 0x14, 0x15, 0x16, 0x17, 0x34, 0x35, 0x36, 0x37, 0x0c, 0x0d, 0x0e, 0x0f, 0x2c, 0x2d, 0x2e, 0x2f, 0x1c, 0x1d, 0x1e, 0x1f, 0x3c, 0x3d, 0x3e, 0x3f },
+	{ 0x00, 0x02, 0x01, 0x03, 0x08, 0x0a, 0x09, 0x0b, 0x04, 0x06, 0x05, 0x07, 0x0c, 0x0e, 0x0d, 0x0f, 0x10, 0x12, 0x11, 0x13, 0x18, 0x1a, 0x19, 0x1b, 0x14, 0x16, 0x15, 0x17, 0x1c, 0x1e, 0x1d, 0x1f, 0x20, 0x22, 0x21, 0x23, 0x28, 0x2a, 0x29, 0x2b, 0x24, 0x26, 0x25, 0x27, 0x2c, 0x2e, 0x2d, 0x2f, 0x30, 0x32, 0x31, 0x33, 0x38, 0x3a, 0x39, 0x3b, 0x34, 0x36, 0x35, 0x37, 0x3c, 0x3e, 0x3d, 0x3f },
+	{ 0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x13, 0x20, 0x21, 0x22, 0x23, 0x30, 0x31, 0x32, 0x33, 0x04, 0x05, 0x06, 0x07, 0x14, 0x15, 0x16, 0x17, 0x24, 0x25, 0x26, 0x27, 0x34, 0x35, 0x36, 0x37, 0x08, 0x09, 0x0a, 0x0b, 0x18, 0x19, 0x1a, 0x1b, 0x28, 0x29, 0x2a, 0x2b, 0x38, 0x39, 0x3a, 0x3b, 0x0c, 0x0d, 0x0e, 0x0f, 0x1c, 0x1d, 0x1e, 0x1f, 0x2c, 0x2d, 0x2e, 0x2f, 0x3c, 0x3d, 0x3e, 0x3f },
+	{ 0x00, 0x02, 0x01, 0x03, 0x04, 0x06, 0x05, 0x07, 0x08, 0x0a, 0x09, 0x0b, 0x0c, 0x0e, 0x0d, 0x0f, 0x20, 0x22, 0x21, 0x23, 0x24, 0x26, 0x25, 0x27, 0x28, 0x2a, 0x29, 0x2b, 0x2c, 0x2e, 0x2d, 0x2f, 0x10, 0x12, 0x11, 0x13, 0x14, 0x16, 0x15, 0x17, 0x18, 0x1a, 0x19, 0x1b, 0x1c, 0x1e, 0x1d, 0x1f, 0x30, 0x32, 0x31, 0x33, 0x34, 0x36, 0x35, 0x37, 0x38, 0x3a, 0x39, 0x3b, 0x3c, 0x3e, 0x3d, 0x3f },
+};
+/* Helper code to generated abowe table:
+
+	cout.fill('0');
+	for (int transformation = DT_BEGIN; transformation != DT_END; transformation++) {
+		cout << "\t{ ";
+		for (int bits = 0; bits < (1 << TRACK_END); bits++) {
+			if (bits != 0) cout << ", ";
+			int transformed_bits = 0;
+			for (int track = TRACK_BEGIN; track != TRACK_END; track++) {
+				if (bits & (1 << track)) {
+					transformed_bits |= 1 << (_track_transformation_map[transformation][track]);
+				}
+			}
+			cout << "0x";
+			cout.width(2);
+			cout << hex << transformed_bits;
+		}
+		cout << " },\n";
+	}
+*/
+
+/** Lookup table to transform a RoadBits by a given DirTransform. */
+extern const byte _road_bits_transformation_map[DT_END][ROAD_ALL + 1] = {
+	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f },
+	{ 0x00, 0x08, 0x01, 0x09, 0x02, 0x0a, 0x03, 0x0b, 0x04, 0x0c, 0x05, 0x0d, 0x06, 0x0e, 0x07, 0x0f },
+	{ 0x00, 0x04, 0x08, 0x0c, 0x01, 0x05, 0x09, 0x0d, 0x02, 0x06, 0x0a, 0x0e, 0x03, 0x07, 0x0b, 0x0f },
+	{ 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f },
+	{ 0x00, 0x04, 0x02, 0x06, 0x01, 0x05, 0x03, 0x07, 0x08, 0x0c, 0x0a, 0x0e, 0x09, 0x0d, 0x0b, 0x0f },
+	{ 0x00, 0x02, 0x01, 0x03, 0x08, 0x0a, 0x09, 0x0b, 0x04, 0x06, 0x05, 0x07, 0x0c, 0x0e, 0x0d, 0x0f },
+	{ 0x00, 0x01, 0x08, 0x09, 0x04, 0x05, 0x0c, 0x0d, 0x02, 0x03, 0x0a, 0x0b, 0x06, 0x07, 0x0e, 0x0f },
+	{ 0x00, 0x08, 0x04, 0x0c, 0x02, 0x0a, 0x06, 0x0e, 0x01, 0x09, 0x05, 0x0d, 0x03, 0x0b, 0x07, 0x0f },
+};
+/* Helper code to generated abowe table:
+
+	cout.fill('0');
+	for (DirTransform transformation = DT_BEGIN; transformation != DT_END; transformation = (DirTransform)(transformation + 1)) {
+		cout << "\t{ ";
+		for (int bits = 0; bits <= ROAD_ALL; bits++) {
+			if (bits != 0) cout << ", ";
+			int transformed_bits = 0;
+			for (int road = 0; road < 4; road++) {
+				if (bits & (1 << road)) transformed_bits |= 1 << (3 - transformation * (DiagDirection)(3 - road));
+			}
+			cout << "0x";
+			cout.width(2);
+			cout << hex << transformed_bits;
+		}
+		cout << " },\n";
+	}
+*/
diff -ibruN src/viewport_type.h src/viewport_type.h
--- src/viewport_type.h	2010-02-02 02:13:15.000000000 +0300
+++ src/viewport_type.h	2010-06-20 15:22:46.000000000 +0400
@@ -109,6 +109,9 @@
 	DDSP_PLACE_ROAD_X_DIR,     ///< Road placement (X axis)
 	DDSP_PLACE_ROAD_Y_DIR,     ///< Road placement (Y axis)
 	DDSP_PLACE_AUTOROAD,       ///< Road placement (auto)
+
+	/* Clipboard */
+	DDSP_COPY_TO_CLIPBOARD,
 };
 
 #endif /* VIEWPORT_TYPE_H */
diff -ibruN src/window_type.h src/window_type.h
--- src/window_type.h	2010-01-15 19:41:15.000000000 +0300
+++ src/window_type.h	2010-06-20 15:22:46.000000000 +0400
@@ -106,6 +106,7 @@
 	WC_AI_DEBUG,
 	WC_AI_LIST,
 	WC_AI_SETTINGS,
+	WC_CLIPBOARD,
 
 	WC_INVALID = 0xFFFF
 };
