diff -uNr gexiv2.old2/gexiv2-metadata.cpp gexiv2/gexiv2-metadata.cpp
--- gexiv2.old2/gexiv2-metadata.cpp	2013-05-05 19:14:39.000000000 +0200
+++ gexiv2/gexiv2-metadata.cpp	2013-05-05 22:37:20.843896756 +0200
@@ -708,6 +708,29 @@
     return FALSE;
 }
 
+gchar** gexiv2_metadata_get_tag_langalt(GExiv2Metadata *self, const gchar* tag) {
+    g_return_val_if_fail(GEXIV2_IS_METADATA(self), NULL);
+    g_return_val_if_fail(tag != NULL, NULL);
+    g_return_val_if_fail(self->priv->image.get() != NULL, NULL);
+    
+    if (gexiv2_metadata_is_xmp_tag(tag))
+        return gexiv2_metadata_get_xmp_tag_langalt(self, tag);
+    
+    return NULL;
+}
+
+gboolean gexiv2_metadata_set_tag_langalt(GExiv2Metadata *self, const gchar* tag, const gchar** values) {
+    g_return_val_if_fail(GEXIV2_IS_METADATA(self), FALSE);
+    g_return_val_if_fail(tag != NULL, FALSE);
+    g_return_val_if_fail(values != NULL, FALSE);
+    g_return_val_if_fail(self->priv->image.get() != NULL, FALSE);
+    
+    if (gexiv2_metadata_is_xmp_tag(tag))
+        return gexiv2_metadata_set_xmp_tag_langalt(self, tag, values);
+    
+    return FALSE;
+}
+
 glong gexiv2_metadata_get_tag_long(GExiv2Metadata *self, const gchar* tag) {
     g_return_val_if_fail(GEXIV2_IS_METADATA(self), 0);
     g_return_val_if_fail(tag != NULL, 0);
diff -uNr gexiv2.old2/gexiv2-metadata.h gexiv2/gexiv2-metadata.h
--- gexiv2.old2/gexiv2-metadata.h	2013-05-05 18:37:36.000000000 +0200
+++ gexiv2/gexiv2-metadata.h	2013-05-05 22:36:39.878748327 +0200
@@ -173,6 +173,22 @@
 gboolean		gexiv2_metadata_set_tag_multiple	(GExiv2Metadata *self, const gchar* tag, const gchar** values);
 
 /**
+ * gexiv2_metadata_get_tag_langalt:
+ * @tag: The name of the tag to get
+ *
+ * Returns: (transfer full) (allow-none) (array zero-terminated=1): The langalt values of that tag
+ */
+gchar**         gexiv2_metadata_get_tag_langalt    (GExiv2Metadata *self, const gchar* tag);
+
+/**
+ * gexiv2_metadata_set_tag_langalt:
+ * @values: (array zero-terminated=1): An array of tags that you want to set
+ *
+ * Returns: (transfer full): Boolean success value
+ */
+gboolean        gexiv2_metadata_set_tag_langalt    (GExiv2Metadata *self, const gchar* tag, const gchar** values);
+
+/**
  * gexiv2_metadata_get_exposure_time:
  * @nom: (out): The numerator
  * @den: (out): The denominator
diff -uNr gexiv2.old2/gexiv2-metadata-private.h gexiv2/gexiv2-metadata-private.h
--- gexiv2.old2/gexiv2-metadata-private.h	2013-05-05 19:12:49.000000000 +0200
+++ gexiv2/gexiv2-metadata-private.h	2013-05-05 22:37:43.698419070 +0200
@@ -61,6 +61,8 @@
 gboolean		gexiv2_metadata_set_xmp_tag_long	(GExiv2Metadata *self, const gchar* tag, glong value);
 gchar**			gexiv2_metadata_get_xmp_tag_multiple (GExiv2Metadata *self, const gchar* tag);
 gboolean		gexiv2_metadata_set_xmp_tag_multiple (GExiv2Metadata *self, const gchar* tag, const gchar** values);
+gchar**         gexiv2_metadata_get_xmp_tag_langalt (GExiv2Metadata *self, const gchar* tag);
+gboolean        gexiv2_metadata_set_xmp_tag_langalt (GExiv2Metadata *self, const gchar* tag, const gchar** values);
 
 const gchar*	gexiv2_metadata_get_xmp_tag_label		(const gchar* tag);
 const gchar*	gexiv2_metadata_get_xmp_tag_description	(const gchar* tag);
diff -uNr gexiv2.old2/gexiv2-metadata-xmp.cpp gexiv2/gexiv2-metadata-xmp.cpp
--- gexiv2.old2/gexiv2-metadata-xmp.cpp	2013-05-05 18:28:57.000000000 +0200
+++ gexiv2/gexiv2-metadata-xmp.cpp	2013-05-05 22:42:00.701673882 +0200
@@ -11,6 +11,7 @@
 #include "gexiv2-metadata.h"
 #include "gexiv2-metadata-private.h"
 #include <string>
+#include <glib.h>
 #include <glib-object.h>
 #include <exiv2/xmp.hpp>
 
@@ -247,6 +248,74 @@
     const gchar** values) {
     g_return_val_if_fail(GEXIV2_IS_METADATA (self), FALSE);
     g_return_val_if_fail(tag != NULL, FALSE);
+    g_return_val_if_fail(values != NULL, FALSE);
+    g_return_val_if_fail(self->priv->image.get() != NULL, FALSE);
+    
+    Exiv2::XmpData& xmp_data = self->priv->image->xmpData();
+    
+    try {
+        /* first clear existing tag */
+        Exiv2::XmpData::iterator it = xmp_data.findKey(Exiv2::XmpKey(tag));
+        while (it != xmp_data.end() && it->count() == 0)
+            it++;
+        
+        if (it != xmp_data.end())
+            xmp_data.erase (it);
+        
+        /* ... and then set the others */
+        const gchar **val_it = values;
+        while (*val_it != NULL) {
+            xmp_data[tag] = static_cast<const std::string> (*val_it);
+            ++val_it;
+        }
+        
+        return TRUE;
+    } catch (Exiv2::Error& e) {
+        LOG_ERROR(e);
+    }
+    
+    return FALSE;
+}
+
+gchar** gexiv2_metadata_get_xmp_tag_langalt (GExiv2Metadata *self, const gchar* tag) {
+    g_return_val_if_fail(GEXIV2_IS_METADATA (self), NULL);
+    g_return_val_if_fail(tag != NULL, NULL);
+    g_return_val_if_fail(self->priv->image.get() != NULL, NULL);
+    
+    Exiv2::XmpData& xmp_data = self->priv->image->xmpData();
+    
+    try {
+        Exiv2::XmpData::iterator it = xmp_data.findKey(Exiv2::XmpKey(tag));
+        while (it != xmp_data.end() && it->count() == 0)
+            it++;
+        
+        if (it != xmp_data.end()) {
+            int size = it->count ();
+            gchar **array = g_new (gchar*, size + 1);
+            array[size] = NULL;
+            
+            const Exiv2::LangAltValue &value = static_cast<const Exiv2::LangAltValue &>(it->value());
+            
+            int index = 0;
+            for (Exiv2::LangAltValue::ValueType::const_iterator i = value.value_.begin(); i != value.value_.end(); ++i)
+                array[index++] = g_strdup_printf("lang=\"%s\" %s", (i->first).c_str(), (i->second).c_str());
+            
+            return array;
+        }
+    } catch (Exiv2::Error& e) {
+        LOG_ERROR(e);
+    }
+    
+    gchar **array = g_new (gchar*, 1);
+    array[0] = NULL;
+    
+    return array;
+}
+
+gboolean gexiv2_metadata_set_xmp_tag_langalt (GExiv2Metadata *self, const gchar* tag, 
+    const gchar** values) {
+    g_return_val_if_fail(GEXIV2_IS_METADATA (self), FALSE);
+    g_return_val_if_fail(tag != NULL, FALSE);
     g_return_val_if_fail(values != NULL, FALSE);
     g_return_val_if_fail(self->priv->image.get() != NULL, FALSE);
     
