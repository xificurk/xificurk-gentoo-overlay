From 04923dfe8a577e3037c731eeb5d3436cc08500e9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Petr=20Mor=C3=A1vek=20[Xificurk]?= <xificurk@gmail.com>
Date: Sun, 21 Aug 2011 23:11:10 +0200
Subject: [PATCH] offset patch

---
 bindings/python/mapnik_stroke.cpp           |    4 +
 include/mapnik/ctrans.hpp                   |  213 ++++++++++++++++++++++++++-
 include/mapnik/line_pattern_symbolizer.hpp  |    3 +
 include/mapnik/stroke.hpp                   |    4 +
 src/agg/process_line_pattern_symbolizer.cpp |    3 +-
 src/agg/process_line_symbolizer.cpp         |    3 +-
 src/cairo_renderer.cpp                      |    6 +-
 src/line_pattern_symbolizer.cpp             |   14 ++-
 src/load_map.cpp                            |   14 ++-
 src/save_map.cpp                            |    9 +
 src/stroke.cpp                              |   14 ++
 11 files changed, 278 insertions(+), 9 deletions(-)

diff --git a/bindings/python/mapnik_stroke.cpp b/bindings/python/mapnik_stroke.cpp
index b045ec1..76461e1 100644
--- a/bindings/python/mapnik_stroke.cpp
+++ b/bindings/python/mapnik_stroke.cpp
@@ -146,6 +146,10 @@ void export_stroke ()
                       &stroke::set_opacity, 
                       "Gets or sets the opacity of this stroke.\n"
                       "The value is a float between 0 and 1.\n")
+        .add_property("offset",
+                      &stroke::get_offset,
+                      &stroke::set_offset,
+                      "Gets or sets the stroke offset in pixels.\n")
         .add_property("gamma",
                       &stroke::get_gamma,
                       &stroke::set_gamma, 
diff --git a/include/mapnik/ctrans.hpp b/include/mapnik/ctrans.hpp
index e18e80f..55a213d 100644
--- a/include/mapnik/ctrans.hpp
+++ b/include/mapnik/ctrans.hpp
@@ -32,6 +32,14 @@
 #include <mapnik/coord_array.hpp>
 #include <mapnik/proj_transform.hpp>
 
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#ifdef MAPNIK_DEBUG
+#include <iostream>
+#endif
+
 namespace mapnik {
 typedef coord_array<coord2d> CoordinateArray;
     
@@ -155,7 +163,210 @@ private:
     int dx_;
     int dy_;
 };
-   
+
+
+template <typename Transform,typename Geometry>
+struct MAPNIK_DECL coord_transform4 : coord_transform2<Transform, Geometry>
+{
+    coord_transform4(Transform const& t,
+                     Geometry const& geom,
+                     proj_transform const& prj_trans)
+        : coord_transform2<Transform, Geometry> (t, geom, prj_trans),
+        t_(t), 
+        geom_(geom), 
+        prj_trans_(prj_trans),
+        offset_(0.0), m_status(initial) {}
+
+    // Enum representing the status or the tranformation process.
+    enum status
+    {
+        initial,
+        start,
+        first,
+        process,
+        last_vertex,
+        angle_joint,
+        end
+    };
+
+    double get_offset() const
+    {
+        return offset_;
+    }
+
+    void set_offset(double offset)
+    {
+        offset_ = offset;
+    }
+
+    bool is_acute(double x0,double y0,double x1,double y1,double x2,double y2)
+    {
+        double dx0 = x0 - x1;
+        double dy0 = y0 - y1;
+        double dx1 = x2 - x1;
+        double dy1 = y2 - y1;
+        double product = dx0 * dx1 + dy0 * dy1;
+        return product > 0;
+    }
+
+     /**
+     * Reads the x and y values of the next vertex and assigns the
+     * values of the locations of the x and y parameters to them.
+     * Returns the next command associated with the vertex based
+     * from where in the line the point is read.
+     */
+    /*
+     * Basically copied out of mapservers line offset algorithm
+     * (msOffsetPolyline).
+     */
+    unsigned vertex(double * x , double  * y)
+    {
+        if (offset_==0.0)
+        {
+            return coord_transform2<Transform, Geometry>::vertex(x, y);
+        }
+
+        double z=0;
+        while(true){
+            switch(m_status)
+            {
+                case end:
+                    return SEG_END;
+                    break;
+                case initial:
+                    m_pre_cmd = geom_.vertex(x,y);
+                    prj_trans_.backward(*x,*y,z);
+                    t_.forward(x,y);
+                    m_pre_x = *x;
+                    m_pre_y = *y;
+                case start:
+                    m_cur_cmd = geom_.vertex(&m_cur_x, &m_cur_y);
+                    prj_trans_.backward(m_cur_x,m_cur_y,z);
+                    t_.forward(&m_cur_x,&m_cur_y);
+                case first:
+                    angle_a = atan2((m_pre_y-m_cur_y),(m_pre_x-m_cur_x));
+                    dx_pre = cos(angle_a + M_PI/2);
+                    dy_pre = sin(angle_a + M_PI/2);
+                    #ifdef MAPNIK_DEBUG
+                        std::clog << "offsetting line by: " << offset_ << "\n";
+                        std::clog << "initial dx=" << (dx_pre * offset_) << " dy=" << (dy_pre * offset_) << "\n";
+                    #endif
+                    *x = m_pre_x + (dx_pre * offset_);
+                    *y = m_pre_y + (dy_pre * offset_);
+                    m_status = process;
+                    return SEG_MOVETO;
+                case process:
+                    switch(m_cur_cmd)
+                    {
+                        case SEG_LINETO:
+                            m_next_cmd = geom_.vertex(&m_next_x, &m_next_y);
+                            prj_trans_.backward(m_next_x,m_next_y,z);
+                            t_.forward(&m_next_x,&m_next_y);
+                            switch(m_next_cmd)
+                            {
+                                case SEG_LINETO:
+                                    m_status = angle_joint;
+                                    break;
+                                default:
+                                    m_status = last_vertex;
+                                    break;
+                            }
+                            break;
+                        case SEG_END:
+                            m_status = end;
+                            return SEG_END;
+                    }
+                    break;
+                case last_vertex:
+                    dx_curr = cos(angle_a + M_PI/2);
+                    dy_curr = sin(angle_a + M_PI/2);
+                    *x = m_cur_x + (dx_curr * offset_);
+                    *y = m_cur_y + (dy_curr * offset_);
+                    m_status = end;
+                    return m_cur_cmd;
+                case angle_joint:
+                    dx_curr = cos(angle_a + M_PI/2);
+                    dy_curr = sin(angle_a + M_PI/2);
+
+                    angle_b = atan2((m_cur_y-m_next_y),(m_cur_x-m_next_x));
+                    double angle_ab = (angle_b - angle_a) - 2.0*M_PI*floor((angle_b - angle_a) / (2.0*M_PI)); // angle_ab = angle_b - angle_a in [0, 2*PI[
+                    #ifdef MAPNIK_DEBUG
+                        std::clog << "'Angle Joint' on segment (" << m_cur_x << ", " << m_cur_y << ")-(" << m_next_x << ", " << m_next_y << ") : \n";
+                        std::clog << "angle_a : " << angle_a << "  ";
+                        std::clog << "angle_b : " << angle_b << " ";
+                        std::clog << "angle_ab : " << angle_ab << "\n";
+                    #endif
+                    // on [0, 2*Pi[, tan(x/2) is not defined for x=Pi = very sharp spike
+                    if ( (angle_ab > M_PI - 0.001 * M_PI) && (angle_ab < M_PI + 0.001 * M_PI) )
+                    {
+                        #ifdef MAPNIK_DEBUG
+                            std::clog << "VERY sharp spike ! we're going to the next vertex\n";
+                        #endif
+                        // next vertex
+                        angle_a = atan2((m_pre_y-m_next_y),(m_pre_x-m_next_x));
+                        m_cur_x = m_next_x;
+                        m_cur_y = m_next_y;
+                        m_status = process;
+                        break; // goto switch on m_status then on m_cur_cmd
+                    }
+                    else
+                    {
+                        h = tan((angle_b - angle_a)/2.0);
+                        #ifdef MAPNIK_DEBUG
+                            std::clog << "angle is not a sharp spike : h : " << h << "\n";
+                        #endif
+                        *x = m_cur_x + (dx_curr - h * dy_curr) * offset_;
+                        *y = m_cur_y + (dy_curr + h * dx_curr) * offset_;
+                    }
+
+                    // Save old shit
+                    m_cur_x = m_next_x;
+                    m_cur_y = m_next_y;
+                    angle_a = angle_b;
+                    m_pre_cmd = m_cur_cmd;
+                    m_cur_cmd = m_next_cmd;
+                    m_status = process;
+                    return m_pre_cmd;
+            }
+        }
+    }
+
+    void rewind (unsigned pos)
+    {
+        geom_.rewind(pos);
+        m_status = initial;
+    }
+
+private:
+    Transform const& t_;
+    Geometry const& geom_;
+    proj_transform const& prj_trans_;
+    int offset_;
+    double dx_pre;
+    double dy_pre;
+    double dx_curr;
+    double dy_curr;
+    double base_shift;
+    double sin_curve;
+    double cos_curve;
+    double angle_a;
+    double angle_b;
+    double h;
+    // processing state
+    status       m_status;
+    // source vertex lookahead queue
+    unsigned       m_pre_cmd;
+    double         m_pre_x;
+    double         m_pre_y;
+    unsigned       m_cur_cmd;
+    double         m_cur_x;
+    double         m_cur_y;
+    unsigned       m_next_cmd;
+    double         m_next_x;
+    double         m_next_y;
+};
+
+
 class CoordTransform
 {
 private:
diff --git a/include/mapnik/line_pattern_symbolizer.hpp b/include/mapnik/line_pattern_symbolizer.hpp
index 88cea40..7b73195 100644
--- a/include/mapnik/line_pattern_symbolizer.hpp
+++ b/include/mapnik/line_pattern_symbolizer.hpp
@@ -35,6 +35,9 @@ struct MAPNIK_DECL line_pattern_symbolizer :
 {
     line_pattern_symbolizer(path_expression_ptr file);
     line_pattern_symbolizer(line_pattern_symbolizer const& rhs);
+    double offset_;
+    double get_offset() const;
+    void set_offset(double offset);
 };    
 }
 
diff --git a/include/mapnik/stroke.hpp b/include/mapnik/stroke.hpp
index 1948788..4542e0a 100644
--- a/include/mapnik/stroke.hpp
+++ b/include/mapnik/stroke.hpp
@@ -65,6 +65,7 @@ class MAPNIK_DECL stroke
     color c_;
     double width_;
     double opacity_; // 0.0 - 1.0
+    double offset_;
     line_cap_e  line_cap_;
     line_join_e line_join_;
     double gamma_;
@@ -84,6 +85,9 @@ public:
 
     void set_opacity(double opacity);
     double get_opacity() const;
+    
+    void set_offset(double offset);
+    double get_offset() const;
         
     void set_line_cap(line_cap_e line_cap);
     line_cap_e get_line_cap() const;
diff --git a/src/agg/process_line_pattern_symbolizer.cpp b/src/agg/process_line_pattern_symbolizer.cpp
index 6974cae..8c4e046 100644
--- a/src/agg/process_line_pattern_symbolizer.cpp
+++ b/src/agg/process_line_pattern_symbolizer.cpp
@@ -48,7 +48,7 @@ void  agg_renderer<T>::process(line_pattern_symbolizer const& sym,
                                Feature const& feature,
                                proj_transform const& prj_trans)
 {
-    typedef  coord_transform2<CoordTransform,geometry_type> path_type;
+    typedef  coord_transform4<CoordTransform,geometry_type> path_type;
     typedef agg::line_image_pattern<agg::pattern_filter_bilinear_rgba8> pattern_type;
     typedef agg::renderer_base<agg::pixfmt_rgba32_plain> renderer_base;
     typedef agg::renderer_outline_image<renderer_base, pattern_type> renderer_type;
@@ -80,6 +80,7 @@ void  agg_renderer<T>::process(line_pattern_symbolizer const& sym,
         if (geom.num_points() > 1)
         {
             path_type path(t_,geom,prj_trans);
+            path.set_offset(sym.get_offset());
             ras.add_path(path);
             if (writer.first) writer.first->add_line(path, feature, t_, writer.second);
         }
diff --git a/src/agg/process_line_symbolizer.cpp b/src/agg/process_line_symbolizer.cpp
index 586676e..c110b54 100644
--- a/src/agg/process_line_symbolizer.cpp
+++ b/src/agg/process_line_symbolizer.cpp
@@ -50,7 +50,7 @@ void agg_renderer<T>::process(line_symbolizer const& sym,
                               proj_transform const& prj_trans)
 {
     typedef agg::renderer_base<agg::pixfmt_rgba32_plain> ren_base;
-    typedef coord_transform2<CoordTransform,geometry_type> path_type;
+    typedef coord_transform4<CoordTransform,geometry_type> path_type;
     //typedef agg::renderer_outline_aa<ren_base> renderer_oaa;
     //typedef agg::rasterizer_outline_aa<renderer_oaa> rasterizer_outline_aa;
     typedef agg::renderer_scanline_aa_solid<ren_base> renderer;
@@ -77,6 +77,7 @@ void agg_renderer<T>::process(line_symbolizer const& sym,
         if (geom.num_points() > 1)
         {
             path_type path(t_,geom,prj_trans);
+            path.set_offset(stroke_.get_offset());
 
             if (stroke_.has_dash())
             {
diff --git a/src/cairo_renderer.cpp b/src/cairo_renderer.cpp
index 4d2b975..4d571a0 100644
--- a/src/cairo_renderer.cpp
+++ b/src/cairo_renderer.cpp
@@ -874,7 +874,7 @@ void cairo_renderer_base::process(line_symbolizer const& sym,
                                   Feature const& feature,
                                   proj_transform const& prj_trans)
 {
-    typedef coord_transform2<CoordTransform,geometry_type> path_type;
+    typedef coord_transform4<CoordTransform,geometry_type> path_type;
 
     cairo_context context(context_);
     mapnik::stroke const& stroke_ = sym.get_stroke();
@@ -889,6 +889,7 @@ void cairo_renderer_base::process(line_symbolizer const& sym,
         {
             cairo_context context(context_);
             path_type path(t_, geom, prj_trans);
+            path.set_offset(stroke_.get_offset());
 
             if (stroke_.has_dash())
             {
@@ -1276,7 +1277,7 @@ void cairo_renderer_base::process(line_pattern_symbolizer const& sym,
                                   Feature const& feature,
                                   proj_transform const& prj_trans)
 {
-    typedef coord_transform2<CoordTransform,geometry_type> path_type;
+    typedef coord_transform4<CoordTransform,geometry_type> path_type;
     
     std::string filename = path_processor_type::evaluate( *sym.get_filename(), feature);
     boost::optional<mapnik::marker_ptr> marker = mapnik::marker_cache::instance()->find(filename,true);
@@ -1299,6 +1300,7 @@ void cairo_renderer_base::process(line_pattern_symbolizer const& sym,
         if (geom.num_points() > 1)
         {
             path_type path(t_, geom, prj_trans);
+            path.set_offset(sym.get_offset());
             double length(0);
             double x0(0), y0(0);
             double x, y;
diff --git a/src/line_pattern_symbolizer.cpp b/src/line_pattern_symbolizer.cpp
index 4703f98..e147152 100644
--- a/src/line_pattern_symbolizer.cpp
+++ b/src/line_pattern_symbolizer.cpp
@@ -29,9 +29,19 @@ namespace mapnik
 {
     
 line_pattern_symbolizer::line_pattern_symbolizer(path_expression_ptr file) 
-    : symbolizer_with_image(file), symbolizer_base() {}
+    : symbolizer_with_image(file), symbolizer_base(), offset_(0.0) {}
 
 line_pattern_symbolizer::line_pattern_symbolizer(line_pattern_symbolizer const& rhs)
-    : symbolizer_with_image(rhs), symbolizer_base(rhs) {}
+    : symbolizer_with_image(rhs), symbolizer_base(rhs), offset_(rhs.offset_) {}
+
+double line_pattern_symbolizer::get_offset() const
+{
+    return offset_;
+}
+
+void line_pattern_symbolizer::set_offset(double offset)
+{
+    offset_=offset;
+}
 
 }
diff --git a/src/load_map.cpp b/src/load_map.cpp
index de40c13..43dcd40 100644
--- a/src/load_map.cpp
+++ b/src/load_map.cpp
@@ -1091,11 +1091,12 @@ void map_parser::parse_markers_symbolizer( rule & rule, ptree const & sym )
 
 void map_parser::parse_line_pattern_symbolizer( rule & rule, ptree const & sym )
 {
-    ensure_attrs(sym, "LinePatternSymbolizer", "file,base,meta-writer,meta-output");
+    ensure_attrs(sym, "LinePatternSymbolizer", "file,base,offset,meta-writer,meta-output");
     try
     {
         std::string file = get_attr<std::string>(sym, "file");
         optional<std::string> base = get_opt_attr<std::string>(sym, "base");
+        optional<double> offset = get_opt_attr<double>(sym, "offset");
             
         try
         {
@@ -1112,6 +1113,11 @@ void map_parser::parse_line_pattern_symbolizer( rule & rule, ptree const & sym )
 
             line_pattern_symbolizer symbol(parse_path(file));
 
+            if (offset)
+            {
+                symbol.set_offset( *offset );
+            }
+
             parse_metawriter_in_symbolizer(symbol, sym);
             rule.append(symbol);
         }
@@ -1711,6 +1717,10 @@ void map_parser::parse_stroke(stroke & strk, ptree const & sym)
     optional<double> opacity = get_opt_attr<double>(sym, "stroke-opacity");
     if (opacity) strk.set_opacity(*opacity);
 
+    // stroke-offset
+    optional<double> offset = get_opt_attr<double>(sym, "stroke-offset");
+    if (offset) strk.set_offset(*offset);
+
     // stroke-linejoin
     optional<line_join_e> line_join = get_opt_attr<line_join_e>(sym, "stroke-linejoin");
     if (line_join) strk.set_line_join(*line_join);
@@ -1771,7 +1781,7 @@ void map_parser::parse_stroke(stroke & strk, ptree const & sym)
 void map_parser::parse_line_symbolizer( rule & rule, ptree const & sym )
 {
     std::stringstream s;
-    s << "stroke,stroke-width,stroke-opacity,stroke-linejoin,"
+    s << "stroke,stroke-width,stroke-opacity,stroke-offset,stroke-linejoin,"
       << "stroke-linecap,stroke-gamma,stroke-dash-offset,stroke-dasharray,"
       << "meta-writer,meta-output";
 
diff --git a/src/save_map.cpp b/src/save_map.cpp
index 0534fd2..bd80a25 100644
--- a/src/save_map.cpp
+++ b/src/save_map.cpp
@@ -90,6 +90,11 @@ public:
             ptree::value_type("LinePatternSymbolizer",
                               ptree()))->second;
 
+        if (sym.get_offset() != 0.0 || explicit_defaults_ )
+        {
+            set_attr( sym_node, "offset", sym.get_offset() );
+        }
+
         add_image_attributes( sym_node, sym );
         add_metawriter_attributes(sym_node, sym);
     }
@@ -577,6 +582,10 @@ private:
         {
             set_attr( node, "stroke-opacity", strk.get_opacity() );
         }
+        if ( strk.get_offset() != dfl.get_offset() || explicit_defaults_ )
+        {
+            set_attr( node, "stroke-offset", strk.get_offset() );
+        }
         if ( strk.get_line_join() != dfl.get_line_join() || explicit_defaults_ )
         {
             set_attr( node, "stroke-linejoin", strk.get_line_join() );
diff --git a/src/stroke.cpp b/src/stroke.cpp
index 0a9ecb4..6eb152f 100644
--- a/src/stroke.cpp
+++ b/src/stroke.cpp
@@ -51,6 +51,7 @@ stroke::stroke()
     : c_(0,0,0),
       width_(1.0),
       opacity_(1.0),
+      offset_(0.0),
       line_cap_(BUTT_CAP),
       line_join_(MITER_JOIN),
       gamma_(1.0),
@@ -61,6 +62,7 @@ stroke::stroke(color const& c, double width)
     : c_(c),
       width_(width),
       opacity_(1.0),
+      offset_(0.0),
       line_cap_(BUTT_CAP),
       line_join_(MITER_JOIN),
       gamma_(1.0),
@@ -71,6 +73,7 @@ stroke::stroke(stroke const& other)
     : c_(other.c_),
       width_(other.width_),
       opacity_(other.opacity_),
+      offset_(other.offset_),
       line_cap_(other.line_cap_),
       line_join_(other.line_join_),
       gamma_(other.gamma_),
@@ -115,6 +118,16 @@ double stroke::get_opacity() const
     return opacity_;
 }
 
+void stroke::set_offset(double offset)
+{
+    offset_=offset;
+}
+
+double stroke::get_offset() const
+{
+    return offset_;
+}
+
 void stroke::set_line_cap(line_cap_e line_cap)
 {
     line_cap_=line_cap;
@@ -175,6 +188,7 @@ void stroke::swap(const stroke& other) throw()
     c_=other.c_;
     width_=other.width_;
     opacity_=other.opacity_;
+    offset_=other.offset_;
     line_cap_=other.line_cap_;
     line_join_=other.line_join_;
     gamma_=other.gamma_;
-- 
1.7.3.4

